/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/websocket";
exports.ids = ["vendor-chunks/websocket"];
exports.modules = {

/***/ "(action-browser)/./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./lib/websocket */ \"(action-browser)/./node_modules/websocket/lib/websocket.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBQSx5SEFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2luZGV4LmpzPzMwM2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./lib/websocket */ \"(rsc)/./node_modules/websocket/lib/websocket.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsOEdBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9pbmRleC5qcz8zMDNkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar Deprecation = {\n    disableWarnings: false,\n    deprecationWarningMap: {},\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn(\"DEPRECATION WARNING: \" + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\nmodule.exports = Deprecation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL0RlcHJlY2F0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsY0FBYztJQUNkQyxpQkFBaUI7SUFFakJDLHVCQUF1QixDQUV2QjtJQUVBQyxNQUFNLFNBQVNDLGVBQWU7UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsZUFBZSxJQUFJLElBQUksQ0FBQ0MscUJBQXFCLENBQUNFLGdCQUFnQixFQUFFO1lBQ3RFQyxRQUFRRixJQUFJLENBQUMsMEJBQTBCLElBQUksQ0FBQ0QscUJBQXFCLENBQUNFLGdCQUFnQjtZQUNsRixJQUFJLENBQUNGLHFCQUFxQixDQUFDRSxnQkFBZ0IsR0FBRztRQUNsRDtJQUNKO0FBQ0o7QUFFQUUsT0FBT0MsT0FBTyxHQUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL0RlcHJlY2F0aW9uLmpzPzc5YzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgRGVwcmVjYXRpb24gPSB7XG4gICAgZGlzYWJsZVdhcm5pbmdzOiBmYWxzZSxcblxuICAgIGRlcHJlY2F0aW9uV2FybmluZ01hcDoge1xuXG4gICAgfSxcblxuICAgIHdhcm46IGZ1bmN0aW9uKGRlcHJlY2F0aW9uTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZVdhcm5pbmdzICYmIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nTWFwW2RlcHJlY2F0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogJyArIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nTWFwW2RlcHJlY2F0aW9uTmFtZV0pO1xuICAgICAgICAgICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmdNYXBbZGVwcmVjYXRpb25OYW1lXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXByZWNhdGlvbjtcbiJdLCJuYW1lcyI6WyJEZXByZWNhdGlvbiIsImRpc2FibGVXYXJuaW5ncyIsImRlcHJlY2F0aW9uV2FybmluZ01hcCIsIndhcm4iLCJkZXByZWNhdGlvbk5hbWUiLCJjb25zb2xlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/Deprecation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar Deprecation = {\n    disableWarnings: false,\n    deprecationWarningMap: {},\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn(\"DEPRECATION WARNING: \" + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\nmodule.exports = Deprecation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLGNBQWM7SUFDZEMsaUJBQWlCO0lBRWpCQyx1QkFBdUIsQ0FFdkI7SUFFQUMsTUFBTSxTQUFTQyxlQUFlO1FBQzFCLElBQUksQ0FBQyxJQUFJLENBQUNILGVBQWUsSUFBSSxJQUFJLENBQUNDLHFCQUFxQixDQUFDRSxnQkFBZ0IsRUFBRTtZQUN0RUMsUUFBUUYsSUFBSSxDQUFDLDBCQUEwQixJQUFJLENBQUNELHFCQUFxQixDQUFDRSxnQkFBZ0I7WUFDbEYsSUFBSSxDQUFDRixxQkFBcUIsQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDbEQ7SUFDSjtBQUNKO0FBRUFFLE9BQU9DLE9BQU8sR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcz83OWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIERlcHJlY2F0aW9uID0ge1xuICAgIGRpc2FibGVXYXJuaW5nczogZmFsc2UsXG5cbiAgICBkZXByZWNhdGlvbldhcm5pbmdNYXA6IHtcblxuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbihkZXByZWNhdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVXYXJuaW5ncyAmJiB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6ICcgKyB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nTWFwW2RlcHJlY2F0aW9uTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwcmVjYXRpb247XG4iXSwibmFtZXMiOlsiRGVwcmVjYXRpb24iLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGlvbldhcm5pbmdNYXAiLCJ3YXJuIiwiZGVwcmVjYXRpb25OYW1lIiwiY29uc29sZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/Deprecation.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"(action-browser)/./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"(action-browser)/./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"(action-browser)/./node_modules/yaeti/index.js\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nmodule.exports = W3CWebSocket;\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true; // Required in the W3C API.\n    var self = this;\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = \"\";\n    this._bufferedAmount = 0; // Hack, always 0.\n    this._binaryType = \"arraybuffer\"; // TODO: Should be 'blob' by default, but Node has no Blob.\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n    this._client.on(\"connect\", function(connection) {\n        onConnect.call(self, connection);\n    });\n    this._client.on(\"connectFailed\", function() {\n        onConnectFailed.call(self);\n    });\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url: {\n        get: function() {\n            return this._url;\n        }\n    },\n    readyState: {\n        get: function() {\n            return this._readyState;\n        }\n    },\n    protocol: {\n        get: function() {\n            return this._protocol;\n        }\n    },\n    extensions: {\n        get: function() {\n            return this._extensions;\n        }\n    },\n    bufferedAmount: {\n        get: function() {\n            return this._bufferedAmount;\n        }\n    }\n});\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== \"arraybuffer\") {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error(\"cannot call send() while not connected\");\n    }\n    // Text.\n    if (typeof data === \"string\" || data instanceof String) {\n        this._connection.sendUTF(data);\n    } else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        } else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        } else {\n            throw new Error(\"unknown binary data:\", data);\n        }\n    }\n};\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState){\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on(\"connect\", function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n/**\n * Private API.\n */ function createCloseEvent(code, reason) {\n    var event = new yaeti.Event(\"close\");\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = typeof code === \"undefined\" || code === 1000;\n    return event;\n}\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event(\"message\");\n    event.data = data;\n    return event;\n}\nfunction onConnect(connection) {\n    var self = this;\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n    this._connection.on(\"close\", function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n    this._connection.on(\"message\", function(msg) {\n        onMessage.call(self, msg);\n    });\n    this.dispatchEvent(new yaeti.Event(\"open\"));\n}\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    try {\n        this.dispatchEvent(new yaeti.Event(\"error\"));\n    } finally{\n        this.dispatchEvent(createCloseEvent(1006, \"connection failed\"));\n    }\n}\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    this.dispatchEvent(createCloseEvent(code, reason || \"\"));\n}\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    } else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === \"arraybuffer\") {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for(var i = 0, len = buffer.length; i < len; ++i){\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1czQ1dlYlNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLGtCQUFrQkMsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFHcEIsTUFBTUcsYUFBYTtBQUNuQixNQUFNQyxPQUFPO0FBQ2IsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxTQUFTO0FBR2ZDLE9BQU9DLE9BQU8sR0FBR0M7QUFHakIsU0FBU0EsYUFBYUMsR0FBRyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxjQUFjLEVBQUVDLFlBQVk7SUFDL0UsNEJBQTRCO0lBQzVCYixNQUFNYyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBRTNCLHlCQUF5QjtJQUN6QkYsZUFBZUEsZ0JBQWdCLENBQUM7SUFDaENBLGFBQWFHLGlCQUFpQixHQUFHLE1BQU8sMkJBQTJCO0lBRW5FLElBQUlDLE9BQU8sSUFBSTtJQUVmLElBQUksQ0FBQ0MsSUFBSSxHQUFHVjtJQUNaLElBQUksQ0FBQ1csV0FBVyxHQUFHbEI7SUFDbkIsSUFBSSxDQUFDbUIsU0FBUyxHQUFHQztJQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLGVBQWUsR0FBRyxHQUFJLGtCQUFrQjtJQUM3QyxJQUFJLENBQUNDLFdBQVcsR0FBRyxlQUFnQiwyREFBMkQ7SUFFOUYsb0NBQW9DO0lBQ3BDLElBQUksQ0FBQ0MsV0FBVyxHQUFHSjtJQUVuQiw0QkFBNEI7SUFDNUIsSUFBSSxDQUFDSyxPQUFPLEdBQUcsSUFBSTdCLGdCQUFnQmdCO0lBRW5DLElBQUksQ0FBQ2EsT0FBTyxDQUFDQyxFQUFFLENBQUMsV0FBVyxTQUFTQyxVQUFVO1FBQzFDQyxVQUFVZCxJQUFJLENBQUNFLE1BQU1X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QVlGLE9BQU9HLE1BQU07WUFDL0MsSUFBSUMsT0FBTyxJQUFJQyxXQUFXSjtZQUMxQixJQUFLLElBQUlLLElBQUUsR0FBR0MsTUFBSVAsT0FBT0csTUFBTSxFQUFFRyxJQUFFQyxLQUFLLEVBQUVELEVBQUc7Z0JBQ3pDRixJQUFJLENBQUNFLEVBQUUsR0FBR04sTUFBTSxDQUFDTSxFQUFFO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDWCxhQUFhLENBQUNKLG1CQUFtQlU7UUFDMUM7SUFDSjtBQUNKO0FBR0EsU0FBU0w7SUFDTCxJQUFJLENBQUN6QyxPQUFPLENBQUNxRCxrQkFBa0I7SUFDL0IsSUFBSSxJQUFJLENBQUN0RCxXQUFXLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxXQUFXLENBQUNzRCxrQkFBa0I7SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1czQ1dlYlNvY2tldC5qcz8zMzBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIFdlYlNvY2tldENsaWVudCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Q2xpZW50Jyk7XG52YXIgdG9CdWZmZXIgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpO1xudmFyIHlhZXRpID0gcmVxdWlyZSgneWFldGknKTtcblxuXG5jb25zdCBDT05ORUNUSU5HID0gMDtcbmNvbnN0IE9QRU4gPSAxO1xuY29uc3QgQ0xPU0lORyA9IDI7XG5jb25zdCBDTE9TRUQgPSAzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVzNDV2ViU29ja2V0O1xuXG5cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmwsIHByb3RvY29scywgb3JpZ2luLCBoZWFkZXJzLCByZXF1ZXN0T3B0aW9ucywgY2xpZW50Q29uZmlnKSB7XG4gICAgLy8gTWFrZSB0aGlzIGFuIEV2ZW50VGFyZ2V0LlxuICAgIHlhZXRpLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBTYW5pdGl6ZSBjbGllbnRDb25maWcuXG4gICAgY2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnIHx8IHt9O1xuICAgIGNsaWVudENvbmZpZy5hc3NlbWJsZUZyYWdtZW50cyA9IHRydWU7ICAvLyBSZXF1aXJlZCBpbiB0aGUgVzNDIEFQSS5cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ09OTkVDVElORztcbiAgICB0aGlzLl9wcm90b2NvbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gJyc7XG4gICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwOyAgLy8gSGFjaywgYWx3YXlzIDAuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7ICAvLyBUT0RPOiBTaG91bGQgYmUgJ2Jsb2InIGJ5IGRlZmF1bHQsIGJ1dCBOb2RlIGhhcyBubyBCbG9iLlxuXG4gICAgLy8gVGhlIFdlYlNvY2tldENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIC8vIFdlYlNvY2tldENsaWVudCBpbnN0YW5jZS5cbiAgICB0aGlzLl9jbGllbnQgPSBuZXcgV2ViU29ja2V0Q2xpZW50KGNsaWVudENvbmZpZyk7XG5cbiAgICB0aGlzLl9jbGllbnQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIG9uQ29ubmVjdC5jYWxsKHNlbGYsIGNvbm5lY3Rpb24pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0RmFpbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uQ29ubmVjdEZhaWxlZC5jYWxsKHNlbGYpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY2xpZW50LmNvbm5lY3QodXJsLCBwcm90b2NvbHMsIG9yaWdpbiwgaGVhZGVycywgcmVxdWVzdE9wdGlvbnMpO1xufVxuXG5cbi8vIEV4cG9zZSBXM0MgcmVhZCBvbmx5IGF0dHJpYnV0ZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXM0NXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gICAgdXJsOiAgICAgICAgICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3VybDsgICAgICAgICAgICB9IH0sXG4gICAgcmVhZHlTdGF0ZTogICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7ICAgICB9IH0sXG4gICAgcHJvdG9jb2w6ICAgICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3Byb3RvY29sOyAgICAgICB9IH0sXG4gICAgZXh0ZW5zaW9uczogICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2V4dGVuc2lvbnM7ICAgICB9IH0sXG4gICAgYnVmZmVyZWRBbW91bnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50OyB9IH1cbn0pO1xuXG5cbi8vIEV4cG9zZSBXM0Mgd3JpdGUvcmVhZCBhdHRyaWJ1dGVzLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICAgIGJpbmFyeVR5cGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEp1c3QgJ2FycmF5YnVmZmVyJyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignanVzdCBcImFycmF5YnVmZmVyXCIgdHlwZSBhbGxvd2VkIGZvciBcImJpbmFyeVR5cGVcIiBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy8gRXhwb3NlIFczQyByZWFkeVN0YXRlIGNvbnN0YW50cyBpbnRvIHRoZSBXZWJTb2NrZXQgaW5zdGFuY2UgYXMgVzNDIHN0YXRlcy5cbltbJ0NPTk5FQ1RJTkcnLENPTk5FQ1RJTkddLCBbJ09QRU4nLE9QRU5dLCBbJ0NMT1NJTkcnLENMT1NJTkddLCBbJ0NMT1NFRCcsQ0xPU0VEXV0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXM0NXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eVswXSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvcGVydHlbMV07IH1cbiAgICB9KTtcbn0pO1xuXG4vLyBBbHNvIGV4cG9zZSBXM0MgcmVhZHlTdGF0ZSBjb25zdGFudHMgaW50byB0aGUgV2ViU29ja2V0IGNsYXNzIChub3QgZGVmaW5lZCBieSB0aGUgVzNDLFxuLy8gYnV0IHRoZXJlIGFyZSBzbyBtYW55IGxpYnMgcmVseWluZyBvbiB0aGVtKS5cbltbJ0NPTk5FQ1RJTkcnLENPTk5FQ1RJTkddLCBbJ09QRU4nLE9QRU5dLCBbJ0NMT1NJTkcnLENMT1NJTkddLCBbJ0NMT1NFRCcsQ0xPU0VEXV0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXM0NXZWJTb2NrZXQsIHByb3BlcnR5WzBdLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBwcm9wZXJ0eVsxXTsgfVxuICAgIH0pO1xufSk7XG5cblxuVzNDV2ViU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBPUEVOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNhbGwgc2VuZCgpIHdoaWxlIG5vdCBjb25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBUZXh0LlxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgfHwgZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmRVVEYoZGF0YSk7XG4gICAgfVxuICAgIC8vIEJpbmFyeS5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBCdWZmZXIuXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmRCeXRlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcgY29udmVydCBpdCB0byBOb2RlIEJ1ZmZlci5cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kQnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYmluYXJ5IGRhdGE6JywgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblczQ1dlYlNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBzd2l0Y2godGhpcy5fcmVhZHlTdGF0ZSkge1xuICAgICAgICBjYXNlIENPTk5FQ1RJTkc6XG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCBoYXZlIHRoZSBXZWJTb2NrZXRDb25uZWN0aW9uIGluc3RhbmNlIHlldCBzbyBub1xuICAgICAgICAgICAgLy8gd2F5IHRvIGNsb3NlIHRoZSBUQ1AgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIC8vIEFydGlmaWNpYWxseSBpbnZva2UgdGhlIG9uQ29ubmVjdEZhaWxlZCBldmVudC5cbiAgICAgICAgICAgIG9uQ29ubmVjdEZhaWxlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gQW5kIGNsb3NlIGlmIGl0IGNvbm5lY3RzIGFmdGVyIGEgd2hpbGUuXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QRU46XG4gICAgICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0lORztcbiAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDTE9TSU5HOlxuICAgICAgICBjYXNlIENMT1NFRDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBQcml2YXRlIEFQSS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb3NlRXZlbnQoY29kZSwgcmVhc29uKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IHlhZXRpLkV2ZW50KCdjbG9zZScpO1xuXG4gICAgZXZlbnQuY29kZSA9IGNvZGU7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50Lndhc0NsZWFuID0gKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJyB8fCBjb2RlID09PSAxMDAwKTtcblxuICAgIHJldHVybiBldmVudDtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRXZlbnQoZGF0YSkge1xuICAgIHZhciBldmVudCA9IG5ldyB5YWV0aS5FdmVudCgnbWVzc2FnZScpO1xuXG4gICAgZXZlbnQuZGF0YSA9IGRhdGE7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuZnVuY3Rpb24gb25Db25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gT1BFTjtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLl9wcm90b2NvbCA9IGNvbm5lY3Rpb24ucHJvdG9jb2w7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGNvbm5lY3Rpb24uZXh0ZW5zaW9ucztcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgICAgIG9uQ2xvc2UuY2FsbChzZWxmLCBjb2RlLCByZWFzb24pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBvbk1lc3NhZ2UuY2FsbChzZWxmLCBtc2cpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyB5YWV0aS5FdmVudCgnb3BlbicpKTtcbn1cblxuXG5mdW5jdGlvbiBvbkNvbm5lY3RGYWlsZWQoKSB7XG4gICAgZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBDTE9TRUQ7XG5cbiAgICB0cnkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHlhZXRpLkV2ZW50KCdlcnJvcicpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlQ2xvc2VFdmVudCgxMDA2LCAnY29ubmVjdGlvbiBmYWlsZWQnKSk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBDTE9TRUQ7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlQ2xvc2VFdmVudChjb2RlLCByZWFzb24gfHwgJycpKTtcbn1cblxuXG5mdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnV0ZjhEYXRhKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVNZXNzYWdlRXZlbnQobWVzc2FnZS51dGY4RGF0YSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXNzYWdlLmJpbmFyeURhdGEpIHtcbiAgICAgICAgLy8gTXVzdCBjb252ZXJ0IGZyb20gTm9kZSBCdWZmZXIgdG8gQXJyYXlCdWZmZXIuXG4gICAgICAgIC8vIFRPRE86IG9yIHRvIGEgQmxvYiAod2hpY2ggZG9lcyBub3QgZXhpc3QgaW4gTm9kZSEpLlxuICAgICAgICBpZiAodGhpcy5iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbWVzc2FnZS5iaW5hcnlEYXRhO1xuICAgICAgICAgICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1idWZmZXIubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVNZXNzYWdlRXZlbnQoYXJyYXlidWZmZXIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJXZWJTb2NrZXRDbGllbnQiLCJyZXF1aXJlIiwidG9CdWZmZXIiLCJ5YWV0aSIsIkNPTk5FQ1RJTkciLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIm1vZHVsZSIsImV4cG9ydHMiLCJXM0NXZWJTb2NrZXQiLCJ1cmwiLCJwcm90b2NvbHMiLCJvcmlnaW4iLCJoZWFkZXJzIiwicmVxdWVzdE9wdGlvbnMiLCJjbGllbnRDb25maWciLCJFdmVudFRhcmdldCIsImNhbGwiLCJhc3NlbWJsZUZyYWdtZW50cyIsInNlbGYiLCJfdXJsIiwiX3JlYWR5U3RhdGUiLCJfcHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJfZXh0ZW5zaW9ucyIsIl9idWZmZXJlZEFtb3VudCIsIl9iaW5hcnlUeXBlIiwiX2Nvbm5lY3Rpb24iLCJfY2xpZW50Iiwib24iLCJjb25uZWN0aW9uIiwib25Db25uZWN0Iiwib25Db25uZWN0RmFpbGVkIiwiY29ubmVjdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJnZXQiLCJyZWFkeVN0YXRlIiwicHJvdG9jb2wiLCJleHRlbnNpb25zIiwiYnVmZmVyZWRBbW91bnQiLCJiaW5hcnlUeXBlIiwic2V0IiwidHlwZSIsIlN5bnRheEVycm9yIiwiZm9yRWFjaCIsInByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJzZW5kIiwiZGF0YSIsIkVycm9yIiwiU3RyaW5nIiwic2VuZFVURiIsIkJ1ZmZlciIsInNlbmRCeXRlcyIsImJ5dGVMZW5ndGgiLCJjbG9zZSIsImNvZGUiLCJyZWFzb24iLCJjcmVhdGVDbG9zZUV2ZW50IiwiZXZlbnQiLCJFdmVudCIsIndhc0NsZWFuIiwiY3JlYXRlTWVzc2FnZUV2ZW50Iiwib25DbG9zZSIsIm1zZyIsIm9uTWVzc2FnZSIsImRpc3BhdGNoRXZlbnQiLCJkZXN0cm95IiwibWVzc2FnZSIsInV0ZjhEYXRhIiwiYmluYXJ5RGF0YSIsImJ1ZmZlciIsImFycmF5YnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJsZW5ndGgiLCJ2aWV3IiwiVWludDhBcnJheSIsImkiLCJsZW4iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/W3CWebSocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"(rsc)/./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"(rsc)/./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"(rsc)/./node_modules/yaeti/index.js\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nmodule.exports = W3CWebSocket;\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true; // Required in the W3C API.\n    var self = this;\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = \"\";\n    this._bufferedAmount = 0; // Hack, always 0.\n    this._binaryType = \"arraybuffer\"; // TODO: Should be 'blob' by default, but Node has no Blob.\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n    this._client.on(\"connect\", function(connection) {\n        onConnect.call(self, connection);\n    });\n    this._client.on(\"connectFailed\", function() {\n        onConnectFailed.call(self);\n    });\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url: {\n        get: function() {\n            return this._url;\n        }\n    },\n    readyState: {\n        get: function() {\n            return this._readyState;\n        }\n    },\n    protocol: {\n        get: function() {\n            return this._protocol;\n        }\n    },\n    extensions: {\n        get: function() {\n            return this._extensions;\n        }\n    },\n    bufferedAmount: {\n        get: function() {\n            return this._bufferedAmount;\n        }\n    }\n});\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== \"arraybuffer\") {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error(\"cannot call send() while not connected\");\n    }\n    // Text.\n    if (typeof data === \"string\" || data instanceof String) {\n        this._connection.sendUTF(data);\n    } else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        } else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        } else {\n            throw new Error(\"unknown binary data:\", data);\n        }\n    }\n};\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState){\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on(\"connect\", function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n/**\n * Private API.\n */ function createCloseEvent(code, reason) {\n    var event = new yaeti.Event(\"close\");\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = typeof code === \"undefined\" || code === 1000;\n    return event;\n}\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event(\"message\");\n    event.data = data;\n    return event;\n}\nfunction onConnect(connection) {\n    var self = this;\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n    this._connection.on(\"close\", function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n    this._connection.on(\"message\", function(msg) {\n        onMessage.call(self, msg);\n    });\n    this.dispatchEvent(new yaeti.Event(\"open\"));\n}\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    try {\n        this.dispatchEvent(new yaeti.Event(\"error\"));\n    } finally{\n        this.dispatchEvent(createCloseEvent(1006, \"connection failed\"));\n    }\n}\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    this.dispatchEvent(createCloseEvent(code, reason || \"\"));\n}\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    } else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === \"arraybuffer\") {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for(var i = 0, len = buffer.length; i < len; ++i){\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxrQkFBa0JDLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBR3BCLE1BQU1HLGFBQWE7QUFDbkIsTUFBTUMsT0FBTztBQUNiLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUdmQyxPQUFPQyxPQUFPLEdBQUdDO0FBR2pCLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxZQUFZO0lBQy9FLDRCQUE0QjtJQUM1QmIsTUFBTWMsV0FBVyxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUUzQix5QkFBeUI7SUFDekJGLGVBQWVBLGdCQUFnQixDQUFDO0lBQ2hDQSxhQUFhRyxpQkFBaUIsR0FBRyxNQUFPLDJCQUEyQjtJQUVuRSxJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLENBQUNDLElBQUksR0FBR1Y7SUFDWixJQUFJLENBQUNXLFdBQVcsR0FBR2xCO0lBQ25CLElBQUksQ0FBQ21CLFNBQVMsR0FBR0M7SUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsR0FBSSxrQkFBa0I7SUFDN0MsSUFBSSxDQUFDQyxXQUFXLEdBQUcsZUFBZ0IsMkRBQTJEO0lBRTlGLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLFdBQVcsR0FBR0o7SUFFbkIsNEJBQTRCO0lBQzVCLElBQUksQ0FBQ0ssT0FBTyxHQUFHLElBQUk3QixnQkFBZ0JnQjtJQUVuQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ0MsRUFBRSxDQUFDLFdBQVcsU0FBU0MsVUFBVTtRQUMxQ0MsVUFBVWQsSUFBSSxDQUFDRSxNQUFNVztJQUN6QjtJQUVB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QUFNO1lBQy9DLElBQUlDLE9BQU8sSUFBSUMsV0FBV0o7WUFDMUIsSUFBSyxJQUFJSyxJQUFFLEdBQUdDLE1BQUlQLE9BQU9HLE1BQU0sRUFBRUcsSUFBRUMsS0FBSyxFQUFFRCxFQUFHO2dCQUN6Q0YsSUFBSSxDQUFDRSxFQUFFLEdBQUdOLE1BQU0sQ0FBQ00sRUFBRTtZQUN2QjtZQUNBLElBQUksQ0FBQ1gsYUFBYSxDQUFDSixtQkFBbUJVO1FBQzFDO0lBQ0o7QUFDSjtBQUdBLFNBQVNMO0lBQ0wsSUFBSSxDQUFDekMsT0FBTyxDQUFDcUQsa0JBQWtCO0lBQy9CLElBQUksSUFBSSxDQUFDdEQsV0FBVyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDc0Qsa0JBQWtCO0lBQ3ZDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanM/MzMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBXZWJTb2NrZXRDbGllbnQgPSByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpO1xudmFyIHRvQnVmZmVyID0gcmVxdWlyZSgndHlwZWRhcnJheS10by1idWZmZXInKTtcbnZhciB5YWV0aSA9IHJlcXVpcmUoJ3lhZXRpJyk7XG5cblxuY29uc3QgQ09OTkVDVElORyA9IDA7XG5jb25zdCBPUEVOID0gMTtcbmNvbnN0IENMT1NJTkcgPSAyO1xuY29uc3QgQ0xPU0VEID0gMztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFczQ1dlYlNvY2tldDtcblxuXG5mdW5jdGlvbiBXM0NXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMsIG9yaWdpbiwgaGVhZGVycywgcmVxdWVzdE9wdGlvbnMsIGNsaWVudENvbmZpZykge1xuICAgIC8vIE1ha2UgdGhpcyBhbiBFdmVudFRhcmdldC5cbiAgICB5YWV0aS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2FuaXRpemUgY2xpZW50Q29uZmlnLlxuICAgIGNsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZyB8fCB7fTtcbiAgICBjbGllbnRDb25maWcuYXNzZW1ibGVGcmFnbWVudHMgPSB0cnVlOyAgLy8gUmVxdWlyZWQgaW4gdGhlIFczQyBBUEkuXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9ICcnO1xuICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDsgIC8vIEhhY2ssIGFsd2F5cyAwLlxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInOyAgLy8gVE9ETzogU2hvdWxkIGJlICdibG9iJyBieSBkZWZhdWx0LCBidXQgTm9kZSBoYXMgbm8gQmxvYi5cblxuICAgIC8vIFRoZSBXZWJTb2NrZXRDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBXZWJTb2NrZXRDbGllbnQgaW5zdGFuY2UuXG4gICAgdGhpcy5fY2xpZW50ID0gbmV3IFdlYlNvY2tldENsaWVudChjbGllbnRDb25maWcpO1xuXG4gICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBvbkNvbm5lY3QuY2FsbChzZWxmLCBjb25uZWN0aW9uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5vbignY29ubmVjdEZhaWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbChzZWxmKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5jb25uZWN0KHVybCwgcHJvdG9jb2xzLCBvcmlnaW4sIGhlYWRlcnMsIHJlcXVlc3RPcHRpb25zKTtcbn1cblxuXG4vLyBFeHBvc2UgVzNDIHJlYWQgb25seSBhdHRyaWJ1dGVzLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICAgIHVybDogICAgICAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl91cmw7ICAgICAgICAgICAgfSB9LFxuICAgIHJlYWR5U3RhdGU6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9yZWFkeVN0YXRlOyAgICAgfSB9LFxuICAgIHByb3RvY29sOiAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcm90b2NvbDsgICAgICAgfSB9LFxuICAgIGV4dGVuc2lvbnM6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9leHRlbnNpb25zOyAgICAgfSB9LFxuICAgIGJ1ZmZlcmVkQW1vdW50OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDsgfSB9XG59KTtcblxuXG4vLyBFeHBvc2UgVzNDIHdyaXRlL3JlYWQgYXR0cmlidXRlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFczQ1dlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgICBiaW5hcnlUeXBlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBKdXN0ICdhcnJheWJ1ZmZlcicgc3VwcG9ydGVkLlxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2p1c3QgXCJhcnJheWJ1ZmZlclwiIHR5cGUgYWxsb3dlZCBmb3IgXCJiaW5hcnlUeXBlXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEV4cG9zZSBXM0MgcmVhZHlTdGF0ZSBjb25zdGFudHMgaW50byB0aGUgV2ViU29ja2V0IGluc3RhbmNlIGFzIFczQyBzdGF0ZXMuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHlbMF0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHByb3BlcnR5WzFdOyB9XG4gICAgfSk7XG59KTtcblxuLy8gQWxzbyBleHBvc2UgVzNDIHJlYWR5U3RhdGUgY29uc3RhbnRzIGludG8gdGhlIFdlYlNvY2tldCBjbGFzcyAobm90IGRlZmluZWQgYnkgdGhlIFczQyxcbi8vIGJ1dCB0aGVyZSBhcmUgc28gbWFueSBsaWJzIHJlbHlpbmcgb24gdGhlbSkuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wZXJ0eVswXSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvcGVydHlbMV07IH1cbiAgICB9KTtcbn0pO1xuXG5cblczQ1dlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gT1BFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHNlbmQoKSB3aGlsZSBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gVGV4dC5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kVVRGKGRhdGEpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgQnVmZmVyLlxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kQnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3IGNvbnZlcnQgaXQgdG8gTm9kZSBCdWZmZXIuXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZEJ5dGVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJpbmFyeSBkYXRhOicsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5XM0NXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgc3dpdGNoKHRoaXMuX3JlYWR5U3RhdGUpIHtcbiAgICAgICAgY2FzZSBDT05ORUNUSU5HOlxuICAgICAgICAgICAgLy8gTk9URTogV2UgZG9uJ3QgaGF2ZSB0aGUgV2ViU29ja2V0Q29ubmVjdGlvbiBpbnN0YW5jZSB5ZXQgc28gbm9cbiAgICAgICAgICAgIC8vIHdheSB0byBjbG9zZSB0aGUgVENQIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAvLyBBcnRpZmljaWFsbHkgaW52b2tlIHRoZSBvbkNvbm5lY3RGYWlsZWQgZXZlbnQuXG4gICAgICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8vIEFuZCBjbG9zZSBpZiBpdCBjb25uZWN0cyBhZnRlciBhIHdoaWxlLlxuICAgICAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUEVOOlxuICAgICAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENMT1NJTkc7XG4gICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ0xPU0lORzpcbiAgICAgICAgY2FzZSBDTE9TRUQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUHJpdmF0ZSBBUEkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDbG9zZUV2ZW50KGNvZGUsIHJlYXNvbikge1xuICAgIHZhciBldmVudCA9IG5ldyB5YWV0aS5FdmVudCgnY2xvc2UnKTtcblxuICAgIGV2ZW50LmNvZGUgPSBjb2RlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC53YXNDbGVhbiA9ICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29kZSA9PT0gMTAwMCk7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgeWFldGkuRXZlbnQoJ21lc3NhZ2UnKTtcblxuICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xuXG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5cbmZ1bmN0aW9uIG9uQ29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IE9QRU47XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBjb25uZWN0aW9uLnByb3RvY29sO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBjb25uZWN0aW9uLmV4dGVuc2lvbnM7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgICAgICBvbkNsb3NlLmNhbGwoc2VsZiwgY29kZSwgcmVhc29uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgb25NZXNzYWdlLmNhbGwoc2VsZiwgbXNnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgeWFldGkuRXZlbnQoJ29wZW4nKSk7XG59XG5cblxuZnVuY3Rpb24gb25Db25uZWN0RmFpbGVkKCkge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyB5YWV0aS5FdmVudCgnZXJyb3InKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoMTAwNiwgJ2Nvbm5lY3Rpb24gZmFpbGVkJykpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvbkNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoY29kZSwgcmVhc29uIHx8ICcnKSk7XG59XG5cblxuZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS51dGY4RGF0YSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KG1lc3NhZ2UudXRmOERhdGEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWVzc2FnZS5iaW5hcnlEYXRhKSB7XG4gICAgICAgIC8vIE11c3QgY29udmVydCBmcm9tIE5vZGUgQnVmZmVyIHRvIEFycmF5QnVmZmVyLlxuICAgICAgICAvLyBUT0RPOiBvciB0byBhIEJsb2IgKHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIE5vZGUhKS5cbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG1lc3NhZ2UuYmluYXJ5RGF0YTtcbiAgICAgICAgICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49YnVmZmVyLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KGFycmF5YnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiV2ViU29ja2V0Q2xpZW50IiwicmVxdWlyZSIsInRvQnVmZmVyIiwieWFldGkiLCJDT05ORUNUSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJtb2R1bGUiLCJleHBvcnRzIiwiVzNDV2ViU29ja2V0IiwidXJsIiwicHJvdG9jb2xzIiwib3JpZ2luIiwiaGVhZGVycyIsInJlcXVlc3RPcHRpb25zIiwiY2xpZW50Q29uZmlnIiwiRXZlbnRUYXJnZXQiLCJjYWxsIiwiYXNzZW1ibGVGcmFnbWVudHMiLCJzZWxmIiwiX3VybCIsIl9yZWFkeVN0YXRlIiwiX3Byb3RvY29sIiwidW5kZWZpbmVkIiwiX2V4dGVuc2lvbnMiLCJfYnVmZmVyZWRBbW91bnQiLCJfYmluYXJ5VHlwZSIsIl9jb25uZWN0aW9uIiwiX2NsaWVudCIsIm9uIiwiY29ubmVjdGlvbiIsIm9uQ29ubmVjdCIsIm9uQ29ubmVjdEZhaWxlZCIsImNvbm5lY3QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiZ2V0IiwicmVhZHlTdGF0ZSIsInByb3RvY29sIiwiZXh0ZW5zaW9ucyIsImJ1ZmZlcmVkQW1vdW50IiwiYmluYXJ5VHlwZSIsInNldCIsInR5cGUiLCJTeW50YXhFcnJvciIsImZvckVhY2giLCJwcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwic2VuZCIsImRhdGEiLCJFcnJvciIsIlN0cmluZyIsInNlbmRVVEYiLCJCdWZmZXIiLCJzZW5kQnl0ZXMiLCJieXRlTGVuZ3RoIiwiY2xvc2UiLCJjb2RlIiwicmVhc29uIiwiY3JlYXRlQ2xvc2VFdmVudCIsImV2ZW50IiwiRXZlbnQiLCJ3YXNDbGVhbiIsImNyZWF0ZU1lc3NhZ2VFdmVudCIsIm9uQ2xvc2UiLCJtc2ciLCJvbk1lc3NhZ2UiLCJkaXNwYXRjaEV2ZW50IiwiZGVzdHJveSIsIm1lc3NhZ2UiLCJ1dGY4RGF0YSIsImJpbmFyeURhdGEiLCJidWZmZXIiLCJhcnJheWJ1ZmZlciIsIkFycmF5QnVmZmVyIiwibGVuZ3RoIiwidmlldyIsIlVpbnQ4QXJyYXkiLCJpIiwibGVuIiwicmVtb3ZlQWxsTGlzdGVuZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/W3CWebSocket.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(action-browser)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar excludedTlsOptions = [\n    \"hostname\",\n    \"port\",\n    \"method\",\n    \"path\",\n    \"headers\"\n];\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    // TODO: Implement extensions\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n            tlsOptions = config.tlsOptions;\n            delete config.tlsOptions;\n        } else {\n            tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n    this._req = null;\n    switch(this.config.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error(\"Requested webSocketVersion is not supported. Allowed values are 8 and 13.\");\n    }\n}\nutil.inherits(WebSocketClient, EventEmitter);\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    if (typeof protocols === \"string\") {\n        if (protocols.length > 0) {\n            protocols = [\n                protocols\n            ];\n        } else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n    if (typeof requestUrl === \"string\") {\n        this.url = url.parse(requestUrl);\n    } else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error(\"You must specify a full WebSocket URL, including protocol.\");\n    }\n    if (!this.url.host) {\n        throw new Error(\"You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.\");\n    }\n    this.secure = this.url.protocol === \"wss:\";\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for(var i = 0; i < protocol.length; i++){\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n    var defaultPorts = {\n        \"ws:\": \"80\",\n        \"wss:\": \"443\"\n    };\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n    var nonce = bufferAllocUnsafe(16);\n    for(var i = 0; i < 16; i++){\n        nonce[i] = Math.round(Math.random() * 0xFF);\n    }\n    this.base64nonce = nonce.toString(\"base64\");\n    var hostHeaderValue = this.url.hostname;\n    if (this.url.protocol === \"ws:\" && this.url.port !== \"80\" || this.url.protocol === \"wss:\" && this.url.port !== \"443\") {\n        hostHeaderValue += \":\" + this.url.port;\n    }\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty(\"headers\")) {\n        // Allow for additional headers to be provided when connecting via HTTPS\n        extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n        // Explicitly provided headers take priority over any from tlsOptions\n        extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": this.config.webSocketVersion.toString(10),\n        \"Sec-WebSocket-Key\": this.base64nonce,\n        \"Host\": reqHeaders.Host || hostHeaderValue\n    });\n    if (this.protocols.length > 0) {\n        reqHeaders[\"Sec-WebSocket-Protocol\"] = this.protocols.join(\", \");\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders[\"Origin\"] = this.origin;\n        } else if (this.config.webSocketVersion === 8) {\n            reqHeaders[\"Sec-WebSocket-Origin\"] = this.origin;\n        }\n    }\n    // TODO: Implement extensions\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    } else if (this.url.path) {\n        pathAndQuery = \"/\" + this.url.path;\n    } else {\n        pathAndQuery = \"/\";\n    }\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit(\"connectFailed\", error);\n    }\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: \"GET\",\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for(var key in tlsOptions){\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on(\"upgrade\", function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener(\"error\", handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on(\"error\", handleRequestError);\n    req.on(\"response\", function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, \"httpResponse\") > 0) {\n            self.emit(\"httpResponse\", response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        } else {\n            var headerDumpParts = [];\n            for(var headerName in response.headers){\n                headerDumpParts.push(headerName + \": \" + response.headers[headerName]);\n            }\n            self.failHandshake(\"Server responded with a non-101 status: \" + response.statusCode + \" \" + response.statusMessage + \"\\nResponse Headers Follow:\\n\" + headerDumpParts.join(\"\\n\") + \"\\n\");\n        }\n    });\n    req.end();\n};\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n    if (this.protocols.length > 0) {\n        this.protocol = headers[\"sec-websocket-protocol\"];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake(\"Server did not respond with a requested protocol.\");\n                return;\n            }\n        } else {\n            this.failHandshake(\"Expected a Sec-WebSocket-Protocol header.\");\n            return;\n        }\n    }\n    if (!(headers[\"connection\"] && headers[\"connection\"].toLocaleLowerCase() === \"upgrade\")) {\n        this.failHandshake(\"Expected a Connection: Upgrade header from the server\");\n        return;\n    }\n    if (!(headers[\"upgrade\"] && headers[\"upgrade\"].toLocaleLowerCase() === \"websocket\")) {\n        this.failHandshake(\"Expected an Upgrade: websocket header from the server\");\n        return;\n    }\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.base64nonce + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var expectedKey = sha1.digest(\"base64\");\n    if (!headers[\"sec-websocket-accept\"]) {\n        this.failHandshake(\"Expected Sec-WebSocket-Accept header from server\");\n        return;\n    }\n    if (headers[\"sec-websocket-accept\"] !== expectedKey) {\n        this.failHandshake(\"Sec-WebSocket-Accept header from server didn't match expected value of \" + expectedKey);\n        return;\n    }\n    // TODO: Support extensions\n    this.succeedHandshake();\n};\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit(\"connectFailed\", new Error(errorDescription));\n};\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n    this.emit(\"connect\", connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\nmodule.exports = WebSocketClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFNBQVNGLE1BQU1FLE1BQU07QUFDekIsSUFBSUMsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUcsZUFBZUgsMERBQThCO0FBQ2pELElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlLLFFBQVFMLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlNLE1BQU1OLG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlRLHNCQUFzQlIsbUJBQU9BLENBQUM7QUFDbEMsSUFBSVMsb0JBQW9CVixNQUFNVSxpQkFBaUI7QUFFL0MsSUFBSUMscUJBQXFCO0lBQ3JCO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDcEI7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUNyQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLQyxPQUFPQyxZQUFZLENBQUM7Q0FDdEM7QUFFRCxJQUFJQyxxQkFBcUI7SUFBQztJQUFXO0lBQU87SUFBUztJQUFPO0NBQVU7QUFFdEUsU0FBU0MsZ0JBQWdCQyxNQUFNO0lBQzNCLHlCQUF5QjtJQUN6QlosYUFBYWEsSUFBSSxDQUFDLElBQUk7SUFFdEIsNkJBQTZCO0lBRTdCLElBQUksQ0FBQ0QsTUFBTSxHQUFHO1FBQ1YsdUJBQXVCO1FBQ3ZCRSxzQkFBc0I7UUFFdEIsNENBQTRDO1FBQzVDLDRCQUE0QjtRQUM1QkMsd0JBQXdCO1FBRXhCLCtEQUErRDtRQUMvRCxpQ0FBaUM7UUFDakNDLDBCQUEwQjtRQUUxQixnRUFBZ0U7UUFDaEUsbUJBQW1CO1FBQ25CQyx3QkFBd0I7UUFFeEIsK0RBQStEO1FBQy9ELG9FQUFvRTtRQUNwRSwwREFB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SUFBSSxDQUFDckIsY0FBYztJQUNuRDtJQUNBLElBQUksQ0FBQ0EsY0FBYyxHQUFHO0FBQzFCO0FBRUFwRSxnQkFBZ0JlLFNBQVMsQ0FBQzJFLEtBQUssR0FBRztJQUM5QixJQUFJLElBQUksQ0FBQzlFLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ0EsSUFBSSxDQUFDOEUsS0FBSztJQUNuQjtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRzVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Q2xpZW50LmpzPzNiMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZW5kID0gdXRpbHMuZXh0ZW5kO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIFdlYlNvY2tldENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL1dlYlNvY2tldENvbm5lY3Rpb24nKTtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHV0aWxzLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG52YXIgcHJvdG9jb2xTZXBhcmF0b3JzID0gW1xuICAgICcoJywgJyknLCAnPCcsICc+JywgJ0AnLFxuICAgICcsJywgJzsnLCAnOicsICdcXFxcJywgJ1xcXCInLFxuICAgICcvJywgJ1snLCAnXScsICc/JywgJz0nLFxuICAgICd7JywgJ30nLCAnICcsIFN0cmluZy5mcm9tQ2hhckNvZGUoOSlcbl07XG5cbnZhciBleGNsdWRlZFRsc09wdGlvbnMgPSBbJ2hvc3RuYW1lJywncG9ydCcsJ21ldGhvZCcsJ3BhdGgnLCdoZWFkZXJzJ107XG5cbmZ1bmN0aW9uIFdlYlNvY2tldENsaWVudChjb25maWcpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZXh0ZW5zaW9uc1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC8vIDFNaUIgbWF4IGZyYW1lIHNpemUuXG4gICAgICAgIG1heFJlY2VpdmVkRnJhbWVTaXplOiAweDEwMDAwMCxcblxuICAgICAgICAvLyA4TWlCIG1heCBtZXNzYWdlIHNpemUsIG9ubHkgYXBwbGljYWJsZSBpZlxuICAgICAgICAvLyBhc3NlbWJsZUZyYWdtZW50cyBpcyB0cnVlXG4gICAgICAgIG1heFJlY2VpdmVkTWVzc2FnZVNpemU6IDB4ODAwMDAwLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIG1lc3NhZ2VzIGxhcmdlciB0aGFuIGZyYWdtZW50YXRpb25UaHJlc2hvbGQgd2lsbCBiZVxuICAgICAgICAvLyBzcGxpdCBpbnRvIG11bHRpcGxlIGZyYWdtZW50cy5cbiAgICAgICAgZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzOiB0cnVlLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIGZyYW1lcyBhcmUgZnJhZ21lbnRlZCBpZiB0aGV5IGV4Y2VlZCB0aGlzIHRocmVzaG9sZC5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyAxNktpQlxuICAgICAgICBmcmFnbWVudGF0aW9uVGhyZXNob2xkOiAweDQwMDAsXG5cbiAgICAgICAgLy8gV2hpY2ggdmVyc2lvbiBvZiB0aGUgcHJvdG9jb2wgdG8gdXNlIGZvciB0aGlzIHNlc3Npb24uICBUaGlzXG4gICAgICAgIC8vIG9wdGlvbiB3aWxsIGJlIHJlbW92ZWQgb25jZSB0aGUgcHJvdG9jb2wgaXMgZmluYWxpemVkIGJ5IHRoZSBJRVRGXG4gICAgICAgIC8vIEl0IGlzIG9ubHkgYXZhaWxhYmxlIHRvIGVhc2UgdGhlIHRyYW5zaXRpb24gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGRyYWZ0IHByb3RvY29sIHZlcnNpb25zLlxuICAgICAgICAvLyBBdCBwcmVzZW50LCBpdCBvbmx5IGFmZmVjdHMgdGhlIG5hbWUgb2YgdGhlIE9yaWdpbiBoZWFkZXIuXG4gICAgICAgIHdlYlNvY2tldFZlcnNpb246IDEzLFxuXG4gICAgICAgIC8vIElmIHRydWUsIGZyYWdtZW50ZWQgbWVzc2FnZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFzc2VtYmxlZFxuICAgICAgICAvLyBhbmQgdGhlIGZ1bGwgbWVzc2FnZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ21lc3NhZ2UnIGV2ZW50LlxuICAgICAgICAvLyBJZiBmYWxzZSwgZWFjaCBmcmFtZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ2ZyYW1lJyBldmVudCBhbmRcbiAgICAgICAgLy8gdGhlIGFwcGxpY2F0aW9uIHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIGFnZ3JlZ2F0aW5nIG11bHRpcGxlXG4gICAgICAgIC8vIGZyYWdtZW50ZWQgZnJhbWVzLiAgU2luZ2xlLWZyYW1lIG1lc3NhZ2VzIHdpbGwgZW1pdCBhICdtZXNzYWdlJ1xuICAgICAgICAvLyBldmVudCBpbiBhZGRpdGlvbiB0byB0aGUgJ2ZyYW1lJyBldmVudC5cbiAgICAgICAgLy8gTW9zdCB1c2VycyB3aWxsIHdhbnQgdG8gbGVhdmUgdGhpcyBzZXQgdG8gJ3RydWUnXG4gICAgICAgIGFzc2VtYmxlRnJhZ21lbnRzOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBOYWdsZSBBbGdvcml0aG0gbWFrZXMgbW9yZSBlZmZpY2llbnQgdXNlIG9mIG5ldHdvcmsgcmVzb3VyY2VzXG4gICAgICAgIC8vIGJ5IGludHJvZHVjaW5nIGEgc21hbGwgZGVsYXkgYmVmb3JlIHNlbmRpbmcgc21hbGwgcGFja2V0cyBzbyB0aGF0XG4gICAgICAgIC8vIG11bHRpcGxlIG1lc3NhZ2VzIGNhbiBiZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZSBnb2luZyBvbnRvIHRoZVxuICAgICAgICAvLyB3aXJlLiAgVGhpcyBob3dldmVyIGNvbWVzIGF0IHRoZSBjb3N0IG9mIGxhdGVuY3ksIHNvIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGlzIHRvIGRpc2FibGUgaXQuICBJZiB5b3UgZG9uJ3QgbmVlZCBsb3cgbGF0ZW5jeSBhbmQgYXJlIHN0cmVhbWluZ1xuICAgICAgICAvLyBsb3RzIG9mIHNtYWxsIG1lc3NhZ2VzLCB5b3UgY2FuIGNoYW5nZSB0aGlzIHRvICdmYWxzZSdcbiAgICAgICAgZGlzYWJsZU5hZ2xlQWxnb3JpdGhtOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIGNsb3NlIGZyYW1lXG4gICAgICAgIC8vIGZvciBhbiBhY2tub3dsZWRnZW1lbnQgdG8gY29tZSBiYWNrIGJlZm9yZSBnaXZpbmcgdXAgYW5kIGp1c3RcbiAgICAgICAgLy8gY2xvc2luZyB0aGUgc29ja2V0LlxuICAgICAgICBjbG9zZVRpbWVvdXQ6IDUwMDAsXG5cbiAgICAgICAgLy8gT3B0aW9ucyB0byBwYXNzIHRvIGh0dHBzLmNvbm5lY3QgaWYgY29ubmVjdGluZyB2aWEgVExTXG4gICAgICAgIHRsc09wdGlvbnM6IHt9XG4gICAgfTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgdmFyIHRsc09wdGlvbnM7XG4gICAgICAgIGlmIChjb25maWcudGxzT3B0aW9ucykge1xuICAgICAgICAgIHRsc09wdGlvbnMgPSBjb25maWcudGxzT3B0aW9ucztcbiAgICAgICAgICBkZWxldGUgY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGxzT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgZXh0ZW5kKHRoaXMuY29uZmlnLnRsc09wdGlvbnMsIHRsc09wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcSA9IG51bGw7XG4gICAgXG4gICAgc3dpdGNoICh0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgd2ViU29ja2V0VmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLiBBbGxvd2VkIHZhbHVlcyBhcmUgOCBhbmQgMTMuJyk7XG4gICAgfVxufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldENsaWVudCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24ocmVxdWVzdFVybCwgcHJvdG9jb2xzLCBvcmlnaW4sIGhlYWRlcnMsIGV4dHJhUmVxdWVzdE9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgaWYgKHR5cGVvZihwcm90b2NvbHMpID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEocHJvdG9jb2xzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnByb3RvY29scyA9IHByb3RvY29scztcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcblxuICAgIGlmICh0eXBlb2YocmVxdWVzdFVybCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsLnBhcnNlKHJlcXVlc3RVcmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy51cmwgPSByZXF1ZXN0VXJsOyAvLyBpbiBjYXNlIGFuIGFscmVhZHkgcGFyc2VkIHVybCBpcyBwYXNzZWQgaW4uXG4gICAgfVxuICAgIGlmICghdGhpcy51cmwucHJvdG9jb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgZnVsbCBXZWJTb2NrZXQgVVJMLCBpbmNsdWRpbmcgcHJvdG9jb2wuJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy51cmwuaG9zdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBmdWxsIFdlYlNvY2tldCBVUkwsIGluY2x1ZGluZyBob3N0bmFtZS4gUmVsYXRpdmUgVVJMcyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlY3VyZSA9ICh0aGlzLnVybC5wcm90b2NvbCA9PT0gJ3dzczonKTtcblxuICAgIC8vIHZhbGlkYXRlIHByb3RvY29sIGNoYXJhY3RlcnM6XG4gICAgdGhpcy5wcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90b2NvbCkge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwcm90b2NvbC5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHByb3RvY29sLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gcHJvdG9jb2wuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHgwMDIxIHx8IGNoYXJDb2RlID4gMHgwMDdFIHx8IHByb3RvY29sU2VwYXJhdG9ycy5pbmRleE9mKGNoYXJhY3RlcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm90b2NvbCBsaXN0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyIFwiJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBkZWZhdWx0UG9ydHMgPSB7XG4gICAgICAgICd3czonOiAnODAnLFxuICAgICAgICAnd3NzOic6ICc0NDMnXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51cmwucG9ydCkge1xuICAgICAgICB0aGlzLnVybC5wb3J0ID0gZGVmYXVsdFBvcnRzW3RoaXMudXJsLnByb3RvY29sXTtcbiAgICB9XG5cbiAgICB2YXIgbm9uY2UgPSBidWZmZXJBbGxvY1Vuc2FmZSgxNik7XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgMTY7IGkrKykge1xuICAgICAgICBub25jZVtpXSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSoweEZGKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlNjRub25jZSA9IG5vbmNlLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgIHZhciBob3N0SGVhZGVyVmFsdWUgPSB0aGlzLnVybC5ob3N0bmFtZTtcbiAgICBpZiAoKHRoaXMudXJsLnByb3RvY29sID09PSAnd3M6JyAmJiB0aGlzLnVybC5wb3J0ICE9PSAnODAnKSB8fFxuICAgICAgICAodGhpcy51cmwucHJvdG9jb2wgPT09ICd3c3M6JyAmJiB0aGlzLnVybC5wb3J0ICE9PSAnNDQzJykpICB7XG4gICAgICAgIGhvc3RIZWFkZXJWYWx1ZSArPSAoJzonICsgdGhpcy51cmwucG9ydCk7XG4gICAgfVxuXG4gICAgdmFyIHJlcUhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5zZWN1cmUgJiYgdGhpcy5jb25maWcudGxzT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaGVhZGVycycpKSB7XG4gICAgICAvLyBBbGxvdyBmb3IgYWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHByb3ZpZGVkIHdoZW4gY29ubmVjdGluZyB2aWEgSFRUUFNcbiAgICAgIGV4dGVuZChyZXFIZWFkZXJzLCB0aGlzLmNvbmZpZy50bHNPcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgLy8gRXhwbGljaXRseSBwcm92aWRlZCBoZWFkZXJzIHRha2UgcHJpb3JpdHkgb3ZlciBhbnkgZnJvbSB0bHNPcHRpb25zXG4gICAgICBleHRlbmQocmVxSGVhZGVycywgaGVhZGVycyk7XG4gICAgfVxuICAgIGV4dGVuZChyZXFIZWFkZXJzLCB7XG4gICAgICAgICdVcGdyYWRlJzogJ3dlYnNvY2tldCcsXG4gICAgICAgICdDb25uZWN0aW9uJzogJ1VwZ3JhZGUnLFxuICAgICAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogdGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbi50b1N0cmluZygxMCksXG4gICAgICAgICdTZWMtV2ViU29ja2V0LUtleSc6IHRoaXMuYmFzZTY0bm9uY2UsXG4gICAgICAgICdIb3N0JzogcmVxSGVhZGVycy5Ib3N0IHx8IGhvc3RIZWFkZXJWYWx1ZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvdG9jb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVxSGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gdGhpcy5wcm90b2NvbHMuam9pbignLCAnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uID09PSAxMykge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snT3JpZ2luJ10gPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uID09PSA4KSB7XG4gICAgICAgICAgICByZXFIZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gdGhpcy5vcmlnaW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZXh0ZW5zaW9uc1xuXG4gICAgdmFyIHBhdGhBbmRRdWVyeTtcbiAgICAvLyBFbnN1cmUgaXQgYmVnaW5zIHdpdGggJy8nLlxuICAgIGlmICh0aGlzLnVybC5wYXRobmFtZSkge1xuICAgICAgICBwYXRoQW5kUXVlcnkgPSB0aGlzLnVybC5wYXRoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnVybC5wYXRoKSB7XG4gICAgICAgIHBhdGhBbmRRdWVyeSA9ICcvJyArIHRoaXMudXJsLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXRoQW5kUXVlcnkgPSAnLyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycm9yKSB7XG4gICAgICAgIHNlbGYuX3JlcSA9IG51bGw7XG4gICAgICAgIHNlbGYuZW1pdCgnY29ubmVjdEZhaWxlZCcsIGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGFnZW50OiBmYWxzZVxuICAgIH07XG4gICAgaWYgKGV4dHJhUmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKHJlcXVlc3RPcHRpb25zLCBleHRyYVJlcXVlc3RPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVGhlc2Ugb3B0aW9ucyBhcmUgYWx3YXlzIG92ZXJyaWRkZW4gYnkgdGhlIGxpYnJhcnkuICBUaGUgdXNlciBpcyBub3RcbiAgICAvLyBhbGxvd2VkIHRvIHNwZWNpZnkgdGhlc2UgZGlyZWN0bHkuXG4gICAgZXh0ZW5kKHJlcXVlc3RPcHRpb25zLCB7XG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLnVybC5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdGhpcy51cmwucG9ydCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcGF0aDogcGF0aEFuZFF1ZXJ5LFxuICAgICAgICBoZWFkZXJzOiByZXFIZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHZhciB0bHNPcHRpb25zID0gdGhpcy5jb25maWcudGxzT3B0aW9ucztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRsc09wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0bHNPcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgJiYgZXhjbHVkZWRUbHNPcHRpb25zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9uc1trZXldID0gdGxzT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcSA9IHRoaXMuX3JlcSA9ICh0aGlzLnNlY3VyZSA/IGh0dHBzIDogaHR0cCkucmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgcmVxLm9uKCd1cGdyYWRlJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFVwZ3JhZGUocmVzcG9uc2UsIHNvY2tldCwgaGVhZCkge1xuICAgICAgICBzZWxmLl9yZXEgPSBudWxsO1xuICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlUmVxdWVzdEVycm9yKTtcbiAgICAgICAgc2VsZi5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgc2VsZi5maXJzdERhdGFDaHVuayA9IGhlYWQ7XG4gICAgICAgIHNlbGYudmFsaWRhdGVIYW5kc2hha2UoKTtcbiAgICB9KTtcbiAgICByZXEub24oJ2Vycm9yJywgaGFuZGxlUmVxdWVzdEVycm9yKTtcblxuICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBzZWxmLl9yZXEgPSBudWxsO1xuICAgICAgICBpZiAodXRpbHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudChzZWxmLCAnaHR0cFJlc3BvbnNlJykgPiAwKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2h0dHBSZXNwb25zZScsIHJlc3BvbnNlLCBzZWxmKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyRHVtcFBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJEdW1wUGFydHMucHVzaChoZWFkZXJOYW1lICsgJzogJyArIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5mYWlsSGFuZHNoYWtlKFxuICAgICAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBub24tMTAxIHN0YXR1czogJyArXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSArICcgJyArIHJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICdcXG5SZXNwb25zZSBIZWFkZXJzIEZvbGxvdzpcXG4nICtcbiAgICAgICAgICAgICAgICBoZWFkZXJEdW1wUGFydHMuam9pbignXFxuJykgKyAnXFxuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlcS5lbmQoKTtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUudmFsaWRhdGVIYW5kc2hha2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVhZGVycyA9IHRoaXMucmVzcG9uc2UuaGVhZGVycztcblxuICAgIGlmICh0aGlzLnByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm90b2NvbHMuaW5kZXhPZih0aGlzLnByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ1NlcnZlciBkaWQgbm90IHJlc3BvbmQgd2l0aCBhIHJlcXVlc3RlZCBwcm90b2NvbC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIGEgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXIuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShoZWFkZXJzWydjb25uZWN0aW9uJ10gJiYgaGVhZGVyc1snY29ubmVjdGlvbiddLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09ICd1cGdyYWRlJykpIHtcbiAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBhIENvbm5lY3Rpb246IFVwZ3JhZGUgaGVhZGVyIGZyb20gdGhlIHNlcnZlcicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEoaGVhZGVyc1sndXBncmFkZSddICYmIGhlYWRlcnNbJ3VwZ3JhZGUnXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAnd2Vic29ja2V0JykpIHtcbiAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBhbiBVcGdyYWRlOiB3ZWJzb2NrZXQgaGVhZGVyIGZyb20gdGhlIHNlcnZlcicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoYTEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICAgIHNoYTEudXBkYXRlKHRoaXMuYmFzZTY0bm9uY2UgKyAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyk7XG4gICAgdmFyIGV4cGVjdGVkS2V5ID0gc2hhMS5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKCFoZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyIGZyb20gc2VydmVyJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXIgZnJvbSBzZXJ2ZXIgZGlkblxcJ3QgbWF0Y2ggZXhwZWN0ZWQgdmFsdWUgb2YgJyArIGV4cGVjdGVkS2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFN1cHBvcnQgZXh0ZW5zaW9uc1xuXG4gICAgdGhpcy5zdWNjZWVkSGFuZHNoYWtlKCk7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmZhaWxIYW5kc2hha2UgPSBmdW5jdGlvbihlcnJvckRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RGYWlsZWQnLCBuZXcgRXJyb3IoZXJyb3JEZXNjcmlwdGlvbikpO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5zdWNjZWVkSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLnNvY2tldCwgW10sIHRoaXMucHJvdG9jb2wsIHRydWUsIHRoaXMuY29uZmlnKTtcblxuICAgIGNvbm5lY3Rpb24ud2ViU29ja2V0VmVyc2lvbiA9IHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb247XG4gICAgY29ubmVjdGlvbi5fYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIGNvbm5lY3Rpb24pO1xuICAgIGlmICh0aGlzLmZpcnN0RGF0YUNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29ubmVjdGlvbi5oYW5kbGVTb2NrZXREYXRhKHRoaXMuZmlyc3REYXRhQ2h1bmspO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0RGF0YUNodW5rID0gbnVsbDtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmVxKSB7XG4gICAgICAgIHRoaXMuX3JlcS5hYm9ydCgpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Q2xpZW50O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImV4dGVuZCIsInV0aWwiLCJFdmVudEVtaXR0ZXIiLCJodHRwIiwiaHR0cHMiLCJ1cmwiLCJjcnlwdG8iLCJXZWJTb2NrZXRDb25uZWN0aW9uIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJwcm90b2NvbFNlcGFyYXRvcnMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJleGNsdWRlZFRsc09wdGlvbnMiLCJXZWJTb2NrZXRDbGllbnQiLCJjb25maWciLCJjYWxsIiwibWF4UmVjZWl2ZWRGcmFtZVNpemUiLCJtYXhSZWNlaXZlZE1lc3NhZ2VTaXplIiwiZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIiwiZnJhZ21lbnRhdGlvblRocmVzaG9sZCIsIndlYlNvY2tldFZlcnNpb24iLCJhc3NlbWJsZUZyYWdtZW50cyIsImRpc2FibGVOYWdsZUFsZ29yaXRobSIsImNsb3NlVGltZW91dCIsInRsc09wdGlvbnMiLCJfcmVxIiwiRXJyb3IiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImNvbm5lY3QiLCJyZXF1ZXN0VXJsIiwicHJvdG9jb2xzIiwib3JpZ2luIiwiaGVhZGVycyIsImV4dHJhUmVxdWVzdE9wdGlvbnMiLCJzZWxmIiwibGVuZ3RoIiwiQXJyYXkiLCJwYXJzZSIsInByb3RvY29sIiwiaG9zdCIsInNlY3VyZSIsImZvckVhY2giLCJpIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiY2hhcmFjdGVyIiwiY2hhckF0IiwiaW5kZXhPZiIsImRlZmF1bHRQb3J0cyIsInBvcnQiLCJub25jZSIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImJhc2U2NG5vbmNlIiwidG9TdHJpbmciLCJob3N0SGVhZGVyVmFsdWUiLCJob3N0bmFtZSIsInJlcUhlYWRlcnMiLCJoYXNPd25Qcm9wZXJ0eSIsIkhvc3QiLCJqb2luIiwicGF0aEFuZFF1ZXJ5IiwicGF0aG5hbWUiLCJwYXRoIiwiaGFuZGxlUmVxdWVzdEVycm9yIiwiZXJyb3IiLCJlbWl0IiwicmVxdWVzdE9wdGlvbnMiLCJhZ2VudCIsIm1ldGhvZCIsImtleSIsInJlcSIsInJlcXVlc3QiLCJvbiIsImhhbmRsZVJlcXVlc3RVcGdyYWRlIiwicmVzcG9uc2UiLCJzb2NrZXQiLCJoZWFkIiwicmVtb3ZlTGlzdGVuZXIiLCJmaXJzdERhdGFDaHVuayIsInZhbGlkYXRlSGFuZHNoYWtlIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsImVuZCIsImhlYWRlckR1bXBQYXJ0cyIsImhlYWRlck5hbWUiLCJwdXNoIiwiZmFpbEhhbmRzaGFrZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJzaGExIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImV4cGVjdGVkS2V5IiwiZGlnZXN0Iiwic3VjY2VlZEhhbmRzaGFrZSIsImVycm9yRGVzY3JpcHRpb24iLCJ3cml0YWJsZSIsImNvbm5lY3Rpb24iLCJfYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMiLCJoYW5kbGVTb2NrZXREYXRhIiwiYWJvcnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar excludedTlsOptions = [\n    \"hostname\",\n    \"port\",\n    \"method\",\n    \"path\",\n    \"headers\"\n];\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    // TODO: Implement extensions\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n            tlsOptions = config.tlsOptions;\n            delete config.tlsOptions;\n        } else {\n            tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n    this._req = null;\n    switch(this.config.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error(\"Requested webSocketVersion is not supported. Allowed values are 8 and 13.\");\n    }\n}\nutil.inherits(WebSocketClient, EventEmitter);\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    if (typeof protocols === \"string\") {\n        if (protocols.length > 0) {\n            protocols = [\n                protocols\n            ];\n        } else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n    if (typeof requestUrl === \"string\") {\n        this.url = url.parse(requestUrl);\n    } else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error(\"You must specify a full WebSocket URL, including protocol.\");\n    }\n    if (!this.url.host) {\n        throw new Error(\"You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.\");\n    }\n    this.secure = this.url.protocol === \"wss:\";\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for(var i = 0; i < protocol.length; i++){\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n    var defaultPorts = {\n        \"ws:\": \"80\",\n        \"wss:\": \"443\"\n    };\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n    var nonce = bufferAllocUnsafe(16);\n    for(var i = 0; i < 16; i++){\n        nonce[i] = Math.round(Math.random() * 0xFF);\n    }\n    this.base64nonce = nonce.toString(\"base64\");\n    var hostHeaderValue = this.url.hostname;\n    if (this.url.protocol === \"ws:\" && this.url.port !== \"80\" || this.url.protocol === \"wss:\" && this.url.port !== \"443\") {\n        hostHeaderValue += \":\" + this.url.port;\n    }\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty(\"headers\")) {\n        // Allow for additional headers to be provided when connecting via HTTPS\n        extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n        // Explicitly provided headers take priority over any from tlsOptions\n        extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": this.config.webSocketVersion.toString(10),\n        \"Sec-WebSocket-Key\": this.base64nonce,\n        \"Host\": reqHeaders.Host || hostHeaderValue\n    });\n    if (this.protocols.length > 0) {\n        reqHeaders[\"Sec-WebSocket-Protocol\"] = this.protocols.join(\", \");\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders[\"Origin\"] = this.origin;\n        } else if (this.config.webSocketVersion === 8) {\n            reqHeaders[\"Sec-WebSocket-Origin\"] = this.origin;\n        }\n    }\n    // TODO: Implement extensions\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    } else if (this.url.path) {\n        pathAndQuery = \"/\" + this.url.path;\n    } else {\n        pathAndQuery = \"/\";\n    }\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit(\"connectFailed\", error);\n    }\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: \"GET\",\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for(var key in tlsOptions){\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on(\"upgrade\", function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener(\"error\", handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on(\"error\", handleRequestError);\n    req.on(\"response\", function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, \"httpResponse\") > 0) {\n            self.emit(\"httpResponse\", response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        } else {\n            var headerDumpParts = [];\n            for(var headerName in response.headers){\n                headerDumpParts.push(headerName + \": \" + response.headers[headerName]);\n            }\n            self.failHandshake(\"Server responded with a non-101 status: \" + response.statusCode + \" \" + response.statusMessage + \"\\nResponse Headers Follow:\\n\" + headerDumpParts.join(\"\\n\") + \"\\n\");\n        }\n    });\n    req.end();\n};\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n    if (this.protocols.length > 0) {\n        this.protocol = headers[\"sec-websocket-protocol\"];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake(\"Server did not respond with a requested protocol.\");\n                return;\n            }\n        } else {\n            this.failHandshake(\"Expected a Sec-WebSocket-Protocol header.\");\n            return;\n        }\n    }\n    if (!(headers[\"connection\"] && headers[\"connection\"].toLocaleLowerCase() === \"upgrade\")) {\n        this.failHandshake(\"Expected a Connection: Upgrade header from the server\");\n        return;\n    }\n    if (!(headers[\"upgrade\"] && headers[\"upgrade\"].toLocaleLowerCase() === \"websocket\")) {\n        this.failHandshake(\"Expected an Upgrade: websocket header from the server\");\n        return;\n    }\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.base64nonce + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var expectedKey = sha1.digest(\"base64\");\n    if (!headers[\"sec-websocket-accept\"]) {\n        this.failHandshake(\"Expected Sec-WebSocket-Accept header from server\");\n        return;\n    }\n    if (headers[\"sec-websocket-accept\"] !== expectedKey) {\n        this.failHandshake(\"Sec-WebSocket-Accept header from server didn't match expected value of \" + expectedKey);\n        return;\n    }\n    // TODO: Support extensions\n    this.succeedHandshake();\n};\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit(\"connectFailed\", new Error(errorDescription));\n};\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n    this.emit(\"connect\", connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\nmodule.exports = WebSocketClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxTQUFTRixNQUFNRSxNQUFNO0FBQ3pCLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLGVBQWVILDBEQUE4QjtBQUNqRCxJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNuQixJQUFJSyxRQUFRTCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJTSxNQUFNTixtQkFBT0EsQ0FBQztBQUNsQixJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJUSxzQkFBc0JSLG1CQUFPQSxDQUFDO0FBQ2xDLElBQUlTLG9CQUFvQlYsTUFBTVUsaUJBQWlCO0FBRS9DLElBQUlDLHFCQUFxQjtJQUNyQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBRUQsSUFBSUMscUJBQXFCO0lBQUM7SUFBVztJQUFPO0lBQVM7SUFBTztDQUFVO0FBRXRFLFNBQVNDLGdCQUFnQkMsTUFBTTtJQUMzQix5QkFBeUI7SUFDekJaLGFBQWFhLElBQUksQ0FBQyxJQUFJO0lBRXRCLDZCQUE2QjtJQUU3QixJQUFJLENBQUNELE1BQU0sR0FBRztRQUNWLHVCQUF1QjtRQUN2QkUsc0JBQXNCO1FBRXRCLDRDQUE0QztRQUM1Qyw0QkFBNEI7UUFDNUJDLHdCQUF3QjtRQUV4QiwrREFBK0Q7UUFDL0QsaUNBQWlDO1FBQ2pDQywwQkFBMEI7UUFFMUIsZ0VBQWdFO1FBQ2hFLG1CQUFtQjtRQUNuQkMsd0JBQXdCO1FBRXhCLCtEQUErRDtRQUMvRCxvRUFBb0U7UUFDcEUsMERBQTBEO1FBQzFELHdD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LGNBQWM7SUFDbkQ7SUFDQSxJQUFJLENBQUNBLGNBQWMsR0FBRztBQUMxQjtBQUVBcEUsZ0JBQWdCZSxTQUFTLENBQUMyRSxLQUFLLEdBQUc7SUFDOUIsSUFBSSxJQUFJLENBQUM5RSxJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUNBLElBQUksQ0FBQzhFLEtBQUs7SUFDbkI7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1RiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENsaWVudC5qcz8zYjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSB1dGlscy5idWZmZXJBbGxvY1Vuc2FmZTtcblxudmFyIHByb3RvY29sU2VwYXJhdG9ycyA9IFtcbiAgICAnKCcsICcpJywgJzwnLCAnPicsICdAJyxcbiAgICAnLCcsICc7JywgJzonLCAnXFxcXCcsICdcXFwiJyxcbiAgICAnLycsICdbJywgJ10nLCAnPycsICc9JyxcbiAgICAneycsICd9JywgJyAnLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpXG5dO1xuXG52YXIgZXhjbHVkZWRUbHNPcHRpb25zID0gWydob3N0bmFtZScsJ3BvcnQnLCdtZXRob2QnLCdwYXRoJywnaGVhZGVycyddO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRDbGllbnQoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyAxTWlCIG1heCBmcmFtZSBzaXplLlxuICAgICAgICBtYXhSZWNlaXZlZEZyYW1lU2l6ZTogMHgxMDAwMDAsXG5cbiAgICAgICAgLy8gOE1pQiBtYXggbWVzc2FnZSBzaXplLCBvbmx5IGFwcGxpY2FibGUgaWZcbiAgICAgICAgLy8gYXNzZW1ibGVGcmFnbWVudHMgaXMgdHJ1ZVxuICAgICAgICBtYXhSZWNlaXZlZE1lc3NhZ2VTaXplOiAweDgwMDAwMCxcblxuICAgICAgICAvLyBPdXRnb2luZyBtZXNzYWdlcyBsYXJnZXIgdGhhbiBmcmFnbWVudGF0aW9uVGhyZXNob2xkIHdpbGwgYmVcbiAgICAgICAgLy8gc3BsaXQgaW50byBtdWx0aXBsZSBmcmFnbWVudHMuXG4gICAgICAgIGZyYWdtZW50T3V0Z29pbmdNZXNzYWdlczogdHJ1ZSxcblxuICAgICAgICAvLyBPdXRnb2luZyBmcmFtZXMgYXJlIGZyYWdtZW50ZWQgaWYgdGhleSBleGNlZWQgdGhpcyB0aHJlc2hvbGQuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgMTZLaUJcbiAgICAgICAgZnJhZ21lbnRhdGlvblRocmVzaG9sZDogMHg0MDAwLFxuXG4gICAgICAgIC8vIFdoaWNoIHZlcnNpb24gb2YgdGhlIHByb3RvY29sIHRvIHVzZSBmb3IgdGhpcyBzZXNzaW9uLiAgVGhpc1xuICAgICAgICAvLyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHByb3RvY29sIGlzIGZpbmFsaXplZCBieSB0aGUgSUVURlxuICAgICAgICAvLyBJdCBpcyBvbmx5IGF2YWlsYWJsZSB0byBlYXNlIHRoZSB0cmFuc2l0aW9uIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBkcmFmdCBwcm90b2NvbCB2ZXJzaW9ucy5cbiAgICAgICAgLy8gQXQgcHJlc2VudCwgaXQgb25seSBhZmZlY3RzIHRoZSBuYW1lIG9mIHRoZSBPcmlnaW4gaGVhZGVyLlxuICAgICAgICB3ZWJTb2NrZXRWZXJzaW9uOiAxMyxcblxuICAgICAgICAvLyBJZiB0cnVlLCBmcmFnbWVudGVkIG1lc3NhZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhc3NlbWJsZWRcbiAgICAgICAgLy8gYW5kIHRoZSBmdWxsIG1lc3NhZ2Ugd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdtZXNzYWdlJyBldmVudC5cbiAgICAgICAgLy8gSWYgZmFsc2UsIGVhY2ggZnJhbWUgd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdmcmFtZScgZXZlbnQgYW5kXG4gICAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBhZ2dyZWdhdGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBmcmFnbWVudGVkIGZyYW1lcy4gIFNpbmdsZS1mcmFtZSBtZXNzYWdlcyB3aWxsIGVtaXQgYSAnbWVzc2FnZSdcbiAgICAgICAgLy8gZXZlbnQgaW4gYWRkaXRpb24gdG8gdGhlICdmcmFtZScgZXZlbnQuXG4gICAgICAgIC8vIE1vc3QgdXNlcnMgd2lsbCB3YW50IHRvIGxlYXZlIHRoaXMgc2V0IHRvICd0cnVlJ1xuICAgICAgICBhc3NlbWJsZUZyYWdtZW50czogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgTmFnbGUgQWxnb3JpdGhtIG1ha2VzIG1vcmUgZWZmaWNpZW50IHVzZSBvZiBuZXR3b3JrIHJlc291cmNlc1xuICAgICAgICAvLyBieSBpbnRyb2R1Y2luZyBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHNtYWxsIHBhY2tldHMgc28gdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtZXNzYWdlcyBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgZ29pbmcgb250byB0aGVcbiAgICAgICAgLy8gd2lyZS4gIFRoaXMgaG93ZXZlciBjb21lcyBhdCB0aGUgY29zdCBvZiBsYXRlbmN5LCBzbyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpcyB0byBkaXNhYmxlIGl0LiAgSWYgeW91IGRvbid0IG5lZWQgbG93IGxhdGVuY3kgYW5kIGFyZSBzdHJlYW1pbmdcbiAgICAgICAgLy8gbG90cyBvZiBzbWFsbCBtZXNzYWdlcywgeW91IGNhbiBjaGFuZ2UgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIGRpc2FibGVOYWdsZUFsZ29yaXRobTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBjbG9zZSBmcmFtZVxuICAgICAgICAvLyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IHRvIGNvbWUgYmFjayBiZWZvcmUgZ2l2aW5nIHVwIGFuZCBqdXN0XG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIHNvY2tldC5cbiAgICAgICAgY2xvc2VUaW1lb3V0OiA1MDAwLFxuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBodHRwcy5jb25uZWN0IGlmIGNvbm5lY3RpbmcgdmlhIFRMU1xuICAgICAgICB0bHNPcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB0bHNPcHRpb25zO1xuICAgICAgICBpZiAoY29uZmlnLnRsc09wdGlvbnMpIHtcbiAgICAgICAgICB0bHNPcHRpb25zID0gY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZy50bHNPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRsc09wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZy50bHNPcHRpb25zLCB0bHNPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsO1xuICAgIFxuICAgIHN3aXRjaCAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbikge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHdlYlNvY2tldFZlcnNpb24gaXMgbm90IHN1cHBvcnRlZC4gQWxsb3dlZCB2YWx1ZXMgYXJlIDggYW5kIDEzLicpO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRDbGllbnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKHJlcXVlc3RVcmwsIHByb3RvY29scywgb3JpZ2luLCBoZWFkZXJzLCBleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2YocHJvdG9jb2xzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghKHByb3RvY29scyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHM7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG5cbiAgICBpZiAodHlwZW9mKHJlcXVlc3RVcmwpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnVybCA9IHVybC5wYXJzZShyZXF1ZXN0VXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudXJsID0gcmVxdWVzdFVybDsgLy8gaW4gY2FzZSBhbiBhbHJlYWR5IHBhcnNlZCB1cmwgaXMgcGFzc2VkIGluLlxuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLnByb3RvY29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGZ1bGwgV2ViU29ja2V0IFVSTCwgaW5jbHVkaW5nIHByb3RvY29sLicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgZnVsbCBXZWJTb2NrZXQgVVJMLCBpbmNsdWRpbmcgaG9zdG5hbWUuIFJlbGF0aXZlIFVSTHMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWN1cmUgPSAodGhpcy51cmwucHJvdG9jb2wgPT09ICd3c3M6Jyk7XG5cbiAgICAvLyB2YWxpZGF0ZSBwcm90b2NvbCBjaGFyYWN0ZXJzOlxuICAgIHRoaXMucHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG9jb2wpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcHJvdG9jb2wubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwcm90b2NvbC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHByb3RvY29sLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4MDAyMSB8fCBjaGFyQ29kZSA+IDB4MDA3RSB8fCBwcm90b2NvbFNlcGFyYXRvcnMuaW5kZXhPZihjaGFyYWN0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgbGlzdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlciBcIicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVmYXVsdFBvcnRzID0ge1xuICAgICAgICAnd3M6JzogJzgwJyxcbiAgICAgICAgJ3dzczonOiAnNDQzJ1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXJsLnBvcnQpIHtcbiAgICAgICAgdGhpcy51cmwucG9ydCA9IGRlZmF1bHRQb3J0c1t0aGlzLnVybC5wcm90b2NvbF07XG4gICAgfVxuXG4gICAgdmFyIG5vbmNlID0gYnVmZmVyQWxsb2NVbnNhZmUoMTYpO1xuICAgIGZvciAodmFyIGk9MDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgbm9uY2VbaV0gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqMHhGRik7XG4gICAgfVxuICAgIHRoaXMuYmFzZTY0bm9uY2UgPSBub25jZS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgICB2YXIgaG9zdEhlYWRlclZhbHVlID0gdGhpcy51cmwuaG9zdG5hbWU7XG4gICAgaWYgKCh0aGlzLnVybC5wcm90b2NvbCA9PT0gJ3dzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzgwJykgfHxcbiAgICAgICAgKHRoaXMudXJsLnByb3RvY29sID09PSAnd3NzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzQ0MycpKSAge1xuICAgICAgICBob3N0SGVhZGVyVmFsdWUgKz0gKCc6JyArIHRoaXMudXJsLnBvcnQpO1xuICAgIH1cblxuICAgIHZhciByZXFIZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuc2VjdXJlICYmIHRoaXMuY29uZmlnLnRsc09wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2hlYWRlcnMnKSkge1xuICAgICAgLy8gQWxsb3cgZm9yIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBwcm92aWRlZCB3aGVuIGNvbm5lY3RpbmcgdmlhIEhUVFBTXG4gICAgICBleHRlbmQocmVxSGVhZGVycywgdGhpcy5jb25maWcudGxzT3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgcHJvdmlkZWQgaGVhZGVycyB0YWtlIHByaW9yaXR5IG92ZXIgYW55IGZyb20gdGxzT3B0aW9uc1xuICAgICAgZXh0ZW5kKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBleHRlbmQocmVxSGVhZGVycywge1xuICAgICAgICAnVXBncmFkZSc6ICd3ZWJzb2NrZXQnLFxuICAgICAgICAnQ29ubmVjdGlvbic6ICdVcGdyYWRlJyxcbiAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24udG9TdHJpbmcoMTApLFxuICAgICAgICAnU2VjLVdlYlNvY2tldC1LZXknOiB0aGlzLmJhc2U2NG5vbmNlLFxuICAgICAgICAnSG9zdCc6IHJlcUhlYWRlcnMuSG9zdCB8fCBob3N0SGVhZGVyVmFsdWVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcUhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHRoaXMucHJvdG9jb2xzLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJlcUhlYWRlcnNbJ09yaWdpbiddID0gdGhpcy5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gOCkge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IHRoaXMub3JpZ2luO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHZhciBwYXRoQW5kUXVlcnk7XG4gICAgLy8gRW5zdXJlIGl0IGJlZ2lucyB3aXRoICcvJy5cbiAgICBpZiAodGhpcy51cmwucGF0aG5hbWUpIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gdGhpcy51cmwucGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy51cmwucGF0aCkge1xuICAgICAgICBwYXRoQW5kUXVlcnkgPSAnLycgKyB0aGlzLnVybC5wYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gJy8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RFcnJvcihlcnJvcikge1xuICAgICAgICBzZWxmLl9yZXEgPSBudWxsO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nvbm5lY3RGYWlsZWQnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBhZ2VudDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywgZXh0cmFSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRoZXNlIG9wdGlvbnMgYXJlIGFsd2F5cyBvdmVycmlkZGVuIGJ5IHRoZSBsaWJyYXJ5LiAgVGhlIHVzZXIgaXMgbm90XG4gICAgLy8gYWxsb3dlZCB0byBzcGVjaWZ5IHRoZXNlIGRpcmVjdGx5LlxuICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICBob3N0bmFtZTogdGhpcy51cmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHRoaXMudXJsLnBvcnQsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHBhdGg6IHBhdGhBbmRRdWVyeSxcbiAgICAgICAgaGVhZGVyczogcmVxSGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnNlY3VyZSkge1xuICAgICAgICB2YXIgdGxzT3B0aW9ucyA9IHRoaXMuY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0bHNPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGxzT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV4Y2x1ZGVkVGxzT3B0aW9ucy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnNba2V5XSA9IHRsc09wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXEgPSB0aGlzLl9yZXEgPSAodGhpcy5zZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgIHJlcS5vbigndXBncmFkZScsIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RVcGdyYWRlKHJlc3BvbnNlLCBzb2NrZXQsIGhlYWQpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG4gICAgICAgIHNlbGYuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICBzZWxmLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHNlbGYuZmlyc3REYXRhQ2h1bmsgPSBoZWFkO1xuICAgICAgICBzZWxmLnZhbGlkYXRlSGFuZHNoYWtlKCk7XG4gICAgfSk7XG4gICAgcmVxLm9uKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG5cbiAgICByZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgaWYgKHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQoc2VsZiwgJ2h0dHBSZXNwb25zZScpID4gMCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdodHRwUmVzcG9uc2UnLCByZXNwb25zZSwgc2VsZik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhlYWRlckR1bXBQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLnB1c2goaGVhZGVyTmFtZSArICc6ICcgKyByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmFpbEhhbmRzaGFrZShcbiAgICAgICAgICAgICAgICAnU2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgbm9uLTEwMSBzdGF0dXM6ICcgK1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnICcgKyByZXNwb25zZS5zdGF0dXNNZXNzYWdlICtcbiAgICAgICAgICAgICAgICAnXFxuUmVzcG9uc2UgSGVhZGVycyBGb2xsb3c6XFxuJyArXG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLmpvaW4oJ1xcbicpICsgJ1xcbidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLnZhbGlkYXRlSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5wcm90b2NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG9jb2xzLmluZGV4T2YodGhpcy5wcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggYSByZXF1ZXN0ZWQgcHJvdG9jb2wuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBhIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoaGVhZGVyc1snY29ubmVjdGlvbiddICYmIGhlYWRlcnNbJ2Nvbm5lY3Rpb24nXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAndXBncmFkZScpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYSBDb25uZWN0aW9uOiBVcGdyYWRlIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGhlYWRlcnNbJ3VwZ3JhZGUnXSAmJiBoZWFkZXJzWyd1cGdyYWRlJ10udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gJ3dlYnNvY2tldCcpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYW4gVXBncmFkZTogd2Vic29ja2V0IGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBzaGExLnVwZGF0ZSh0aGlzLmJhc2U2NG5vbmNlICsgJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScpO1xuICAgIHZhciBleHBlY3RlZEtleSA9IHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmICghaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlciBmcm9tIHNlcnZlcicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyIGZyb20gc2VydmVyIGRpZG5cXCd0IG1hdGNoIGV4cGVjdGVkIHZhbHVlIG9mICcgKyBleHBlY3RlZEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuc3VjY2VlZEhhbmRzaGFrZSgpO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5mYWlsSGFuZHNoYWtlID0gZnVuY3Rpb24oZXJyb3JEZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC53cml0YWJsZSkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0RmFpbGVkJywgbmV3IEVycm9yKGVycm9yRGVzY3JpcHRpb24pKTtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuc3VjY2VlZEhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldENvbm5lY3Rpb24odGhpcy5zb2NrZXQsIFtdLCB0aGlzLnByb3RvY29sLCB0cnVlLCB0aGlzLmNvbmZpZyk7XG5cbiAgICBjb25uZWN0aW9uLndlYlNvY2tldFZlcnNpb24gPSB0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIGNvbm5lY3Rpb24uX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICBpZiAodGhpcy5maXJzdERhdGFDaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uaGFuZGxlU29ja2V0RGF0YSh0aGlzLmZpcnN0RGF0YUNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5maXJzdERhdGFDaHVuayA9IG51bGw7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3JlcSkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENsaWVudDtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJleHRlbmQiLCJ1dGlsIiwiRXZlbnRFbWl0dGVyIiwiaHR0cCIsImh0dHBzIiwidXJsIiwiY3J5cHRvIiwiV2ViU29ja2V0Q29ubmVjdGlvbiIsImJ1ZmZlckFsbG9jVW5zYWZlIiwicHJvdG9jb2xTZXBhcmF0b3JzIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhjbHVkZWRUbHNPcHRpb25zIiwiV2ViU29ja2V0Q2xpZW50IiwiY29uZmlnIiwiY2FsbCIsIm1heFJlY2VpdmVkRnJhbWVTaXplIiwibWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSIsImZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyIsImZyYWdtZW50YXRpb25UaHJlc2hvbGQiLCJ3ZWJTb2NrZXRWZXJzaW9uIiwiYXNzZW1ibGVGcmFnbWVudHMiLCJkaXNhYmxlTmFnbGVBbGdvcml0aG0iLCJjbG9zZVRpbWVvdXQiLCJ0bHNPcHRpb25zIiwiX3JlcSIsIkVycm9yIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJjb25uZWN0IiwicmVxdWVzdFVybCIsInByb3RvY29scyIsIm9yaWdpbiIsImhlYWRlcnMiLCJleHRyYVJlcXVlc3RPcHRpb25zIiwic2VsZiIsImxlbmd0aCIsIkFycmF5IiwicGFyc2UiLCJwcm90b2NvbCIsImhvc3QiLCJzZWN1cmUiLCJmb3JFYWNoIiwiaSIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImNoYXJhY3RlciIsImNoYXJBdCIsImluZGV4T2YiLCJkZWZhdWx0UG9ydHMiLCJwb3J0Iiwibm9uY2UiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJiYXNlNjRub25jZSIsInRvU3RyaW5nIiwiaG9zdEhlYWRlclZhbHVlIiwiaG9zdG5hbWUiLCJyZXFIZWFkZXJzIiwiaGFzT3duUHJvcGVydHkiLCJIb3N0Iiwiam9pbiIsInBhdGhBbmRRdWVyeSIsInBhdGhuYW1lIiwicGF0aCIsImhhbmRsZVJlcXVlc3RFcnJvciIsImVycm9yIiwiZW1pdCIsInJlcXVlc3RPcHRpb25zIiwiYWdlbnQiLCJtZXRob2QiLCJrZXkiLCJyZXEiLCJyZXF1ZXN0Iiwib24iLCJoYW5kbGVSZXF1ZXN0VXBncmFkZSIsInJlc3BvbnNlIiwic29ja2V0IiwiaGVhZCIsInJlbW92ZUxpc3RlbmVyIiwiZmlyc3REYXRhQ2h1bmsiLCJ2YWxpZGF0ZUhhbmRzaGFrZSIsImV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQiLCJlbmQiLCJoZWFkZXJEdW1wUGFydHMiLCJoZWFkZXJOYW1lIiwicHVzaCIsImZhaWxIYW5kc2hha2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwic2hhMSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJleHBlY3RlZEtleSIsImRpZ2VzdCIsInN1Y2NlZWRIYW5kc2hha2UiLCJlcnJvckRlc2NyaXB0aW9uIiwid3JpdGFibGUiLCJjb25uZWN0aW9uIiwiX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzIiwiaGFuZGxlU29ja2V0RGF0YSIsImFib3J0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketClient.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"(action-browser)/./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"(action-browser)/./node_modules/websocket/vendor/FastBufferList.js\");\nvar isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(action-browser)/./node_modules/utf-8-validate/index.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = \"open\";\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = \"peer_requested_close\";\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = \"ending\";\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = \"closed\";\nvar setImmediateImpl = \"setImmediate\" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);\nvar idCounter = 0;\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger(\"websocket:connection\", ++idCounter);\n    this._debug(\"constructor\");\n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._pingListenerCount = 0;\n    this.on(\"newListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount++;\n        }\n    }).on(\"removeListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount--;\n        }\n    });\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof this.config.keepaliveInterval !== \"number\") {\n            throw new Error(\"keepaliveInterval must be specified and numeric \" + \"if keepalive is true.\");\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof this.config.keepaliveGracePeriod !== \"number\") {\n                throw new Error(\"keepaliveGracePeriod  must be specified and \" + \"numeric if dropConnectionOnKeepaliveTimeout \" + \"is true.\");\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    } else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!(\"setKeepAlive\" in this.socket)) {\n            throw new Error(\"Unable to use native keepalive: unsupported by \" + \"this version of Node.\");\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners(\"error\");\n}\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: \"Normal connection closure\",\n    1001: \"Remote peer is going away\",\n    1002: \"Protocol error\",\n    1003: \"Unprocessable input\",\n    1004: \"Reserved\",\n    1005: \"Reason not provided\",\n    1006: \"Abnormal closure, no further detail available\",\n    1007: \"Invalid data received\",\n    1008: \"Policy violation\",\n    1009: \"Message too big\",\n    1010: \"Extension requested by client is required\",\n    1011: \"Internal Server Error\",\n    1015: \"TLS Handshake Failed\"\n};\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [\n            1000,\n            1001,\n            1002,\n            1003,\n            1007,\n            1008,\n            1009,\n            1010,\n            1011,\n            1012,\n            1013,\n            1014,\n            1015\n        ].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\nutil.inherits(WebSocketConnection, EventEmitter);\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on(\"error\", this.handleSocketError.bind(this));\n    this.socket.on(\"end\", this.handleSocketEnd.bind(this));\n    this.socket.on(\"close\", this.handleSocketClose.bind(this));\n    this.socket.on(\"drain\", this.handleSocketDrain.bind(this));\n    this.socket.on(\"pause\", this.handleSocketPause.bind(this));\n    this.socket.on(\"resume\", this.handleSocketResume.bind(this));\n    this.socket.on(\"data\", this.handleSocketData.bind(this));\n};\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug(\"setKeepaliveTimer\");\n    if (!this.config.keepalive || this.config.useNativeKeepalive) {\n        return;\n    }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug(\"handleKeepaliveTimer\");\n    this._keepaliveTimeoutID = null;\n    this.ping();\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    } else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug(\"setGracePeriodTimer\");\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug(\"handleGracePeriodTimer\");\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, \"Peer not responding.\", true);\n};\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug(\"handleSocketData\");\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug(\"processReceivedData\");\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) {\n        return;\n    }\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) {\n        return;\n    }\n    var frame = this.currentFrame;\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) {\n        this._debug(\"-- insufficient data for frame\");\n        return;\n    }\n    var self = this;\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug(\"-- protocol error\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    } else if (frame.frameTooLarge) {\n        this._debug(\"-- frame too large\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug(\"-- illegal rsv flag\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unsupported usage of rsv bits without negotiated extension.\");\n        });\n        return;\n    }\n    if (!this.assembleFragments) {\n        this._debug(\"-- emitting frame\");\n        process.nextTick(function() {\n            self.emit(\"frame\", frame);\n        });\n    }\n    process.nextTick(function() {\n        self.processFrame(frame);\n    });\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug(\"handleSocketError: %j\", error);\n    if (this.state === STATE_CLOSED) {\n        // See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug(\"  --- Socket 'error' after 'close'\");\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = \"Socket Error: \" + error.syscall + \" \" + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, \"error\") > 0) {\n        this.emit(\"error\", error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug(\"handleSocketEnd: received socket end.  state = %s\", this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug(\"  --- Socket 'end' after 'close'\");\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {\n        this._debug(\"  --- UNEXPECTED socket end.\");\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug(\"handleSocketClose: received socket close\");\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = \"Connection dropped by remote peer.\";\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"-- Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n};\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug(\"handleSocketDrain: socket drain event\");\n    this.outputBufferFull = false;\n    this.emit(\"drain\");\n};\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug(\"handleSocketPause: socket pause event\");\n    this.inputPaused = true;\n    this.emit(\"pause\");\n};\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug(\"handleSocketResume: socket resume event\");\n    this.inputPaused = false;\n    this.emit(\"resume\");\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.pause = function() {\n    this._debug(\"pause: pause requested\");\n    this.socket.pause();\n};\nWebSocketConnection.prototype.resume = function() {\n    this._debug(\"resume: resume requested\");\n    this.socket.resume();\n};\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug(\"close: Initating clean WebSocket close sequence.\");\n        if (\"number\" !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error(\"Close code \" + reasonCode + \" is not valid.\");\n        }\n        if (\"string\" !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug(\"drop\");\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n    if (typeof description !== \"string\") {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n    this._debug(\"Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s\", skipCloseFrame, reasonCode, description);\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n    this._debug(\"Drop: destroying socket\");\n    this.socket.destroy();\n};\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug(\"setCloseTimer\");\n    this.clearCloseTimer();\n    this._debug(\"Setting close timer\");\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug(\"clearCloseTimer\");\n    if (this.closeTimer) {\n        this._debug(\"Clearing close timer\");\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug(\"handleCloseTimer\");\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug(\"Close response not received from client.  Forcing socket end.\");\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug(\"processFrame\");\n    this._debug(\" -- frame: %s\", frame);\n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && frame.opcode > 0x00 && frame.opcode < 0x08) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Illegal frame opcode 0x\" + frame.opcode.toString(16) + \" \" + \"received in middle of fragmented message.\");\n        return;\n    }\n    switch(frame.opcode){\n        case 0x02:\n            this._debug(\"-- Binary Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"binary\",\n                        binaryData: frame.binaryPayload\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01:\n            this._debug(\"-- Text Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"utf8\",\n                        utf8Data: frame.binaryPayload.toString(\"utf8\")\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00:\n            this._debug(\"-- Continuation Frame\");\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected Continuation Frame\");\n                    return;\n                }\n                this.fragmentationSize += frame.length;\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, \"Maximum message size exceeded.\");\n                    return;\n                }\n                this.frameQueue.push(frame);\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function(currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n                    switch(opcode){\n                        case 0x02:\n                            this.emit(\"message\", {\n                                type: \"binary\",\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01:\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                                return;\n                            }\n                            this.emit(\"message\", {\n                                type: \"utf8\",\n                                utf8Data: binaryPayload.toString(\"utf8\")\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected first opcode in fragmentation sequence: 0x\" + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09:\n            this._debug(\"-- Ping Frame\");\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.emit(\"ping\", cancel, frame.binaryPayload);\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            } else {\n                this.pong(frame.binaryPayload);\n            }\n            break;\n        case 0x0A:\n            this._debug(\"-- Pong Frame\");\n            this.emit(\"pong\", frame.binaryPayload);\n            break;\n        case 0x08:\n            this._debug(\"-- Close Frame\");\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug(\"---- Got close response from peer.  Completing closing handshake.\");\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            this._debug(\"---- Closing handshake initiated by peer.\");\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            } else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString(\"utf8\");\n            } else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\"------ Remote peer %s - code: %d - %s - close frame payload length: %d\", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);\n            this._debug(\"------ responding to remote peer's close request.\");\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug(\"-- Unrecognized Opcode %d\", frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unrecognized Opcode: 0x\" + frame.opcode.toString(16));\n            break;\n    }\n};\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug(\"send\");\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    } else if (typeof data[\"toString\"] === \"function\") {\n        this.sendUTF(data, cb);\n    } else {\n        throw new Error(\"Data provided must either be a Node Buffer or implement toString()\");\n    }\n};\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), \"utf8\");\n    this._debug(\"sendUTF: %d bytes\", data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug(\"sendBytes\");\n    if (!Buffer.isBuffer(data)) {\n        throw new Error(\"You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()\");\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug(\"ping\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), \"utf8\");\n        }\n        if (data.length > 125) {\n            this._debug(\"WebSocket: Data for ping is longer than 125 bytes.  Truncating.\");\n            data = data.slice(0, 124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug(\"pong\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug(\"WebSocket: Data for pong is longer than 125 bytes.  Truncating.\");\n        binaryPayload = binaryPayload.slice(0, 124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug(\"fragmentAndSend\");\n    if (frame.opcode > 0x07) {\n        throw new Error(\"You cannot fragment control frames.\");\n    }\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === \"function\") {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if (sentFragments === numFragments && typeof cb === \"function\") {\n            cb();\n        }\n    };\n    for(var i = 1; i <= numFragments; i++){\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        // continuation opcode except for first frame.\n        currentFrame.opcode = i === 1 ? frame.opcode : 0x00;\n        // fin set on last frame only\n        currentFrame.fin = i === numFragments;\n        // length is likely to be shorter on the last fragment\n        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;\n        var sliceStart = threshold * (i - 1);\n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    this._debug(\"sendCloseFrame state: %s, reasonCode: %d, description: %s\", this.state, reasonCode, description);\n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {\n        return;\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof description === \"string\") {\n        frame.binaryPayload = bufferFromString(description, \"utf8\");\n    }\n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug(\"sendFrame\");\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\nmodule.exports = WebSocketConnection;\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */ if (!connection._debug.enabled) {\n        return;\n    }\n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug(\"||| Socket Event  '%s'\", event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    for(var key in socket){\n        if (\"function\" !== typeof socket[key]) {\n            continue;\n        }\n        if ([\n            \"emit\"\n        ].indexOf(key) !== -1) {\n            continue;\n        }\n        (function(key) {\n            var original = socket[key];\n            if (key === \"on\") {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug(\"||| Socket method called:  %s (%s)\", key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug(\"||| Socket method called:  %s\", key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxlQUFlRiwwREFBOEI7QUFDakQsSUFBSUcsaUJBQWlCSCxtQkFBT0EsQ0FBQztBQUM3QixJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQztBQUN6QixJQUFJSyxjQUFjTCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJTSxvQkFBb0JMLE1BQU1LLGlCQUFpQjtBQUMvQyxJQUFJQyxtQkFBbUJOLE1BQU1NLGdCQUFnQjtBQUU3QywwREFBMEQ7QUFDMUQsTUFBTUMsYUFBYTtBQUNuQiw4Q0FBOEM7QUFDOUMsTUFBTUMsNkJBQTZCO0FBQ25DLGlFQUFpRTtBQUNqRSxNQUFNQyxlQUFlO0FBQ3JCLHdFQUF3RTtBQUN4RSxNQUFNQyxlQUFlO0FBRXJCLElBQUlDLG1CQUFtQixrQkFBbUJDLFNBQ2RBLE9BQU9DLFlBQVksQ0FBQ0MsSUFBSSxDQUFDRixVQUN6QkcsUUFBUUMsUUFBUSxDQUFDRixJQUFJLENBQUNDO0FBRWxELElBQUlFLFlBQVk7QUFFaEIsU0FBU0Msb0JBQW9CQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxtQkFBbUIsRUFBRUMsTUFBTTtJQUNsRixJQUFJLENBQUNDLE1BQU0sR0FBR3hCLE1BQU15QixlQUFlLENBQUMsd0JBQXdCLEVBQUVSO0lBQzlELElBQUksQ0FBQ08sTUFBTSxDQUFDO0lBRVosSUFBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQ0UsT0FBTyxFQUFFO1FBQ3JCQyw2QkFBNkIsSUFBSSxFQUFFUjtJQUN2QztJQUVBLHlCQUF5QjtJQUN6QmxCLGFBQWEyQixJQUFJLENBQUMsSUFBSTtJQUV0QixJQUFJLENBQUNDLGtCQUFr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RUFBRTtvQkFDekUsT0FBT0UsU0FBU0gsS0FBSyxDQUFDLElBQUksRUFBRUM7Z0JBQ2hDO2dCQUNBO1lBQ0o7WUFDQXZLLE1BQU0sQ0FBQ3dLLElBQUksR0FBRyxTQUFTRztnQkFDbkJSLFdBQVc5SixNQUFNLENBQUMsaUNBQWlDbUs7Z0JBQ25ELE9BQU9DLFNBQVNILEtBQUssQ0FBQyxJQUFJLEVBQUVDO1lBQ2hDO1FBQ0osR0FBR0M7SUFDUDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Q29ubmVjdGlvbi5qcz80ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldEZyYW1lID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRGcmFtZScpO1xudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuLi92ZW5kb3IvRmFzdEJ1ZmZlckxpc3QnKTtcbnZhciBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSB1dGlscy5idWZmZXJBbGxvY1Vuc2FmZTtcbnZhciBidWZmZXJGcm9tU3RyaW5nID0gdXRpbHMuYnVmZmVyRnJvbVN0cmluZztcblxuLy8gQ29ubmVjdGVkLCBmdWxseS1vcGVuLCByZWFkeSB0byBzZW5kIGFuZCByZWNlaXZlIGZyYW1lc1xuY29uc3QgU1RBVEVfT1BFTiA9ICdvcGVuJztcbi8vIFJlY2VpdmVkIGEgY2xvc2UgZnJhbWUgZnJvbSB0aGUgcmVtb3RlIHBlZXJcbmNvbnN0IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFID0gJ3BlZXJfcmVxdWVzdGVkX2Nsb3NlJztcbi8vIFNlbnQgY2xvc2UgZnJhbWUgdG8gcmVtb3RlIHBlZXIuICBObyBmdXJ0aGVyIGRhdGEgY2FuIGJlIHNlbnQuXG5jb25zdCBTVEFURV9FTkRJTkcgPSAnZW5kaW5nJztcbi8vIENvbm5lY3Rpb24gaXMgZnVsbHkgY2xvc2VkLiAgTm8gZnVydGhlciBkYXRhIGNhbiBiZSBzZW50IG9yIHJlY2VpdmVkLlxuY29uc3QgU1RBVEVfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cbnZhciBzZXRJbW1lZGlhdGVJbXBsID0gKCdzZXRJbW1lZGlhdGUnIGluIGdsb2JhbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWwpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2Vzcyk7XG5cbnZhciBpZENvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRDb25uZWN0aW9uKHNvY2tldCwgZXh0ZW5zaW9ucywgcHJvdG9jb2wsIG1hc2tPdXRnb2luZ1BhY2tldHMsIGNvbmZpZykge1xuICAgIHRoaXMuX2RlYnVnID0gdXRpbHMuQnVmZmVyaW5nTG9nZ2VyKCd3ZWJzb2NrZXQ6Y29ubmVjdGlvbicsICsraWRDb3VudGVyKTtcbiAgICB0aGlzLl9kZWJ1ZygnY29uc3RydWN0b3InKTtcbiAgICBcbiAgICBpZiAodGhpcy5fZGVidWcuZW5hYmxlZCkge1xuICAgICAgICBpbnN0cnVtZW50U29ja2V0Rm9yRGVidWdnaW5nKHRoaXMsIHNvY2tldCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50ID0gMDtcbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldiA9PT0gJ3BpbmcnKXtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldiA9PT0gJ3BpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudC0tO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IC0xO1xuICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCA9IGZhbHNlO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBtYXNrIG91dGdvaW5nIHBhY2tldHMgaWYgd2UncmUgYWN0aW5nIGFzIGEgV2ViU29ja2V0IGNsaWVudC5cbiAgICB0aGlzLm1hc2tPdXRnb2luZ1BhY2tldHMgPSBtYXNrT3V0Z29pbmdQYWNrZXRzO1xuXG4gICAgLy8gV2UgcmUtdXNlIHRoZSBzYW1lIGJ1ZmZlcnMgZm9yIHRoZSBtYXNrIGFuZCBmcmFtZSBoZWFkZXIgZm9yIGFsbCBmcmFtZXNcbiAgICAvLyByZWNlaXZlZCBvbiBlYWNoIGNvbm5lY3Rpb24gdG8gYXZvaWQgYSBzbWFsbCBtZW1vcnkgYWxsb2NhdGlvbiBmb3IgZWFjaFxuICAgIC8vIGZyYW1lLlxuICAgIHRoaXMubWFza0J5dGVzID0gYnVmZmVyQWxsb2NVbnNhZmUoNCk7XG4gICAgdGhpcy5mcmFtZUhlYWRlciA9IGJ1ZmZlckFsbG9jVW5zYWZlKDEwKTtcblxuICAgIC8vIHRoZSBCdWZmZXJMaXN0IHdpbGwgaGFuZGxlIHRoZSBkYXRhIHN0cmVhbWluZyBpblxuICAgIHRoaXMuYnVmZmVyTGlzdCA9IG5ldyBCdWZmZXJMaXN0KCk7XG5cbiAgICAvLyBQcmVwYXJlIGZvciByZWNlaXZpbmcgZmlyc3QgZnJhbWVcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSAwOyAvLyBkYXRhIHJlY2VpdmVkIHNvIGZhci4uLlxuICAgIHRoaXMuZnJhbWVRdWV1ZSA9IFtdO1xuICAgIFxuICAgIC8vIFZhcmlvdXMgYml0cyBvZiBjb25uZWN0aW9uIHN0YXRlXG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9PUEVOO1xuICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAvLyBSZWNlaXZlZCBUQ1AgRklOLCBzb2NrZXQncyByZWFkYWJsZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gICAgdGhpcy5yZWNlaXZlZEVuZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jbG9zZVRpbWVvdXQgPSB0aGlzLmNvbmZpZy5jbG9zZVRpbWVvdXQ7XG4gICAgdGhpcy5hc3NlbWJsZUZyYWdtZW50cyA9IHRoaXMuY29uZmlnLmFzc2VtYmxlRnJhZ21lbnRzO1xuICAgIHRoaXMubWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSA9IHRoaXMuY29uZmlnLm1heFJlY2VpdmVkTWVzc2FnZVNpemU7XG5cbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSBmYWxzZTtcbiAgICB0aGlzLmlucHV0UGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZWNlaXZlZERhdGFIYW5kbGVyID0gdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2xvc2VUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUNsb3NlVGltZXIuYmluZCh0aGlzKTtcblxuICAgIC8vIERpc2FibGUgbmFnbGUgYWxnb3JpdGhtP1xuICAgIHRoaXMuc29ja2V0LnNldE5vRGVsYXkodGhpcy5jb25maWcuZGlzYWJsZU5hZ2xlQWxnb3JpdGhtKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBubyBzb2NrZXQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gICAgdGhpcy5zb2NrZXQuc2V0VGltZW91dCgwKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwYWxpdmUgJiYgIXRoaXMuY29uZmlnLnVzZU5hdGl2ZUtlZXBhbGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuY29uZmlnLmtlZXBhbGl2ZUludGVydmFsKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2VlcGFsaXZlSW50ZXJ2YWwgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG51bWVyaWMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lmIGtlZXBhbGl2ZSBpcyB0cnVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tlZXBhbGl2ZVRpbWVySGFuZGxlciA9IHRoaXMuaGFuZGxlS2VlcGFsaXZlVGltZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRLZWVwYWxpdmVUaW1lcigpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5kcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLmNvbmZpZy5rZWVwYWxpdmVHcmFjZVBlcmlvZCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZWVwYWxpdmVHcmFjZVBlcmlvZCAgbXVzdCBiZSBzcGVjaWZpZWQgYW5kICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtZXJpYyBpZiBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lzIHRydWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ncmFjZVBlcmlvZFRpbWVySGFuZGxlciA9IHRoaXMuaGFuZGxlR3JhY2VQZXJpb2RUaW1lci5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmtlZXBhbGl2ZSAmJiB0aGlzLmNvbmZpZy51c2VOYXRpdmVLZWVwYWxpdmUpIHtcbiAgICAgICAgaWYgKCEoJ3NldEtlZXBBbGl2ZScgaW4gdGhpcy5zb2NrZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB1c2UgbmF0aXZlIGtlZXBhbGl2ZTogdW5zdXBwb3J0ZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoaXMgdmVyc2lvbiBvZiBOb2RlLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRoZSBIVFRQIENsaWVudCBzZWVtcyB0byBzdWJzY3JpYmUgdG8gc29ja2V0IGVycm9yIGV2ZW50c1xuICAgIC8vIGFuZCByZS1kaXNwYXRjaCB0aGVtIGluIHN1Y2ggYSB3YXkgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyBmb3IgdXNlcnMgb2Ygb3VyIGNsaWVudCwgc28gd2Ugd2FudCB0byBtYWtlIHN1cmUgbm9ib2R5XG4gICAgLy8gZWxzZSBpcyBsaXN0ZW5pbmcgZm9yIGVycm9yIGV2ZW50cyBvbiB0aGUgc29ja2V0IGJlc2lkZXMgdXMuXG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xufVxuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUwgPSAxMDAwO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fR09JTkdfQVdBWSA9IDEwMDE7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUiA9IDEwMDI7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9VTlBST0NFU1NBQkxFX0lOUFVUID0gMTAwMztcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1JFU0VSVkVEID0gMTAwNDsgLy8gUmVzZXJ2ZWQgdmFsdWUuICBVbmRlZmluZWQgbWVhbmluZy5cbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PVF9QUk9WSURFRCA9IDEwMDU7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTCA9IDEwMDY7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEgPSAxMDA3O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUE9MSUNZX1ZJT0xBVElPTiA9IDEwMDg7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUcgPSAxMDA5O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fRVhURU5TSU9OX1JFUVVJUkVEID0gMTAxMDtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVEVSTkFMX1NFUlZFUl9FUlJPUiA9IDEwMTE7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9UTFNfSEFORFNIQUtFX0ZBSUxFRCA9IDEwMTU7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5cbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TID0ge1xuICAgIDEwMDA6ICdOb3JtYWwgY29ubmVjdGlvbiBjbG9zdXJlJyxcbiAgICAxMDAxOiAnUmVtb3RlIHBlZXIgaXMgZ29pbmcgYXdheScsXG4gICAgMTAwMjogJ1Byb3RvY29sIGVycm9yJyxcbiAgICAxMDAzOiAnVW5wcm9jZXNzYWJsZSBpbnB1dCcsXG4gICAgMTAwNDogJ1Jlc2VydmVkJyxcbiAgICAxMDA1OiAnUmVhc29uIG5vdCBwcm92aWRlZCcsXG4gICAgMTAwNjogJ0Fibm9ybWFsIGNsb3N1cmUsIG5vIGZ1cnRoZXIgZGV0YWlsIGF2YWlsYWJsZScsXG4gICAgMTAwNzogJ0ludmFsaWQgZGF0YSByZWNlaXZlZCcsXG4gICAgMTAwODogJ1BvbGljeSB2aW9sYXRpb24nLFxuICAgIDEwMDk6ICdNZXNzYWdlIHRvbyBiaWcnLFxuICAgIDEwMTA6ICdFeHRlbnNpb24gcmVxdWVzdGVkIGJ5IGNsaWVudCBpcyByZXF1aXJlZCcsXG4gICAgMTAxMTogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgMTAxNTogJ1RMUyBIYW5kc2hha2UgRmFpbGVkJ1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVDbG9zZVJlYXNvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCAxMDAwKSB7XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlcyBpbiB0aGUgcmFuZ2UgMC05OTkgYXJlIG5vdCB1c2VkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDI5OTkpIHtcbiAgICAgICAgLy8gQ29kZXMgZnJvbSAxMDAwIC0gMjk5OSBhcmUgcmVzZXJ2ZWQgZm9yIHVzZSBieSB0aGUgcHJvdG9jb2wuICBPbmx5XG4gICAgICAgIC8vIGEgZmV3IGNvZGVzIGFyZSBkZWZpbmVkLCBhbGwgb3RoZXJzIGFyZSBjdXJyZW50bHkgaWxsZWdhbC5cbiAgICAgICAgcmV0dXJuIFsxMDAwLCAxMDAxLCAxMDAyLCAxMDAzLCAxMDA3LCAxMDA4LCAxMDA5LCAxMDEwLCAxMDExLCAxMDEyLCAxMDEzLCAxMDE0LCAxMDE1XS5pbmRleE9mKGNvZGUpICE9PSAtMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDM5OTkpIHtcbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIHVzZSBieSBsaWJyYXJpZXMsIGZyYW1ld29ya3MsIGFuZCBhcHBsaWNhdGlvbnMuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggSUFOQS4gIEludGVycHJldGF0aW9uIG9mIHRoZXNlIGNvZGVzIGlzXG4gICAgICAgIC8vIHVuZGVmaW5lZCBieSB0aGUgV2ViU29ja2V0IHByb3RvY29sLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gNDAwMCAmJiBjb2RlIDw9IDQ5OTkpIHtcbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIHByaXZhdGUgdXNlLiAgSW50ZXJwcmV0YXRpb24gb2YgdGhlc2UgY29kZXMgaXNcbiAgICAgICAgLy8gdW5kZWZpbmVkIGJ5IHRoZSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA1MDAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Q29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5oYW5kbGVTb2NrZXRFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgdGhpcy5oYW5kbGVTb2NrZXRFbmQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5oYW5kbGVTb2NrZXRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZHJhaW4nLCB0aGlzLmhhbmRsZVNvY2tldERyYWluLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdwYXVzZScsIHRoaXMuaGFuZGxlU29ja2V0UGF1c2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ3Jlc3VtZScsIHRoaXMuaGFuZGxlU29ja2V0UmVzdW1lLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5oYW5kbGVTb2NrZXREYXRhLmJpbmQodGhpcykpO1xufTtcblxuLy8gc2V0IG9yIHJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgd2hlbiBkYXRhIGlzIHJlY2VpdmVkLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2V0S2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0S2VlcGFsaXZlVGltZXInKTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmtlZXBhbGl2ZSAgfHwgdGhpcy5jb25maWcudXNlTmF0aXZlS2VlcGFsaXZlKSB7IHJldHVybjsgfVxuICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgdGhpcy5fa2VlcGFsaXZlVGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLl9rZWVwYWxpdmVUaW1lckhhbmRsZXIsIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUludGVydmFsKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyS2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fa2VlcGFsaXZlVGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQpO1xuICAgIH1cbn07XG5cbi8vIE5vIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgd2l0aGluIGNvbmZpZy5rZWVwYWxpdmVUaW1lb3V0IG1zLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlS2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlS2VlcGFsaXZlVGltZXInKTtcbiAgICB0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQgPSBudWxsO1xuICAgIHRoaXMucGluZygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGNvbmZpZ3VyZWQgdG8gZHJvcCBjb25uZWN0aW9ucyBpZiB0aGUgY2xpZW50IGRvZXNuJ3QgcmVzcG9uZFxuICAgIC8vIHRoZW4gc2V0IHRoZSBncmFjZSBwZXJpb2QgdGltZXIuXG4gICAgaWYgKHRoaXMuY29uZmlnLmRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuc2V0R3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgdG8gc2VuZCB0aGUgbmV4dCBwaW5nLlxuICAgICAgICB0aGlzLnNldEtlZXBhbGl2ZVRpbWVyKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2V0R3JhY2VQZXJpb2RUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdzZXRHcmFjZVBlcmlvZFRpbWVyJyk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICB0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5fZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIsIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUdyYWNlUGVyaW9kKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyR3JhY2VQZXJpb2RUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlR3JhY2VQZXJpb2RUaW1lcicpO1xuICAgIC8vIElmIHRoaXMgaXMgY2FsbGVkLCB0aGUgY2xpZW50IGhhcyBub3QgcmVzcG9uZGVkIGFuZCBpcyBhc3N1bWVkIGRlYWQuXG4gICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQgPSBudWxsO1xuICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTCwgJ1BlZXIgbm90IHJlc3BvbmRpbmcuJywgdHJ1ZSk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXREYXRhJyk7XG4gICAgLy8gUmVzZXQgdGhlIGtlZXBhbGl2ZSB0aW1lciB3aGVuIHJlY2VpdmluZyBkYXRhIG9mIGFueSBraW5kLlxuICAgIHRoaXMuc2V0S2VlcGFsaXZlVGltZXIoKTtcblxuICAgIC8vIEFkZCByZWNlaXZlZCBkYXRhIHRvIG91ciBidWZmZXJMaXN0LCB3aGljaCBlZmZpY2llbnRseSBob2xkcyByZWNlaXZlZFxuICAgIC8vIGRhdGEgY2h1bmtzIGluIGEgbGlua2VkIGxpc3Qgb2YgQnVmZmVyIG9iamVjdHMuXG4gICAgdGhpcy5idWZmZXJMaXN0LndyaXRlKGRhdGEpO1xuXG4gICAgdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzUmVjZWl2ZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Byb2Nlc3NSZWNlaXZlZERhdGEnKTtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBzaG91bGQgaWdub3JlIGFueSBkYXRhIHJlbWFpbmluZyBvbiB0aGUgYnVmZmVyLlxuICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBSZWNlaXZpbmcvcGFyc2luZyBpcyBleHBlY3RlZCB0byBiZSBoYWx0ZWQgd2hlbiBwYXVzZWQuXG4gICAgaWYgKHRoaXMuaW5wdXRQYXVzZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblxuICAgIC8vIFdlYlNvY2tldEZyYW1lLnByb3RvdHlwZS5hZGREYXRhIHJldHVybnMgdHJ1ZSBpZiBhbGwgZGF0YSBuZWNlc3NhcnkgdG9cbiAgICAvLyBwYXJzZSB0aGUgZnJhbWUgd2FzIGF2YWlsYWJsZS4gIEl0IHJldHVybnMgZmFsc2UgaWYgd2UgYXJlIHdhaXRpbmcgZm9yXG4gICAgLy8gbW9yZSBkYXRhIHRvIGNvbWUgaW4gb24gdGhlIHdpcmUuXG4gICAgaWYgKCFmcmFtZS5hZGREYXRhKHRoaXMuYnVmZmVyTGlzdCkpIHsgdGhpcy5fZGVidWcoJy0tIGluc3VmZmljaWVudCBkYXRhIGZvciBmcmFtZScpOyByZXR1cm47IH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIEhhbmRsZSBwb3NzaWJsZSBwYXJzaW5nIGVycm9yc1xuICAgIGlmIChmcmFtZS5wcm90b2NvbEVycm9yKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBiYWQgaGFwcGVuZWQuLiBnZXQgcmlkIG9mIHRoaXMgY2xpZW50LlxuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gcHJvdG9jb2wgZXJyb3InKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUiwgZnJhbWUuZHJvcFJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYW1lLmZyYW1lVG9vTGFyZ2UpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGZyYW1lIHRvbyBsYXJnZScpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRywgZnJhbWUuZHJvcFJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vdyBzaW5jZSB3ZSBkb24ndCBzdXBwb3J0IGV4dGVuc2lvbnMsIGFsbCBSU1YgYml0cyBhcmUgaWxsZWdhbFxuICAgIGlmIChmcmFtZS5yc3YxIHx8IGZyYW1lLnJzdjIgfHwgZnJhbWUucnN2Mykge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gaWxsZWdhbCByc3YgZmxhZycpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAnVW5zdXBwb3J0ZWQgdXNhZ2Ugb2YgcnN2IGJpdHMgd2l0aG91dCBuZWdvdGlhdGVkIGV4dGVuc2lvbi4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXNzZW1ibGVGcmFnbWVudHMpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGVtaXR0aW5nIGZyYW1lJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuZW1pdCgnZnJhbWUnLCBmcmFtZSk7IH0pO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYucHJvY2Vzc0ZyYW1lKGZyYW1lKTsgfSk7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcblxuICAgIC8vIElmIHRoZXJlJ3MgZGF0YSByZW1haW5pbmcsIHNjaGVkdWxlIGFkZGl0aW9uYWwgcHJvY2Vzc2luZywgYnV0IHlpZWxkXG4gICAgLy8gZm9yIG5vdyBzbyB0aGF0IG90aGVyIGNvbm5lY3Rpb25zIGhhdmUgYSBjaGFuY2UgdG8gaGF2ZSB0aGVpciBkYXRhXG4gICAgLy8gcHJvY2Vzc2VkLiAgV2UgdXNlIHNldEltbWVkaWF0ZSBoZXJlIGluc3RlYWQgb2YgcHJvY2Vzcy5uZXh0VGljayB0b1xuICAgIC8vIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhhdCB3ZSB3aXNoIGZvciBvdGhlciBJL08gdG8gYmUgaGFuZGxlZCBmaXJzdC5cbiAgICBpZiAodGhpcy5idWZmZXJMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlSW1wbCh0aGlzLnJlY2VpdmVkRGF0YUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RXJyb3I6ICVqJywgZXJyb3IpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9DTE9TRUQpIHtcblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2lzc3Vlcy8yODhcbiAgICAgICAgdGhpcy5fZGVidWcoJyAgLS0tIFNvY2tldCBcXCdlcnJvclxcJyBhZnRlciBcXCdjbG9zZVxcJycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUw7XG4gICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gJ1NvY2tldCBFcnJvcjogJyArIGVycm9yLnN5c2NhbGwgKyAnICcgKyBlcnJvci5jb2RlO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcbiAgICBpZiAodXRpbHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuX2RlYnVnLnByaW50T3V0cHV0KCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRFbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RW5kOiByZWNlaXZlZCBzb2NrZXQgZW5kLiAgc3RhdGUgPSAlcycsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMucmVjZWl2ZWRFbmQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9DTE9TRUQpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyB0aGUgVExTIG1vZHVsZSwgc29tZXRpbWVzIHRoZSBzb2NrZXQgd2lsbCBlbWl0ICdlbmQnXG4gICAgICAgIC8vIGFmdGVyIGl0IGVtaXRzICdjbG9zZScuICBJIGRvbid0IHRoaW5rIHRoYXQncyBjb3JyZWN0IGJlaGF2aW9yLFxuICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGRlYWwgd2l0aCBpdCBncmFjZWZ1bGx5IGJ5IGlnbm9yaW5nIGl0LlxuICAgICAgICB0aGlzLl9kZWJ1ZygnICAtLS0gU29ja2V0IFxcJ2VuZFxcJyBhZnRlciBcXCdjbG9zZVxcJycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSAmJlxuICAgICAgICB0aGlzLnN0YXRlICE9PSBTVEFURV9FTkRJTkcpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCcgIC0tLSBVTkVYUEVDVEVEIHNvY2tldCBlbmQuJyk7XG4gICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRDbG9zZSA9IGZ1bmN0aW9uKGhhZEVycm9yKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldENsb3NlOiByZWNlaXZlZCBzb2NrZXQgY2xvc2UnKTtcbiAgICB0aGlzLnNvY2tldEhhZEVycm9yID0gaGFkRXJyb3I7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgIC8vIElmIGNsb3NlUmVhc29uQ29kZSBpcyBzdGlsbCBzZXQgdG8gLTEgYXQgdGhpcyBwb2ludCB0aGVuIHdlIG11c3RcbiAgICAvLyBub3QgaGF2ZSByZWNlaXZlZCBhIGNsb3NlIGZyYW1lISFcbiAgICBpZiAodGhpcy5jbG9zZVJlYXNvbkNvZGUgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUw7XG4gICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9ICdDb25uZWN0aW9uIGRyb3BwZWQgYnkgcmVtb3RlIHBlZXIuJztcbiAgICB9XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIGlmICghdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCkge1xuICAgICAgICB0aGlzLmNsb3NlRXZlbnRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIEVtaXR0aW5nIFdlYlNvY2tldENvbm5lY3Rpb24gY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldERyYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldERyYWluOiBzb2NrZXQgZHJhaW4gZXZlbnQnKTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRQYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRQYXVzZTogc29ja2V0IHBhdXNlIGV2ZW50Jyk7XG4gICAgdGhpcy5pbnB1dFBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0UmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldFJlc3VtZTogc29ja2V0IHJlc3VtZSBldmVudCcpO1xuICAgIHRoaXMuaW5wdXRQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgIHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygncGF1c2U6IHBhdXNlIHJlcXVlc3RlZCcpO1xuICAgIHRoaXMuc29ja2V0LnBhdXNlKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygncmVzdW1lOiByZXN1bWUgcmVxdWVzdGVkJyk7XG4gICAgdGhpcy5zb2NrZXQucmVzdW1lKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdjbG9zZTogSW5pdGF0aW5nIGNsZWFuIFdlYlNvY2tldCBjbG9zZSBzZXF1ZW5jZS4nKTtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgcmVhc29uQ29kZSkge1xuICAgICAgICAgICAgcmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PUk1BTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkYXRlQ2xvc2VSZWFzb24ocmVhc29uQ29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2UgY29kZSAnICsgcmVhc29uQ29kZSArICcgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3JlYXNvbkNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VUaW1lcigpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZUZyYW1lKHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRU5ESU5HO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbiwgc2tpcENsb3NlRnJhbWUpIHtcbiAgICB0aGlzLl9kZWJ1ZygnZHJvcCcpO1xuICAgIGlmICh0eXBlb2YocmVhc29uQ29kZSkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKGRlc2NyaXB0aW9uKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSWYgbm8gZGVzY3JpcHRpb24gaXMgcHJvdmlkZWQsIHRyeSB0byBsb29rIG9uZSB1cCBiYXNlZCBvbiB0aGVcbiAgICAgICAgLy8gc3BlY2lmaWVkIHJlYXNvbkNvZGUuXG4gICAgICAgIGRlc2NyaXB0aW9uID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9ERVNDUklQVElPTlNbcmVhc29uQ29kZV07XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ0ZvcmNlZnVsbHkgZHJvcHBpbmcgY29ubmVjdGlvbi4gc2tpcENsb3NlRnJhbWU6ICVzLCBjb2RlOiAlZCwgZGVzY3JpcHRpb246ICVzJyxcbiAgICAgICAgc2tpcENsb3NlRnJhbWUsIHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uXG4gICAgKTtcblxuICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcbiAgICBpZiAoIXNraXBDbG9zZUZyYW1lKSB7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlRnJhbWUocmVhc29uQ29kZSwgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuXG4gICAgaWYgKCF0aGlzLmNsb3NlRXZlbnRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFdmVudEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnRW1pdHRpbmcgV2ViU29ja2V0Q29ubmVjdGlvbiBjbG9zZSBldmVudCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5jbG9zZVJlYXNvbkNvZGUsIHRoaXMuY2xvc2VEZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX2RlYnVnKCdEcm9wOiBkZXN0cm95aW5nIHNvY2tldCcpO1xuICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldENsb3NlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0Q2xvc2VUaW1lcicpO1xuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5fZGVidWcoJ1NldHRpbmcgY2xvc2UgdGltZXInKTtcbiAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXJIYW5kbGVyLCB0aGlzLmNsb3NlVGltZW91dCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhckNsb3NlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnY2xlYXJDbG9zZVRpbWVyJyk7XG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnQ2xlYXJpbmcgY2xvc2UgdGltZXInKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUNsb3NlVGltZXInKTtcbiAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdDbG9zZSByZXNwb25zZSBub3QgcmVjZWl2ZWQgZnJvbSBjbGllbnQuICBGb3JjaW5nIHNvY2tldCBlbmQuJyk7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc0ZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICB0aGlzLl9kZWJ1ZygncHJvY2Vzc0ZyYW1lJyk7XG4gICAgdGhpcy5fZGVidWcoJyAtLSBmcmFtZTogJXMnLCBmcmFtZSk7XG4gICAgXG4gICAgLy8gQW55IG5vbi1jb250cm9sIG9wY29kZSBiZXNpZGVzIDB4MDAgKGNvbnRpbnVhdGlvbikgcmVjZWl2ZWQgaW4gdGhlXG4gICAgLy8gbWlkZGxlIG9mIGEgZnJhZ21lbnRlZCBtZXNzYWdlIGlzIGlsbGVnYWwuXG4gICAgaWYgKHRoaXMuZnJhbWVRdWV1ZS5sZW5ndGggIT09IDAgJiYgKGZyYW1lLm9wY29kZSA+IDB4MDAgJiYgZnJhbWUub3Bjb2RlIDwgMHgwOCkpIHtcbiAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICdJbGxlZ2FsIGZyYW1lIG9wY29kZSAweCcgKyBmcmFtZS5vcGNvZGUudG9TdHJpbmcoMTYpICsgJyAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgaW4gbWlkZGxlIG9mIGZyYWdtZW50ZWQgbWVzc2FnZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChmcmFtZS5vcGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAyOiAvLyBXZWJTb2NrZXRGcmFtZS5CSU5BUllfRlJBTUVcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBCaW5hcnkgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLmZpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZSBzaW5nbGUtZnJhbWUgbWVzc2FnZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBFbWl0dGluZyBcXCdtZXNzYWdlXFwnIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiaW5hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5RGF0YTogZnJhbWUuYmluYXJ5UGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMTogLy8gV2ViU29ja2V0RnJhbWUuVEVYVF9GUkFNRVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFRleHQgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLmZpbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGZyYW1lLmJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBVVEYtOCBEYXRhIFJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgc2luZ2xlLWZyYW1lIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gRW1pdHRpbmcgXFwnbWVzc2FnZVxcJyBldmVudCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXRmOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4RGF0YTogZnJhbWUuYmluYXJ5UGF5bG9hZC50b1N0cmluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIGEgZnJhZ21lbnRlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAwOiAvLyBXZWJTb2NrZXRGcmFtZS5DT05USU5VQVRJT05cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBDb250aW51YXRpb24gRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIENvbnRpbnVhdGlvbiBGcmFtZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSArPSBmcmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA+IHRoaXMubWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHLFxuICAgICAgICAgICAgICAgICAgICAgICdNYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBleGNlZWRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5wdXNoKGZyYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIGZyYWdtZW50ZWQgbWVzc2FnZSwgc28gd2UgcHJvY2VzcyB0aGUgd2hvbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBub3cuICBXZSBhbHNvIGhhdmUgdG8gZGVjb2RlIHRoZSB1dGYtOCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IGZyYW1lcyBhZnRlciBjb21iaW5pbmcgYWxsIHRoZSBmcmFnbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlc0NvcGllZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXlsb2FkID0gYnVmZmVyQWxsb2NVbnNhZmUodGhpcy5mcmFnbWVudGF0aW9uU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLmZyYW1lUXVldWVbMF0ub3Bjb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuYmluYXJ5UGF5bG9hZC5jb3B5KGJpbmFyeVBheWxvYWQsIGJ5dGVzQ29waWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzQ29waWVkICs9IGN1cnJlbnRGcmFtZS5iaW5hcnlQYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAyOiAvLyBXZWJTb2NrZXRPcGNvZGUuQklOQVJZX0ZSQU1FXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5RGF0YTogYmluYXJ5UGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAxOiAvLyBXZWJTb2NrZXRPcGNvZGUuVEVYVF9GUkFNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFVURjgoYmluYXJ5UGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBVVEYtOCBEYXRhIFJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXRmOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhEYXRhOiBiaW5hcnlQYXlsb2FkLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgZmlyc3Qgb3Bjb2RlIGluIGZyYWdtZW50YXRpb24gc2VxdWVuY2U6IDB4JyArIG9wY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vIFdlYlNvY2tldEZyYW1lLlBJTkdcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBQaW5nIEZyYW1lJyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9waW5nTGlzdGVuZXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsb2dpYyB0byBlbWl0IHRoZSBwaW5nIGZyYW1lOiB0aGlzIGlzIG9ubHkgZG9uZSB3aGVuIGEgbGlzdGVuZXIgaXMga25vd24gdG8gZXhpc3RcbiAgICAgICAgICAgICAgICAvLyBFeHBvc2UgYSBmdW5jdGlvbiBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBwaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7IFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwaW5nJywgY2FuY2VsLCBmcmFtZS5iaW5hcnlQYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc2VuZCBhIHBvbmcgaWYgdGhlIGNsaWVudCBkaWQgbm90IGluZGljYXRlIHRoYXQgaGUgd291bGQgbGlrZSB0byBjYW5jZWxcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbmcoZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb25nKGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDBBOiAvLyBXZWJTb2NrZXRGcmFtZS5QT05HXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gUG9uZyBGcmFtZScpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb25nJywgZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA4OiAvLyBXZWJTb2NrZXRGcmFtZS5DT05ORUNUSU9OX0NMT1NFXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQ2xvc2UgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gR290IHJlc3BvbnNlIHRvIG91ciByZXF1ZXN0IHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENsb3NlIGlzIGNvbXBsZXRlLCBzbyB3ZSBqdXN0IGhhbmcgdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gR290IGNsb3NlIHJlc3BvbnNlIGZyb20gcGVlci4gIENvbXBsZXRpbmcgY2xvc2luZyBoYW5kc2hha2UuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIENsb3NpbmcgaGFuZHNoYWtlIGluaXRpYXRlZCBieSBwZWVyLicpO1xuICAgICAgICAgICAgLy8gR290IHJlcXVlc3QgZnJvbSBvdGhlciBwYXJ0eSB0byBjbG9zZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gU2VuZCBiYWNrIGFja25vd2xlZGdlbWVudCBhbmQgdGhlbiBoYW5nIHVwLlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFO1xuICAgICAgICAgICAgdmFyIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGU7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2xvc2UgcmVhc29uIHByb3ZpZGVkIGlzIGxlZ2FsIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gdGhlIHByb3RvY29sIHNwZWMuICBQcm92aWRpbmcgbm8gY2xvc2Ugc3RhdHVzIGlzIGxlZ2FsLlxuICAgICAgICAgICAgLy8gV2ViU29ja2V0RnJhbWUgc2V0cyBjbG9zZVN0YXR1cyB0byAtMSBieSBkZWZhdWx0LCBzbyBpZiBpdFxuICAgICAgICAgICAgLy8gaXMgc3RpbGwgLTEsIHRoZW4gbm8gc3RhdHVzIHdhcyBwcm92aWRlZC5cbiAgICAgICAgICAgIGlmIChmcmFtZS5pbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gMTAwNTsgLy8gMTAwNSA9IE5vIHJlYXNvbiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFtZS5jbG9zZVN0YXR1cyA9PT0gLTEgfHwgdmFsaWRhdGVDbG9zZVJlYXNvbihmcmFtZS5jbG9zZVN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IGZyYW1lLmNsb3NlU3RhdHVzO1xuICAgICAgICAgICAgICAgIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IGZyYW1lLmNsb3NlU3RhdHVzO1xuICAgICAgICAgICAgICAgIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB0ZXh0dWFsIGRlc2NyaXB0aW9uIGluIHRoZSBjbG9zZSBmcmFtZSwgZXh0cmFjdCBpdC5cbiAgICAgICAgICAgIGlmIChmcmFtZS5iaW5hcnlQYXlsb2FkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGZyYW1lLmJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IGZyYW1lLmJpbmFyeVBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3RoaXMuY2xvc2VSZWFzb25Db2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICAgICctLS0tLS0gUmVtb3RlIHBlZXIgJXMgLSBjb2RlOiAlZCAtICVzIC0gY2xvc2UgZnJhbWUgcGF5bG9hZCBsZW5ndGg6ICVkJyxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MsIHRoaXMuY2xvc2VSZWFzb25Db2RlLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiwgZnJhbWUubGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0tLSByZXNwb25kaW5nIHRvIHJlbW90ZSBwZWVyXFwncyBjbG9zZSByZXF1ZXN0LicpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VGcmFtZShyZXNwb25kQ2xvc2VSZWFzb25Db2RlLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBVbnJlY29nbml6ZWQgT3Bjb2RlICVkJywgZnJhbWUub3Bjb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgJ1VucmVjb2duaXplZCBPcGNvZGU6IDB4JyArIGZyYW1lLm9wY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmQnKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRoaXMuc2VuZEJ5dGVzKGRhdGEsIGNiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mKGRhdGFbJ3RvU3RyaW5nJ10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuc2VuZFVURihkYXRhLCBjYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgcHJvdmlkZWQgbXVzdCBlaXRoZXIgYmUgYSBOb2RlIEJ1ZmZlciBvciBpbXBsZW1lbnQgdG9TdHJpbmcoKScpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRVVEYgPSBmdW5jdGlvbihkYXRhLCBjYikge1xuICAgIGRhdGEgPSBidWZmZXJGcm9tU3RyaW5nKGRhdGEudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZFVURjogJWQgYnl0ZXMnLCBkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwMTsgLy8gV2ViU29ja2V0T3Bjb2RlLlRFWFRfRlJBTUVcbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB0aGlzLmZyYWdtZW50QW5kU2VuZChmcmFtZSwgY2IpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZEJ5dGVzID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZEJ5dGVzJyk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgTm9kZSBCdWZmZXIgb2JqZWN0IHRvIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRCeXRlcygpJyk7XG4gICAgfVxuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDI7IC8vIFdlYlNvY2tldE9wY29kZS5CSU5BUllfRlJBTUVcbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB0aGlzLmZyYWdtZW50QW5kU2VuZChmcmFtZSwgY2IpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLl9kZWJ1ZygncGluZycpO1xuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDk7IC8vIFdlYlNvY2tldE9wY29kZS5QSU5HXG4gICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGJ1ZmZlckZyb21TdHJpbmcoZGF0YS50b1N0cmluZygpLCAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ1dlYlNvY2tldDogRGF0YSBmb3IgcGluZyBpcyBsb25nZXIgdGhhbiAxMjUgYnl0ZXMuICBUcnVuY2F0aW5nLicpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwxMjQpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBkYXRhO1xuICAgIH1cbiAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSk7XG59O1xuXG4vLyBQb25nIGZyYW1lcyBoYXZlIHRvIGVjaG8gYmFjayB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgcG9ydGlvbiBvZiB0aGVcbi8vIHBpbmcgZnJhbWUgZXhhY3RseSwgYnl0ZSBmb3IgYnl0ZS5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBvbmcgPSBmdW5jdGlvbihiaW5hcnlQYXlsb2FkKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BvbmcnKTtcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDBBOyAvLyBXZWJTb2NrZXRPcGNvZGUuUE9OR1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYmluYXJ5UGF5bG9hZCkgJiYgYmluYXJ5UGF5bG9hZC5sZW5ndGggPiAxMjUpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ1dlYlNvY2tldDogRGF0YSBmb3IgcG9uZyBpcyBsb25nZXIgdGhhbiAxMjUgYnl0ZXMuICBUcnVuY2F0aW5nLicpO1xuICAgICAgICBiaW5hcnlQYXlsb2FkID0gYmluYXJ5UGF5bG9hZC5zbGljZSgwLDEyNCk7XG4gICAgfVxuICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBiaW5hcnlQYXlsb2FkO1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuZnJhZ21lbnRBbmRTZW5kID0gZnVuY3Rpb24oZnJhbWUsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ2ZyYWdtZW50QW5kU2VuZCcpO1xuICAgIGlmIChmcmFtZS5vcGNvZGUgPiAweDA3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBmcmFnbWVudCBjb250cm9sIGZyYW1lcy4nKTtcbiAgICB9XG5cbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5jb25maWcuZnJhZ21lbnRhdGlvblRocmVzaG9sZDtcbiAgICB2YXIgbGVuZ3RoID0gZnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG5cbiAgICAvLyBTZW5kIGltbWVkaWF0ZWx5IGlmIGZyYWdtZW50YXRpb24gaXMgZGlzYWJsZWQgb3IgdGhlIG1lc3NhZ2UgaXMgbm90XG4gICAgLy8gbGFyZ2VyIHRoYW4gdGhlIGZyYWdtZW50YXRpb24gdGhyZXNob2xkLlxuICAgIGlmICghdGhpcy5jb25maWcuZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIHx8IChmcmFtZS5iaW5hcnlQYXlsb2FkICYmIGxlbmd0aCA8PSB0aHJlc2hvbGQpKSB7XG4gICAgICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG51bUZyYWdtZW50cyA9IE1hdGguY2VpbChsZW5ndGggLyB0aHJlc2hvbGQpO1xuICAgIHZhciBzZW50RnJhZ21lbnRzID0gMDtcbiAgICB2YXIgc2VudENhbGxiYWNrID0gZnVuY3Rpb24gZnJhZ21lbnRTZW50Q2FsbGJhY2soZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzIG9ubHkgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBjYiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKytzZW50RnJhZ21lbnRzO1xuICAgICAgICBpZiAoKHNlbnRGcmFnbWVudHMgPT09IG51bUZyYWdtZW50cykgJiYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGk9MTsgaSA8PSBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjb250aW51YXRpb24gb3Bjb2RlIGV4Y2VwdCBmb3IgZmlyc3QgZnJhbWUuXG4gICAgICAgIGN1cnJlbnRGcmFtZS5vcGNvZGUgPSAoaSA9PT0gMSkgPyBmcmFtZS5vcGNvZGUgOiAweDAwO1xuICAgICAgICBcbiAgICAgICAgLy8gZmluIHNldCBvbiBsYXN0IGZyYW1lIG9ubHlcbiAgICAgICAgY3VycmVudEZyYW1lLmZpbiA9IChpID09PSBudW1GcmFnbWVudHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGxpa2VseSB0byBiZSBzaG9ydGVyIG9uIHRoZSBsYXN0IGZyYWdtZW50XG4gICAgICAgIHZhciBjdXJyZW50TGVuZ3RoID0gKGkgPT09IG51bUZyYWdtZW50cykgPyBsZW5ndGggLSAodGhyZXNob2xkICogKGktMSkpIDogdGhyZXNob2xkO1xuICAgICAgICB2YXIgc2xpY2VTdGFydCA9IHRocmVzaG9sZCAqIChpLTEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2xpY2UgdGhlIHJpZ2h0IHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHBheWxvYWRcbiAgICAgICAgY3VycmVudEZyYW1lLmJpbmFyeVBheWxvYWQgPSBmcmFtZS5iaW5hcnlQYXlsb2FkLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlU3RhcnQgKyBjdXJyZW50TGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VuZEZyYW1lKGN1cnJlbnRGcmFtZSwgc2VudENhbGxiYWNrKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQ2xvc2VGcmFtZSA9IGZ1bmN0aW9uKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uLCBjYikge1xuICAgIGlmICh0eXBlb2YocmVhc29uQ29kZSkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX2RlYnVnKCdzZW5kQ2xvc2VGcmFtZSBzdGF0ZTogJXMsIHJlYXNvbkNvZGU6ICVkLCBkZXNjcmlwdGlvbjogJXMnLCB0aGlzLnN0YXRlLCByZWFzb25Db2RlLCBkZXNjcmlwdGlvbik7XG4gICAgXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX09QRU4gJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UpIHsgcmV0dXJuOyB9XG4gICAgXG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDA4OyAvLyBXZWJTb2NrZXRPcGNvZGUuQ09OTkVDVElPTl9DTE9TRVxuICAgIGZyYW1lLmNsb3NlU3RhdHVzID0gcmVhc29uQ29kZTtcbiAgICBpZiAodHlwZW9mKGRlc2NyaXB0aW9uKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckZyb21TdHJpbmcoZGVzY3JpcHRpb24sICd1dGY4Jyk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lLCBjYik7XG4gICAgdGhpcy5zb2NrZXQuZW5kKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZEZyYW1lJyk7XG4gICAgZnJhbWUubWFzayA9IHRoaXMubWFza091dGdvaW5nUGFja2V0cztcbiAgICB2YXIgZmx1c2hlZCA9IHRoaXMuc29ja2V0LndyaXRlKGZyYW1lLnRvQnVmZmVyKCksIGNiKTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSAhZmx1c2hlZDtcbiAgICByZXR1cm4gZmx1c2hlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Q29ubmVjdGlvbjtcblxuXG5cbmZ1bmN0aW9uIGluc3RydW1lbnRTb2NrZXRGb3JEZWJ1Z2dpbmcoY29ubmVjdGlvbiwgc29ja2V0KSB7XG4gICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgaWYgKCFjb25uZWN0aW9uLl9kZWJ1Zy5lbmFibGVkKSB7IHJldHVybjsgfVxuICAgIFxuICAgIHZhciBvcmlnaW5hbFNvY2tldEVtaXQgPSBzb2NrZXQuZW1pdDtcbiAgICBzb2NrZXQuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IEV2ZW50ICBcXCclc1xcJycsIGV2ZW50KTtcbiAgICAgICAgb3JpZ2luYWxTb2NrZXRFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBcbiAgICBmb3IgKHZhciBrZXkgaW4gc29ja2V0KSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2Yoc29ja2V0W2tleV0pKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChbJ2VtaXQnXS5pbmRleE9mKGtleSkgIT09IC0xKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHNvY2tldFtrZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgIHNvY2tldFtrZXldID0gZnVuY3Rpb24gcHJveHlNZXRob2RfX0V2ZW50RW1pdHRlcl9fT24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IG1ldGhvZCBjYWxsZWQ6ICAlcyAoJXMpJywga2V5LCBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldFtrZXldID0gZnVuY3Rpb24gcHJveHlNZXRob2QoKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fZGVidWcoJ3x8fCBTb2NrZXQgbWV0aG9kIGNhbGxlZDogICVzJywga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGtleSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwidXRpbHMiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRGcmFtZSIsIkJ1ZmZlckxpc3QiLCJpc1ZhbGlkVVRGOCIsImJ1ZmZlckFsbG9jVW5zYWZlIiwiYnVmZmVyRnJvbVN0cmluZyIsIlNUQVRFX09QRU4iLCJTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSIsIlNUQVRFX0VORElORyIsIlNUQVRFX0NMT1NFRCIsInNldEltbWVkaWF0ZUltcGwiLCJnbG9iYWwiLCJzZXRJbW1lZGlhdGUiLCJiaW5kIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiaWRDb3VudGVyIiwiV2ViU29ja2V0Q29ubmVjdGlvbiIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJwcm90b2NvbCIsIm1hc2tPdXRnb2luZ1BhY2tldHMiLCJjb25maWciLCJfZGVidWciLCJCdWZmZXJpbmdMb2dnZXIiLCJlbmFibGVkIiwiaW5zdHJ1bWVudFNvY2tldEZvckRlYnVnZ2luZyIsImNhbGwiLCJfcGluZ0xpc3RlbmVyQ291bnQiLCJvbiIsImV2IiwicmVtb3RlQWRkcmVzcyIsImNsb3NlUmVhc29uQ29kZSIsImNsb3NlRGVzY3JpcHRpb24iLCJjbG9zZUV2ZW50RW1pdHRlZCIsIm1hc2tCeXRlcyIsImZyYW1lSGVhZGVyIiwiYnVmZmVyTGlzdCIsImN1cnJlbnRGcmFtZSIsImZyYWdtZW50YXRpb25TaXplIiwiZnJhbWVRdWV1ZSIsImNvbm5lY3RlZCIsInN0YXRlIiwid2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UiLCJyZWNlaXZlZEVuZCIsImNsb3NlVGltZW91dCIsImFzc2VtYmxlRnJhZ21lbnRzIiwibWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSIsIm91dHB1dEJ1ZmZlckZ1bGwiLCJpbnB1dFBhdXNlZCIsInJlY2VpdmVkRGF0YUhhbmRsZXIiLCJwcm9jZXNzUmVjZWl2ZWREYXRhIiwiX2Nsb3NlVGltZXJIYW5kbGVyIiwiaGFuZGxlQ2xvc2VUaW1lciIsInNldE5vRGVsYXkiLCJkaXNhYmxlTmFnbGVBbGdvcml0aG0iLCJzZXRUaW1lb3V0Iiwia2VlcGFsaXZlIiwidXNlTmF0aXZlS2VlcGFsaXZlIiwia2VlcGFsaXZlSW50ZXJ2YWwiLCJFcnJvciIsIl9rZWVwYWxpdmVUaW1lckhhbmRsZXIiLCJoYW5kbGVLZWVwYWxpdmVUaW1lciIsInNldEtlZXBhbGl2ZVRpbWVyIiwiZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQiLCJrZWVwYWxpdmVHcmFjZVBlcmlvZCIsIl9ncmFjZVBlcmlvZFRpbWVySGFuZGxlciIsImhhbmRsZUdyYWNlUGVyaW9kVGltZXIiLCJzZXRLZWVwQWxpdmUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJDTE9TRV9SRUFTT05fTk9STUFMIiwiQ0xPU0VfUkVBU09OX0dPSU5HX0FXQVkiLCJDTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IiLCJDTE9TRV9SRUFTT05fVU5QUk9DRVNTQUJMRV9JTlBVVCIsIkNMT1NFX1JFQVNPTl9SRVNFUlZFRCIsIkNMT1NFX1JFQVNPTl9OT1RfUFJPVklERUQiLCJDTE9TRV9SRUFTT05fQUJOT1JNQUwiLCJDTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBIiwiQ0xPU0VfUkVBU09OX1BPTElDWV9WSU9MQVRJT04iLCJDTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHIiwiQ0xPU0VfUkVBU09OX0VYVEVOU0lPTl9SRVFVSVJFRCIsIkNMT1NFX1JFQVNPTl9JTlRFUk5BTF9TRVJWRVJfRVJST1IiLCJDTE9TRV9SRUFTT05fVExTX0hBTkRTSEFLRV9GQUlMRUQiLCJDTE9TRV9ERVNDUklQVElPTlMiLCJ2YWxpZGF0ZUNsb3NlUmVhc29uIiwiY29kZSIsImluZGV4T2YiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsIl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyIsImhhbmRsZVNvY2tldEVycm9yIiwiaGFuZGxlU29ja2V0RW5kIiwiaGFuZGxlU29ja2V0Q2xvc2UiLCJoYW5kbGVTb2NrZXREcmFpbiIsImhhbmRsZVNvY2tldFBhdXNlIiwiaGFuZGxlU29ja2V0UmVzdW1lIiwiaGFuZGxlU29ja2V0RGF0YSIsImNsZWFyS2VlcGFsaXZlVGltZXIiLCJjbGVhckdyYWNlUGVyaW9kVGltZXIiLCJfa2VlcGFsaXZlVGltZW91dElEIiwiY2xlYXJUaW1lb3V0IiwicGluZyIsInNldEdyYWNlUGVyaW9kVGltZXIiLCJfZ3JhY2VQZXJpb2RUaW1lb3V0SUQiLCJkcm9wIiwiZGF0YSIsIndyaXRlIiwiZnJhbWUiLCJhZGREYXRhIiwic2VsZiIsInByb3RvY29sRXJyb3IiLCJkcm9wUmVhc29uIiwiZnJhbWVUb29MYXJnZSIsInJzdjEiLCJyc3YyIiwicnN2MyIsImVtaXQiLCJwcm9jZXNzRnJhbWUiLCJsZW5ndGgiLCJlcnJvciIsInN5c2NhbGwiLCJldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50IiwiZGVzdHJveSIsInByaW50T3V0cHV0IiwiZW5kIiwiaGFkRXJyb3IiLCJzb2NrZXRIYWRFcnJvciIsImNsZWFyQ2xvc2VUaW1lciIsInBhdXNlIiwicmVzdW1lIiwiY2xvc2UiLCJyZWFzb25Db2RlIiwiZGVzY3JpcHRpb24iLCJzZXRDbG9zZVRpbWVyIiwic2VuZENsb3NlRnJhbWUiLCJza2lwQ2xvc2VGcmFtZSIsImNsb3NlVGltZXIiLCJvcGNvZGUiLCJ0b1N0cmluZyIsImZpbiIsInR5cGUiLCJiaW5hcnlEYXRhIiwiYmluYXJ5UGF5bG9hZCIsInB1c2giLCJ1dGY4RGF0YSIsImJ5dGVzQ29waWVkIiwiZm9yRWFjaCIsImNvcHkiLCJjYW5jZWxsZWQiLCJjYW5jZWwiLCJwb25nIiwicmVzcG9uZENsb3NlUmVhc29uQ29kZSIsImludmFsaWRDbG9zZUZyYW1lTGVuZ3RoIiwiY2xvc2VTdGF0dXMiLCJzZW5kIiwiY2IiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInNlbmRCeXRlcyIsInNlbmRVVEYiLCJmcmFnbWVudEFuZFNlbmQiLCJzbGljZSIsInNlbmRGcmFtZSIsInRocmVzaG9sZCIsImZyYWdtZW50YXRpb25UaHJlc2hvbGQiLCJmcmFnbWVudE91dGdvaW5nTWVzc2FnZXMiLCJudW1GcmFnbWVudHMiLCJNYXRoIiwiY2VpbCIsInNlbnRGcmFnbWVudHMiLCJzZW50Q2FsbGJhY2siLCJmcmFnbWVudFNlbnRDYWxsYmFjayIsImVyciIsImkiLCJjdXJyZW50TGVuZ3RoIiwic2xpY2VTdGFydCIsIm1hc2siLCJmbHVzaGVkIiwidG9CdWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29ubmVjdGlvbiIsIm9yaWdpbmFsU29ja2V0RW1pdCIsImV2ZW50IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJrZXkiLCJvcmlnaW5hbCIsInByb3h5TWV0aG9kX19FdmVudEVtaXR0ZXJfX09uIiwicHJveHlNZXRob2QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketConnection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"(rsc)/./node_modules/websocket/vendor/FastBufferList.js\");\nvar isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(rsc)/./node_modules/utf-8-validate/index.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = \"open\";\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = \"peer_requested_close\";\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = \"ending\";\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = \"closed\";\nvar setImmediateImpl = \"setImmediate\" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);\nvar idCounter = 0;\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger(\"websocket:connection\", ++idCounter);\n    this._debug(\"constructor\");\n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._pingListenerCount = 0;\n    this.on(\"newListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount++;\n        }\n    }).on(\"removeListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount--;\n        }\n    });\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof this.config.keepaliveInterval !== \"number\") {\n            throw new Error(\"keepaliveInterval must be specified and numeric \" + \"if keepalive is true.\");\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof this.config.keepaliveGracePeriod !== \"number\") {\n                throw new Error(\"keepaliveGracePeriod  must be specified and \" + \"numeric if dropConnectionOnKeepaliveTimeout \" + \"is true.\");\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    } else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!(\"setKeepAlive\" in this.socket)) {\n            throw new Error(\"Unable to use native keepalive: unsupported by \" + \"this version of Node.\");\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners(\"error\");\n}\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: \"Normal connection closure\",\n    1001: \"Remote peer is going away\",\n    1002: \"Protocol error\",\n    1003: \"Unprocessable input\",\n    1004: \"Reserved\",\n    1005: \"Reason not provided\",\n    1006: \"Abnormal closure, no further detail available\",\n    1007: \"Invalid data received\",\n    1008: \"Policy violation\",\n    1009: \"Message too big\",\n    1010: \"Extension requested by client is required\",\n    1011: \"Internal Server Error\",\n    1015: \"TLS Handshake Failed\"\n};\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [\n            1000,\n            1001,\n            1002,\n            1003,\n            1007,\n            1008,\n            1009,\n            1010,\n            1011,\n            1012,\n            1013,\n            1014,\n            1015\n        ].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\nutil.inherits(WebSocketConnection, EventEmitter);\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on(\"error\", this.handleSocketError.bind(this));\n    this.socket.on(\"end\", this.handleSocketEnd.bind(this));\n    this.socket.on(\"close\", this.handleSocketClose.bind(this));\n    this.socket.on(\"drain\", this.handleSocketDrain.bind(this));\n    this.socket.on(\"pause\", this.handleSocketPause.bind(this));\n    this.socket.on(\"resume\", this.handleSocketResume.bind(this));\n    this.socket.on(\"data\", this.handleSocketData.bind(this));\n};\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug(\"setKeepaliveTimer\");\n    if (!this.config.keepalive || this.config.useNativeKeepalive) {\n        return;\n    }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug(\"handleKeepaliveTimer\");\n    this._keepaliveTimeoutID = null;\n    this.ping();\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    } else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug(\"setGracePeriodTimer\");\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug(\"handleGracePeriodTimer\");\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, \"Peer not responding.\", true);\n};\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug(\"handleSocketData\");\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug(\"processReceivedData\");\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) {\n        return;\n    }\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) {\n        return;\n    }\n    var frame = this.currentFrame;\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) {\n        this._debug(\"-- insufficient data for frame\");\n        return;\n    }\n    var self = this;\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug(\"-- protocol error\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    } else if (frame.frameTooLarge) {\n        this._debug(\"-- frame too large\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug(\"-- illegal rsv flag\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unsupported usage of rsv bits without negotiated extension.\");\n        });\n        return;\n    }\n    if (!this.assembleFragments) {\n        this._debug(\"-- emitting frame\");\n        process.nextTick(function() {\n            self.emit(\"frame\", frame);\n        });\n    }\n    process.nextTick(function() {\n        self.processFrame(frame);\n    });\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug(\"handleSocketError: %j\", error);\n    if (this.state === STATE_CLOSED) {\n        // See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug(\"  --- Socket 'error' after 'close'\");\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = \"Socket Error: \" + error.syscall + \" \" + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, \"error\") > 0) {\n        this.emit(\"error\", error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug(\"handleSocketEnd: received socket end.  state = %s\", this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug(\"  --- Socket 'end' after 'close'\");\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {\n        this._debug(\"  --- UNEXPECTED socket end.\");\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug(\"handleSocketClose: received socket close\");\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = \"Connection dropped by remote peer.\";\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"-- Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n};\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug(\"handleSocketDrain: socket drain event\");\n    this.outputBufferFull = false;\n    this.emit(\"drain\");\n};\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug(\"handleSocketPause: socket pause event\");\n    this.inputPaused = true;\n    this.emit(\"pause\");\n};\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug(\"handleSocketResume: socket resume event\");\n    this.inputPaused = false;\n    this.emit(\"resume\");\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.pause = function() {\n    this._debug(\"pause: pause requested\");\n    this.socket.pause();\n};\nWebSocketConnection.prototype.resume = function() {\n    this._debug(\"resume: resume requested\");\n    this.socket.resume();\n};\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug(\"close: Initating clean WebSocket close sequence.\");\n        if (\"number\" !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error(\"Close code \" + reasonCode + \" is not valid.\");\n        }\n        if (\"string\" !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug(\"drop\");\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n    if (typeof description !== \"string\") {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n    this._debug(\"Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s\", skipCloseFrame, reasonCode, description);\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n    this._debug(\"Drop: destroying socket\");\n    this.socket.destroy();\n};\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug(\"setCloseTimer\");\n    this.clearCloseTimer();\n    this._debug(\"Setting close timer\");\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug(\"clearCloseTimer\");\n    if (this.closeTimer) {\n        this._debug(\"Clearing close timer\");\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug(\"handleCloseTimer\");\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug(\"Close response not received from client.  Forcing socket end.\");\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug(\"processFrame\");\n    this._debug(\" -- frame: %s\", frame);\n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && frame.opcode > 0x00 && frame.opcode < 0x08) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Illegal frame opcode 0x\" + frame.opcode.toString(16) + \" \" + \"received in middle of fragmented message.\");\n        return;\n    }\n    switch(frame.opcode){\n        case 0x02:\n            this._debug(\"-- Binary Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"binary\",\n                        binaryData: frame.binaryPayload\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01:\n            this._debug(\"-- Text Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"utf8\",\n                        utf8Data: frame.binaryPayload.toString(\"utf8\")\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00:\n            this._debug(\"-- Continuation Frame\");\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected Continuation Frame\");\n                    return;\n                }\n                this.fragmentationSize += frame.length;\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, \"Maximum message size exceeded.\");\n                    return;\n                }\n                this.frameQueue.push(frame);\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function(currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n                    switch(opcode){\n                        case 0x02:\n                            this.emit(\"message\", {\n                                type: \"binary\",\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01:\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                                return;\n                            }\n                            this.emit(\"message\", {\n                                type: \"utf8\",\n                                utf8Data: binaryPayload.toString(\"utf8\")\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected first opcode in fragmentation sequence: 0x\" + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09:\n            this._debug(\"-- Ping Frame\");\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.emit(\"ping\", cancel, frame.binaryPayload);\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            } else {\n                this.pong(frame.binaryPayload);\n            }\n            break;\n        case 0x0A:\n            this._debug(\"-- Pong Frame\");\n            this.emit(\"pong\", frame.binaryPayload);\n            break;\n        case 0x08:\n            this._debug(\"-- Close Frame\");\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug(\"---- Got close response from peer.  Completing closing handshake.\");\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            this._debug(\"---- Closing handshake initiated by peer.\");\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            } else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString(\"utf8\");\n            } else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\"------ Remote peer %s - code: %d - %s - close frame payload length: %d\", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);\n            this._debug(\"------ responding to remote peer's close request.\");\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug(\"-- Unrecognized Opcode %d\", frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unrecognized Opcode: 0x\" + frame.opcode.toString(16));\n            break;\n    }\n};\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug(\"send\");\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    } else if (typeof data[\"toString\"] === \"function\") {\n        this.sendUTF(data, cb);\n    } else {\n        throw new Error(\"Data provided must either be a Node Buffer or implement toString()\");\n    }\n};\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), \"utf8\");\n    this._debug(\"sendUTF: %d bytes\", data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug(\"sendBytes\");\n    if (!Buffer.isBuffer(data)) {\n        throw new Error(\"You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()\");\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug(\"ping\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), \"utf8\");\n        }\n        if (data.length > 125) {\n            this._debug(\"WebSocket: Data for ping is longer than 125 bytes.  Truncating.\");\n            data = data.slice(0, 124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug(\"pong\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug(\"WebSocket: Data for pong is longer than 125 bytes.  Truncating.\");\n        binaryPayload = binaryPayload.slice(0, 124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug(\"fragmentAndSend\");\n    if (frame.opcode > 0x07) {\n        throw new Error(\"You cannot fragment control frames.\");\n    }\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === \"function\") {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if (sentFragments === numFragments && typeof cb === \"function\") {\n            cb();\n        }\n    };\n    for(var i = 1; i <= numFragments; i++){\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        // continuation opcode except for first frame.\n        currentFrame.opcode = i === 1 ? frame.opcode : 0x00;\n        // fin set on last frame only\n        currentFrame.fin = i === numFragments;\n        // length is likely to be shorter on the last fragment\n        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;\n        var sliceStart = threshold * (i - 1);\n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    this._debug(\"sendCloseFrame state: %s, reasonCode: %d, description: %s\", this.state, reasonCode, description);\n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {\n        return;\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof description === \"string\") {\n        frame.binaryPayload = bufferFromString(description, \"utf8\");\n    }\n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug(\"sendFrame\");\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\nmodule.exports = WebSocketConnection;\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */ if (!connection._debug.enabled) {\n        return;\n    }\n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug(\"||| Socket Event  '%s'\", event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    for(var key in socket){\n        if (\"function\" !== typeof socket[key]) {\n            continue;\n        }\n        if ([\n            \"emit\"\n        ].indexOf(key) !== -1) {\n            continue;\n        }\n        (function(key) {\n            var original = socket[key];\n            if (key === \"on\") {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug(\"||| Socket method called:  %s (%s)\", key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug(\"||| Socket method called:  %s\", key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUksYUFBYUosbUJBQU9BLENBQUM7QUFDekIsSUFBSUssY0FBY0wsbUJBQU9BLENBQUM7QUFDMUIsSUFBSU0sb0JBQW9CTCxNQUFNSyxpQkFBaUI7QUFDL0MsSUFBSUMsbUJBQW1CTixNQUFNTSxnQkFBZ0I7QUFFN0MsMERBQTBEO0FBQzFELE1BQU1DLGFBQWE7QUFDbkIsOENBQThDO0FBQzlDLE1BQU1DLDZCQUE2QjtBQUNuQyxpRUFBaUU7QUFDakUsTUFBTUMsZUFBZTtBQUNyQix3RUFBd0U7QUFDeEUsTUFBTUMsZUFBZTtBQUVyQixJQUFJQyxtQkFBbUIsa0JBQW1CQyxTQUNkQSxPQUFPQyxZQUFZLENBQUNDLElBQUksQ0FBQ0YsVUFDekJHLFFBQVFDLFFBQVEsQ0FBQ0YsSUFBSSxDQUFDQztBQUVsRCxJQUFJRSxZQUFZO0FBRWhCLFNBQVNDLG9CQUFvQkMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsbUJBQW1CLEVBQUVDLE1BQU07SUFDbEYsSUFBSSxDQUFDQyxNQUFNLEdBQUd4QixNQUFNeUIsZUFBZSxDQUFDLHdCQUF3QixFQUFFUjtJQUM5RCxJQUFJLENBQUNPLE1BQU0sQ0FBQztJQUVaLElBQUksSUFBSSxDQUFDQSxNQUFNLENBQUNFLE9BQU8sRUFBRTtRQUNyQkMsNkJBQTZCLElBQUksRUFBRVI7SUFDdkM7SUFFQSx5QkFBeUI7SUFDekJsQixhQUFhMkIsSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztJQUMx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LE9BQU9FLFNBQVNILEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUNoQztnQkFDQTtZQUNKO1lBQ0F2SyxNQUFNLENBQUN3SyxJQUFJLEdBQUcsU0FBU0c7Z0JBQ25CUixXQUFXOUosTUFBTSxDQUFDLGlDQUFpQ21LO2dCQUNuRCxPQUFPQyxTQUFTSCxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNoQztRQUNKLEdBQUdDO0lBQ1A7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENvbm5lY3Rpb24uanM/NGU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRGcmFtZSA9IHJlcXVpcmUoJy4vV2ViU29ja2V0RnJhbWUnKTtcbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi4vdmVuZG9yL0Zhc3RCdWZmZXJMaXN0Jyk7XG52YXIgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xudmFyIGJ1ZmZlckFsbG9jVW5zYWZlID0gdXRpbHMuYnVmZmVyQWxsb2NVbnNhZmU7XG52YXIgYnVmZmVyRnJvbVN0cmluZyA9IHV0aWxzLmJ1ZmZlckZyb21TdHJpbmc7XG5cbi8vIENvbm5lY3RlZCwgZnVsbHktb3BlbiwgcmVhZHkgdG8gc2VuZCBhbmQgcmVjZWl2ZSBmcmFtZXNcbmNvbnN0IFNUQVRFX09QRU4gPSAnb3Blbic7XG4vLyBSZWNlaXZlZCBhIGNsb3NlIGZyYW1lIGZyb20gdGhlIHJlbW90ZSBwZWVyXG5jb25zdCBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSA9ICdwZWVyX3JlcXVlc3RlZF9jbG9zZSc7XG4vLyBTZW50IGNsb3NlIGZyYW1lIHRvIHJlbW90ZSBwZWVyLiAgTm8gZnVydGhlciBkYXRhIGNhbiBiZSBzZW50LlxuY29uc3QgU1RBVEVfRU5ESU5HID0gJ2VuZGluZyc7XG4vLyBDb25uZWN0aW9uIGlzIGZ1bGx5IGNsb3NlZC4gIE5vIGZ1cnRoZXIgZGF0YSBjYW4gYmUgc2VudCBvciByZWNlaXZlZC5cbmNvbnN0IFNUQVRFX0NMT1NFRCA9ICdjbG9zZWQnO1xuXG52YXIgc2V0SW1tZWRpYXRlSW1wbCA9ICgnc2V0SW1tZWRpYXRlJyBpbiBnbG9iYWwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwuc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljay5iaW5kKHByb2Nlc3MpO1xuXG52YXIgaWRDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gV2ViU29ja2V0Q29ubmVjdGlvbihzb2NrZXQsIGV4dGVuc2lvbnMsIHByb3RvY29sLCBtYXNrT3V0Z29pbmdQYWNrZXRzLCBjb25maWcpIHtcbiAgICB0aGlzLl9kZWJ1ZyA9IHV0aWxzLkJ1ZmZlcmluZ0xvZ2dlcignd2Vic29ja2V0OmNvbm5lY3Rpb24nLCArK2lkQ291bnRlcik7XG4gICAgdGhpcy5fZGVidWcoJ2NvbnN0cnVjdG9yJyk7XG4gICAgXG4gICAgaWYgKHRoaXMuX2RlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgaW5zdHJ1bWVudFNvY2tldEZvckRlYnVnZ2luZyh0aGlzLCBzb2NrZXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudCA9IDA7XG4gICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYgPT09ICdwaW5nJyl7XG4gICAgICAgICAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9KS5vbigncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYgPT09ICdwaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fcGluZ0xpc3RlbmVyQ291bnQtLTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSAtMTtcbiAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBudWxsO1xuICAgIHRoaXMuY2xvc2VFdmVudEVtaXR0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFdlIGhhdmUgdG8gbWFzayBvdXRnb2luZyBwYWNrZXRzIGlmIHdlJ3JlIGFjdGluZyBhcyBhIFdlYlNvY2tldCBjbGllbnQuXG4gICAgdGhpcy5tYXNrT3V0Z29pbmdQYWNrZXRzID0gbWFza091dGdvaW5nUGFja2V0cztcblxuICAgIC8vIFdlIHJlLXVzZSB0aGUgc2FtZSBidWZmZXJzIGZvciB0aGUgbWFzayBhbmQgZnJhbWUgaGVhZGVyIGZvciBhbGwgZnJhbWVzXG4gICAgLy8gcmVjZWl2ZWQgb24gZWFjaCBjb25uZWN0aW9uIHRvIGF2b2lkIGEgc21hbGwgbWVtb3J5IGFsbG9jYXRpb24gZm9yIGVhY2hcbiAgICAvLyBmcmFtZS5cbiAgICB0aGlzLm1hc2tCeXRlcyA9IGJ1ZmZlckFsbG9jVW5zYWZlKDQpO1xuICAgIHRoaXMuZnJhbWVIZWFkZXIgPSBidWZmZXJBbGxvY1Vuc2FmZSgxMCk7XG5cbiAgICAvLyB0aGUgQnVmZmVyTGlzdCB3aWxsIGhhbmRsZSB0aGUgZGF0YSBzdHJlYW1pbmcgaW5cbiAgICB0aGlzLmJ1ZmZlckxpc3QgPSBuZXcgQnVmZmVyTGlzdCgpO1xuXG4gICAgLy8gUHJlcGFyZSBmb3IgcmVjZWl2aW5nIGZpcnN0IGZyYW1lXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDsgLy8gZGF0YSByZWNlaXZlZCBzbyBmYXIuLi5cbiAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICBcbiAgICAvLyBWYXJpb3VzIGJpdHMgb2YgY29ubmVjdGlvbiBzdGF0ZVxuICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfT1BFTjtcbiAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgLy8gUmVjZWl2ZWQgVENQIEZJTiwgc29ja2V0J3MgcmVhZGFibGUgc3RyZWFtIGlzIGZpbmlzaGVkLlxuICAgIHRoaXMucmVjZWl2ZWRFbmQgPSBmYWxzZTtcblxuICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gdGhpcy5jb25maWcuY2xvc2VUaW1lb3V0O1xuICAgIHRoaXMuYXNzZW1ibGVGcmFnbWVudHMgPSB0aGlzLmNvbmZpZy5hc3NlbWJsZUZyYWdtZW50cztcbiAgICB0aGlzLm1heFJlY2VpdmVkTWVzc2FnZVNpemUgPSB0aGlzLmNvbmZpZy5tYXhSZWNlaXZlZE1lc3NhZ2VTaXplO1xuXG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gZmFsc2U7XG4gICAgdGhpcy5pbnB1dFBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVjZWl2ZWREYXRhSGFuZGxlciA9IHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2Nsb3NlVGltZXJIYW5kbGVyID0gdGhpcy5oYW5kbGVDbG9zZVRpbWVyLmJpbmQodGhpcyk7XG5cbiAgICAvLyBEaXNhYmxlIG5hZ2xlIGFsZ29yaXRobT9cbiAgICB0aGlzLnNvY2tldC5zZXROb0RlbGF5KHRoaXMuY29uZmlnLmRpc2FibGVOYWdsZUFsZ29yaXRobSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbm8gc29ja2V0IGluYWN0aXZpdHkgdGltZW91dFxuICAgIHRoaXMuc29ja2V0LnNldFRpbWVvdXQoMCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcua2VlcGFsaXZlICYmICF0aGlzLmNvbmZpZy51c2VOYXRpdmVLZWVwYWxpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlZXBhbGl2ZUludGVydmFsIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBudW1lcmljICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZiBrZWVwYWxpdmUgaXMgdHJ1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9rZWVwYWxpdmVUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUtlZXBhbGl2ZVRpbWVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0S2VlcGFsaXZlVGltZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodGhpcy5jb25maWcua2VlcGFsaXZlR3JhY2VQZXJpb2QpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2VlcGFsaXZlR3JhY2VQZXJpb2QgIG11c3QgYmUgc3BlY2lmaWVkIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bWVyaWMgaWYgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcyB0cnVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUdyYWNlUGVyaW9kVGltZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5rZWVwYWxpdmUgJiYgdGhpcy5jb25maWcudXNlTmF0aXZlS2VlcGFsaXZlKSB7XG4gICAgICAgIGlmICghKCdzZXRLZWVwQWxpdmUnIGluIHRoaXMuc29ja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdXNlIG5hdGl2ZSBrZWVwYWxpdmU6IHVuc3VwcG9ydGVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGlzIHZlcnNpb24gb2YgTm9kZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwgdGhpcy5jb25maWcua2VlcGFsaXZlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUaGUgSFRUUCBDbGllbnQgc2VlbXMgdG8gc3Vic2NyaWJlIHRvIHNvY2tldCBlcnJvciBldmVudHNcbiAgICAvLyBhbmQgcmUtZGlzcGF0Y2ggdGhlbSBpbiBzdWNoIGEgd2F5IHRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gZm9yIHVzZXJzIG9mIG91ciBjbGllbnQsIHNvIHdlIHdhbnQgdG8gbWFrZSBzdXJlIG5vYm9keVxuICAgIC8vIGVsc2UgaXMgbGlzdGVuaW5nIGZvciBlcnJvciBldmVudHMgb24gdGhlIHNvY2tldCBiZXNpZGVzIHVzLlxuICAgIHRoaXMuc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbn1cblxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMID0gMTAwMDtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0dPSU5HX0FXQVkgPSAxMDAxO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IgPSAxMDAyO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fVU5QUk9DRVNTQUJMRV9JTlBVVCA9IDEwMDM7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9SRVNFUlZFRCA9IDEwMDQ7IC8vIFJlc2VydmVkIHZhbHVlLiAgVW5kZWZpbmVkIG1lYW5pbmcuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1RfUFJPVklERUQgPSAxMDA1OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwgPSAxMDA2OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBID0gMTAwNztcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BPTElDWV9WSU9MQVRJT04gPSAxMDA4O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHID0gMTAwOTtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0VYVEVOU0lPTl9SRVFVSVJFRCA9IDEwMTA7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlRFUk5BTF9TRVJWRVJfRVJST1IgPSAxMDExO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fVExTX0hBTkRTSEFLRV9GQUlMRUQgPSAxMDE1OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OUyA9IHtcbiAgICAxMDAwOiAnTm9ybWFsIGNvbm5lY3Rpb24gY2xvc3VyZScsXG4gICAgMTAwMTogJ1JlbW90ZSBwZWVyIGlzIGdvaW5nIGF3YXknLFxuICAgIDEwMDI6ICdQcm90b2NvbCBlcnJvcicsXG4gICAgMTAwMzogJ1VucHJvY2Vzc2FibGUgaW5wdXQnLFxuICAgIDEwMDQ6ICdSZXNlcnZlZCcsXG4gICAgMTAwNTogJ1JlYXNvbiBub3QgcHJvdmlkZWQnLFxuICAgIDEwMDY6ICdBYm5vcm1hbCBjbG9zdXJlLCBubyBmdXJ0aGVyIGRldGFpbCBhdmFpbGFibGUnLFxuICAgIDEwMDc6ICdJbnZhbGlkIGRhdGEgcmVjZWl2ZWQnLFxuICAgIDEwMDg6ICdQb2xpY3kgdmlvbGF0aW9uJyxcbiAgICAxMDA5OiAnTWVzc2FnZSB0b28gYmlnJyxcbiAgICAxMDEwOiAnRXh0ZW5zaW9uIHJlcXVlc3RlZCBieSBjbGllbnQgaXMgcmVxdWlyZWQnLFxuICAgIDEwMTE6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDEwMTU6ICdUTFMgSGFuZHNoYWtlIEZhaWxlZCdcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xvc2VSZWFzb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgMTAwMCkge1xuICAgICAgICAvLyBTdGF0dXMgY29kZXMgaW4gdGhlIHJhbmdlIDAtOTk5IGFyZSBub3QgdXNlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDEwMDAgJiYgY29kZSA8PSAyOTk5KSB7XG4gICAgICAgIC8vIENvZGVzIGZyb20gMTAwMCAtIDI5OTkgYXJlIHJlc2VydmVkIGZvciB1c2UgYnkgdGhlIHByb3RvY29sLiAgT25seVxuICAgICAgICAvLyBhIGZldyBjb2RlcyBhcmUgZGVmaW5lZCwgYWxsIG90aGVycyBhcmUgY3VycmVudGx5IGlsbGVnYWwuXG4gICAgICAgIHJldHVybiBbMTAwMCwgMTAwMSwgMTAwMiwgMTAwMywgMTAwNywgMTAwOCwgMTAwOSwgMTAxMCwgMTAxMSwgMTAxMiwgMTAxMywgMTAxNCwgMTAxNV0uaW5kZXhPZihjb2RlKSAhPT0gLTE7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSAzOTk5KSB7XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciB1c2UgYnkgbGlicmFyaWVzLCBmcmFtZXdvcmtzLCBhbmQgYXBwbGljYXRpb25zLlxuICAgICAgICAvLyBTaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIElBTkEuICBJbnRlcnByZXRhdGlvbiBvZiB0aGVzZSBjb2RlcyBpc1xuICAgICAgICAvLyB1bmRlZmluZWQgYnkgdGhlIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDQwMDAgJiYgY29kZSA8PSA0OTk5KSB7XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBwcml2YXRlIHVzZS4gIEludGVycHJldGF0aW9uIG9mIHRoZXNlIGNvZGVzIGlzXG4gICAgICAgIC8vIHVuZGVmaW5lZCBieSB0aGUgV2ViU29ja2V0IHByb3RvY29sLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gNTAwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuaGFuZGxlU29ja2V0RXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2VuZCcsIHRoaXMuaGFuZGxlU29ja2V0RW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuaGFuZGxlU29ja2V0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2RyYWluJywgdGhpcy5oYW5kbGVTb2NrZXREcmFpbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbigncGF1c2UnLCB0aGlzLmhhbmRsZVNvY2tldFBhdXNlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdyZXN1bWUnLCB0aGlzLmhhbmRsZVNvY2tldFJlc3VtZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZGF0YScsIHRoaXMuaGFuZGxlU29ja2V0RGF0YS5iaW5kKHRoaXMpKTtcbn07XG5cbi8vIHNldCBvciByZXNldCB0aGUga2VlcGFsaXZlIHRpbWVyIHdoZW4gZGF0YSBpcyByZWNlaXZlZC5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldEtlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NldEtlZXBhbGl2ZVRpbWVyJyk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5rZWVwYWxpdmUgIHx8IHRoaXMuY29uZmlnLnVzZU5hdGl2ZUtlZXBhbGl2ZSkgeyByZXR1cm47IH1cbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5fa2VlcGFsaXZlVGltZXJIYW5kbGVyLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhcktlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fa2VlcGFsaXZlVGltZW91dElEKTtcbiAgICB9XG59O1xuXG4vLyBObyBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIHdpdGhpbiBjb25maWcua2VlcGFsaXZlVGltZW91dCBtcy5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUtlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUtlZXBhbGl2ZVRpbWVyJyk7XG4gICAgdGhpcy5fa2VlcGFsaXZlVGltZW91dElEID0gbnVsbDtcbiAgICB0aGlzLnBpbmcoKTtcblxuICAgIC8vIElmIHdlIGFyZSBjb25maWd1cmVkIHRvIGRyb3AgY29ubmVjdGlvbnMgaWYgdGhlIGNsaWVudCBkb2Vzbid0IHJlc3BvbmRcbiAgICAvLyB0aGVuIHNldCB0aGUgZ3JhY2UgcGVyaW9kIHRpbWVyLlxuICAgIGlmICh0aGlzLmNvbmZpZy5kcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCkge1xuICAgICAgICB0aGlzLnNldEdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCB0aGUga2VlcGFsaXZlIHRpbWVyIHRvIHNlbmQgdGhlIG5leHQgcGluZy5cbiAgICAgICAgdGhpcy5zZXRLZWVwYWxpdmVUaW1lcigpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldEdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0R3JhY2VQZXJpb2RUaW1lcicpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuX2dyYWNlUGVyaW9kVGltZXJIYW5kbGVyLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVHcmFjZVBlcmlvZCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhckdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVHcmFjZVBlcmlvZFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUdyYWNlUGVyaW9kVGltZXInKTtcbiAgICAvLyBJZiB0aGlzIGlzIGNhbGxlZCwgdGhlIGNsaWVudCBoYXMgbm90IHJlc3BvbmRlZCBhbmQgaXMgYXNzdW1lZCBkZWFkLlxuICAgIHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEID0gbnVsbDtcbiAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwsICdQZWVyIG5vdCByZXNwb25kaW5nLicsIHRydWUpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RGF0YScpO1xuICAgIC8vIFJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgd2hlbiByZWNlaXZpbmcgZGF0YSBvZiBhbnkga2luZC5cbiAgICB0aGlzLnNldEtlZXBhbGl2ZVRpbWVyKCk7XG5cbiAgICAvLyBBZGQgcmVjZWl2ZWQgZGF0YSB0byBvdXIgYnVmZmVyTGlzdCwgd2hpY2ggZWZmaWNpZW50bHkgaG9sZHMgcmVjZWl2ZWRcbiAgICAvLyBkYXRhIGNodW5rcyBpbiBhIGxpbmtlZCBsaXN0IG9mIEJ1ZmZlciBvYmplY3RzLlxuICAgIHRoaXMuYnVmZmVyTGlzdC53cml0ZShkYXRhKTtcblxuICAgIHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc1JlY2VpdmVkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdwcm9jZXNzUmVjZWl2ZWREYXRhJyk7XG4gICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2Ugc2hvdWxkIGlnbm9yZSBhbnkgZGF0YSByZW1haW5pbmcgb24gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7IHJldHVybjsgfVxuXG4gICAgLy8gUmVjZWl2aW5nL3BhcnNpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaGFsdGVkIHdoZW4gcGF1c2VkLlxuICAgIGlmICh0aGlzLmlucHV0UGF1c2VkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cbiAgICAvLyBXZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUuYWRkRGF0YSByZXR1cm5zIHRydWUgaWYgYWxsIGRhdGEgbmVjZXNzYXJ5IHRvXG4gICAgLy8gcGFyc2UgdGhlIGZyYW1lIHdhcyBhdmFpbGFibGUuICBJdCByZXR1cm5zIGZhbHNlIGlmIHdlIGFyZSB3YWl0aW5nIGZvclxuICAgIC8vIG1vcmUgZGF0YSB0byBjb21lIGluIG9uIHRoZSB3aXJlLlxuICAgIGlmICghZnJhbWUuYWRkRGF0YSh0aGlzLmJ1ZmZlckxpc3QpKSB7IHRoaXMuX2RlYnVnKCctLSBpbnN1ZmZpY2llbnQgZGF0YSBmb3IgZnJhbWUnKTsgcmV0dXJuOyB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBIYW5kbGUgcG9zc2libGUgcGFyc2luZyBlcnJvcnNcbiAgICBpZiAoZnJhbWUucHJvdG9jb2xFcnJvcikge1xuICAgICAgICAvLyBTb21ldGhpbmcgYmFkIGhhcHBlbmVkLi4gZ2V0IHJpZCBvZiB0aGlzIGNsaWVudC5cbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIHByb3RvY29sIGVycm9yJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsIGZyYW1lLmRyb3BSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChmcmFtZS5mcmFtZVRvb0xhcmdlKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBmcmFtZSB0b28gbGFyZ2UnKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUcsIGZyYW1lLmRyb3BSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvciBub3cgc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydCBleHRlbnNpb25zLCBhbGwgUlNWIGJpdHMgYXJlIGlsbGVnYWxcbiAgICBpZiAoZnJhbWUucnN2MSB8fCBmcmFtZS5yc3YyIHx8IGZyYW1lLnJzdjMpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGlsbGVnYWwgcnN2IGZsYWcnKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIHVzYWdlIG9mIHJzdiBiaXRzIHdpdGhvdXQgbmVnb3RpYXRlZCBleHRlbnNpb24uJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBlbWl0dGluZyBmcmFtZScpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLmVtaXQoJ2ZyYW1lJywgZnJhbWUpOyB9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLnByb2Nlc3NGcmFtZShmcmFtZSk7IH0pO1xuICAgIFxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGRhdGEgcmVtYWluaW5nLCBzY2hlZHVsZSBhZGRpdGlvbmFsIHByb2Nlc3NpbmcsIGJ1dCB5aWVsZFxuICAgIC8vIGZvciBub3cgc28gdGhhdCBvdGhlciBjb25uZWN0aW9ucyBoYXZlIGEgY2hhbmNlIHRvIGhhdmUgdGhlaXIgZGF0YVxuICAgIC8vIHByb2Nlc3NlZC4gIFdlIHVzZSBzZXRJbW1lZGlhdGUgaGVyZSBpbnN0ZWFkIG9mIHByb2Nlc3MubmV4dFRpY2sgdG9cbiAgICAvLyBleHBsaWNpdGx5IGluZGljYXRlIHRoYXQgd2Ugd2lzaCBmb3Igb3RoZXIgSS9PIHRvIGJlIGhhbmRsZWQgZmlyc3QuXG4gICAgaWYgKHRoaXMuYnVmZmVyTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZUltcGwodGhpcy5yZWNlaXZlZERhdGFIYW5kbGVyKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldEVycm9yOiAlaicsIGVycm9yKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfQ0xPU0VEKSB7XG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZS9pc3N1ZXMvMjg4XG4gICAgICAgIHRoaXMuX2RlYnVnKCcgIC0tLSBTb2NrZXQgXFwnZXJyb3JcXCcgYWZ0ZXIgXFwnY2xvc2VcXCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMO1xuICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9ICdTb2NrZXQgRXJyb3I6ICcgKyBlcnJvci5zeXNjYWxsICsgJyAnICsgZXJyb3IuY29kZTtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG4gICAgaWYgKHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB0aGlzLl9kZWJ1Zy5wcmludE91dHB1dCgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldEVuZDogcmVjZWl2ZWQgc29ja2V0IGVuZC4gIHN0YXRlID0gJXMnLCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLnJlY2VpdmVkRW5kID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfQ0xPU0VEKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgdGhlIFRMUyBtb2R1bGUsIHNvbWV0aW1lcyB0aGUgc29ja2V0IHdpbGwgZW1pdCAnZW5kJ1xuICAgICAgICAvLyBhZnRlciBpdCBlbWl0cyAnY2xvc2UnLiAgSSBkb24ndCB0aGluayB0aGF0J3MgY29ycmVjdCBiZWhhdmlvcixcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBkZWFsIHdpdGggaXQgZ3JhY2VmdWxseSBieSBpZ25vcmluZyBpdC5cbiAgICAgICAgdGhpcy5fZGVidWcoJyAgLS0tIFNvY2tldCBcXCdlbmRcXCcgYWZ0ZXIgXFwnY2xvc2VcXCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRU5ESU5HKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnICAtLS0gVU5FWFBFQ1RFRCBzb2NrZXQgZW5kLicpO1xuICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0Q2xvc2UgPSBmdW5jdGlvbihoYWRFcnJvcikge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRDbG9zZTogcmVjZWl2ZWQgc29ja2V0IGNsb3NlJyk7XG4gICAgdGhpcy5zb2NrZXRIYWRFcnJvciA9IGhhZEVycm9yO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAvLyBJZiBjbG9zZVJlYXNvbkNvZGUgaXMgc3RpbGwgc2V0IHRvIC0xIGF0IHRoaXMgcG9pbnQgdGhlbiB3ZSBtdXN0XG4gICAgLy8gbm90IGhhdmUgcmVjZWl2ZWQgYSBjbG9zZSBmcmFtZSEhXG4gICAgaWYgKHRoaXMuY2xvc2VSZWFzb25Db2RlID09PSAtMSkge1xuICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMO1xuICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IHJlbW90ZSBwZWVyLic7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICBpZiAoIXRoaXMuY2xvc2VFdmVudEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBFbWl0dGluZyBXZWJTb2NrZXRDb25uZWN0aW9uIGNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLmNsb3NlUmVhc29uQ29kZSwgdGhpcy5jbG9zZURlc2NyaXB0aW9uKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXREcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXREcmFpbjogc29ja2V0IGRyYWluIGV2ZW50Jyk7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0UGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0UGF1c2U6IHNvY2tldCBwYXVzZSBldmVudCcpO1xuICAgIHRoaXMuaW5wdXRQYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldFJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRSZXN1bWU6IHNvY2tldCByZXN1bWUgZXZlbnQnKTtcbiAgICB0aGlzLmlucHV0UGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgICB0aGlzLnByb2Nlc3NSZWNlaXZlZERhdGEoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BhdXNlOiBwYXVzZSByZXF1ZXN0ZWQnKTtcbiAgICB0aGlzLnNvY2tldC5wYXVzZSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Jlc3VtZTogcmVzdW1lIHJlcXVlc3RlZCcpO1xuICAgIHRoaXMuc29ja2V0LnJlc3VtZSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnY2xvc2U6IEluaXRhdGluZyBjbGVhbiBXZWJTb2NrZXQgY2xvc2Ugc2VxdWVuY2UuJyk7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHJlYXNvbkNvZGUpIHtcbiAgICAgICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZGF0ZUNsb3NlUmVhc29uKHJlYXNvbkNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlIGNvZGUgJyArIHJlYXNvbkNvZGUgKyAnIGlzIG5vdCB2YWxpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OU1tyZWFzb25Db2RlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNldENsb3NlVGltZXIoKTtcbiAgICAgICAgdGhpcy5zZW5kQ2xvc2VGcmFtZSh0aGlzLmNsb3NlUmVhc29uQ29kZSwgdGhpcy5jbG9zZURlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0VORElORztcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24ocmVhc29uQ29kZSwgZGVzY3JpcHRpb24sIHNraXBDbG9zZUZyYW1lKSB7XG4gICAgdGhpcy5fZGVidWcoJ2Ryb3AnKTtcbiAgICBpZiAodHlwZW9mKHJlYXNvbkNvZGUpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihkZXNjcmlwdGlvbikgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIElmIG5vIGRlc2NyaXB0aW9uIGlzIHByb3ZpZGVkLCB0cnkgdG8gbG9vayBvbmUgdXAgYmFzZWQgb24gdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCByZWFzb25Db2RlLlxuICAgICAgICBkZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3JlYXNvbkNvZGVdO1xuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdGb3JjZWZ1bGx5IGRyb3BwaW5nIGNvbm5lY3Rpb24uIHNraXBDbG9zZUZyYW1lOiAlcywgY29kZTogJWQsIGRlc2NyaXB0aW9uOiAlcycsXG4gICAgICAgIHNraXBDbG9zZUZyYW1lLCByZWFzb25Db2RlLCBkZXNjcmlwdGlvblxuICAgICk7XG5cbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgdGhpcy5mcmFtZVF1ZXVlID0gW107XG4gICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG4gICAgaWYgKCFza2lwQ2xvc2VGcmFtZSkge1xuICAgICAgICB0aGlzLnNlbmRDbG9zZUZyYW1lKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcblxuICAgIGlmICghdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCkge1xuICAgICAgICB0aGlzLmNsb3NlRXZlbnRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVidWcoJ0VtaXR0aW5nIFdlYlNvY2tldENvbm5lY3Rpb24gY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9kZWJ1ZygnRHJvcDogZGVzdHJveWluZyBzb2NrZXQnKTtcbiAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NldENsb3NlVGltZXInKTtcbiAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIHRoaXMuX2RlYnVnKCdTZXR0aW5nIGNsb3NlIHRpbWVyJyk7XG4gICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9jbG9zZVRpbWVySGFuZGxlciwgdGhpcy5jbG9zZVRpbWVvdXQpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYXJDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2NsZWFyQ2xvc2VUaW1lcicpO1xuICAgIGlmICh0aGlzLmNsb3NlVGltZXIpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ0NsZWFyaW5nIGNsb3NlIHRpbWVyJyk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlQ2xvc2VUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVDbG9zZVRpbWVyJyk7XG4gICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnQ2xvc2UgcmVzcG9uc2Ugbm90IHJlY2VpdmVkIGZyb20gY2xpZW50LiAgRm9yY2luZyBzb2NrZXQgZW5kLicpO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Byb2Nlc3NGcmFtZScpO1xuICAgIHRoaXMuX2RlYnVnKCcgLS0gZnJhbWU6ICVzJywgZnJhbWUpO1xuICAgIFxuICAgIC8vIEFueSBub24tY29udHJvbCBvcGNvZGUgYmVzaWRlcyAweDAwIChjb250aW51YXRpb24pIHJlY2VpdmVkIGluIHRoZVxuICAgIC8vIG1pZGRsZSBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZSBpcyBpbGxlZ2FsLlxuICAgIGlmICh0aGlzLmZyYW1lUXVldWUubGVuZ3RoICE9PSAwICYmIChmcmFtZS5vcGNvZGUgPiAweDAwICYmIGZyYW1lLm9wY29kZSA8IDB4MDgpKSB7XG4gICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAnSWxsZWdhbCBmcmFtZSBvcGNvZGUgMHgnICsgZnJhbWUub3Bjb2RlLnRvU3RyaW5nKDE2KSArICcgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkIGluIG1pZGRsZSBvZiBmcmFnbWVudGVkIG1lc3NhZ2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZnJhbWUub3Bjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMjogLy8gV2ViU29ja2V0RnJhbWUuQklOQVJZX0ZSQU1FXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQmluYXJ5IEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgc2luZ2xlLWZyYW1lIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gRW1pdHRpbmcgXFwnbWVzc2FnZVxcJyBldmVudCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeURhdGE6IGZyYW1lLmJpbmFyeVBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgYSBmcmFnbWVudGVkIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDE6IC8vIFdlYlNvY2tldEZyYW1lLlRFWFRfRlJBTUVcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBUZXh0IEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChmcmFtZS5iaW5hcnlQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHNpbmdsZS1mcmFtZSBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIEVtaXR0aW5nIFxcJ21lc3NhZ2VcXCcgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3V0ZjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOERhdGE6IGZyYW1lLmJpbmFyeVBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMDogLy8gV2ViU29ja2V0RnJhbWUuQ09OVElOVUFUSU9OXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQ29udGludWF0aW9uIEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBDb250aW51YXRpb24gRnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgKz0gZnJhbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPiB0aGlzLm1heFJlY2VpdmVkTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRyxcbiAgICAgICAgICAgICAgICAgICAgICAnTWF4aW11bSBtZXNzYWdlIHNpemUgZXhjZWVkZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUuZmluKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBmcmFnbWVudGVkIG1lc3NhZ2UsIHNvIHdlIHByb2Nlc3MgdGhlIHdob2xlXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2Ugbm93LiAgV2UgYWxzbyBoYXZlIHRvIGRlY29kZSB0aGUgdXRmLTggZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGV4dCBmcmFtZXMgYWZ0ZXIgY29tYmluaW5nIGFsbCB0aGUgZnJhZ21lbnRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMuZnJhZ21lbnRhdGlvblNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3Bjb2RlID0gdGhpcy5mcmFtZVF1ZXVlWzBdLm9wY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmJpbmFyeVBheWxvYWQuY29weShiaW5hcnlQYXlsb2FkLCBieXRlc0NvcGllZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0NvcGllZCArPSBjdXJyZW50RnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMjogLy8gV2ViU29ja2V0T3Bjb2RlLkJJTkFSWV9GUkFNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JpbmFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeURhdGE6IGJpbmFyeVBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMTogLy8gV2ViU29ja2V0T3Bjb2RlLlRFWFRfRlJBTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3V0ZjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4RGF0YTogYmluYXJ5UGF5bG9hZC50b1N0cmluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGZpcnN0IG9wY29kZSBpbiBmcmFnbWVudGF0aW9uIHNlcXVlbmNlOiAweCcgKyBvcGNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvLyBXZWJTb2NrZXRGcmFtZS5QSU5HXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gUGluZyBGcmFtZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGluZ0xpc3RlbmVyQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9naWMgdG8gZW1pdCB0aGUgcGluZyBmcmFtZTogdGhpcyBpcyBvbmx5IGRvbmUgd2hlbiBhIGxpc3RlbmVyIGlzIGtub3duIHRvIGV4aXN0XG4gICAgICAgICAgICAgICAgLy8gRXhwb3NlIGEgZnVuY3Rpb24gYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycsIGNhbmNlbCwgZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNlbmQgYSBwb25nIGlmIHRoZSBjbGllbnQgZGlkIG5vdCBpbmRpY2F0ZSB0aGF0IGhlIHdvdWxkIGxpa2UgdG8gY2FuY2VsXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb25nKGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9uZyhmcmFtZS5iaW5hcnlQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwQTogLy8gV2ViU29ja2V0RnJhbWUuUE9OR1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFBvbmcgRnJhbWUnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycsIGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwODogLy8gV2ViU29ja2V0RnJhbWUuQ09OTkVDVElPTl9DTE9TRVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIENsb3NlIEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIEdvdCByZXNwb25zZSB0byBvdXIgcmVxdWVzdCB0byBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBpcyBjb21wbGV0ZSwgc28gd2UganVzdCBoYW5nIHVwLlxuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIEdvdCBjbG9zZSByZXNwb25zZSBmcm9tIHBlZXIuICBDb21wbGV0aW5nIGNsb3NpbmcgaGFuZHNoYWtlLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBDbG9zaW5nIGhhbmRzaGFrZSBpbml0aWF0ZWQgYnkgcGVlci4nKTtcbiAgICAgICAgICAgIC8vIEdvdCByZXF1ZXN0IGZyb20gb3RoZXIgcGFydHkgdG8gY2xvc2UgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIC8vIFNlbmQgYmFjayBhY2tub3dsZWRnZW1lbnQgYW5kIHRoZW4gaGFuZyB1cC5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRTtcbiAgICAgICAgICAgIHZhciByZXNwb25kQ2xvc2VSZWFzb25Db2RlO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNsb3NlIHJlYXNvbiBwcm92aWRlZCBpcyBsZWdhbCBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIHRoZSBwcm90b2NvbCBzcGVjLiAgUHJvdmlkaW5nIG5vIGNsb3NlIHN0YXR1cyBpcyBsZWdhbC5cbiAgICAgICAgICAgIC8vIFdlYlNvY2tldEZyYW1lIHNldHMgY2xvc2VTdGF0dXMgdG8gLTEgYnkgZGVmYXVsdCwgc28gaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIHN0aWxsIC0xLCB0aGVuIG5vIHN0YXR1cyB3YXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBpZiAoZnJhbWUuaW52YWxpZENsb3NlRnJhbWVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IDEwMDU7IC8vIDEwMDUgPSBObyByZWFzb24gcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgcmVzcG9uZENsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhbWUuY2xvc2VTdGF0dXMgPT09IC0xIHx8IHZhbGlkYXRlQ2xvc2VSZWFzb24oZnJhbWUuY2xvc2VTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBmcmFtZS5jbG9zZVN0YXR1cztcbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBmcmFtZS5jbG9zZVN0YXR1cztcbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdGV4dHVhbCBkZXNjcmlwdGlvbiBpbiB0aGUgY2xvc2UgZnJhbWUsIGV4dHJhY3QgaXQuXG4gICAgICAgICAgICBpZiAoZnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChmcmFtZS5iaW5hcnlQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFVURi04IERhdGEgUmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBmcmFtZS5iaW5hcnlQYXlsb2FkLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OU1t0aGlzLmNsb3NlUmVhc29uQ29kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICAnLS0tLS0tIFJlbW90ZSBwZWVyICVzIC0gY29kZTogJWQgLSAlcyAtIGNsb3NlIGZyYW1lIHBheWxvYWQgbGVuZ3RoOiAlZCcsXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzLCB0aGlzLmNsb3NlUmVhc29uQ29kZSxcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24sIGZyYW1lLmxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tLS0gcmVzcG9uZGluZyB0byByZW1vdGUgcGVlclxcJ3MgY2xvc2UgcmVxdWVzdC4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlRnJhbWUocmVzcG9uZENsb3NlUmVhc29uQ29kZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gVW5yZWNvZ25pemVkIE9wY29kZSAlZCcsIGZyYW1lLm9wY29kZSk7XG4gICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICdVbnJlY29nbml6ZWQgT3Bjb2RlOiAweCcgKyBmcmFtZS5vcGNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdzZW5kJyk7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICB0aGlzLnNlbmRCeXRlcyhkYXRhLCBjYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihkYXRhWyd0b1N0cmluZyddKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnNlbmRVVEYoZGF0YSwgY2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHByb3ZpZGVkIG11c3QgZWl0aGVyIGJlIGEgTm9kZSBCdWZmZXIgb3IgaW1wbGVtZW50IHRvU3RyaW5nKCknKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kVVRGID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgICBkYXRhID0gYnVmZmVyRnJvbVN0cmluZyhkYXRhLnRvU3RyaW5nKCksICd1dGY4Jyk7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRVVEY6ICVkIGJ5dGVzJywgZGF0YS5sZW5ndGgpO1xuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDE7IC8vIFdlYlNvY2tldE9wY29kZS5URVhUX0ZSQU1FXG4gICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGRhdGE7XG4gICAgdGhpcy5mcmFnbWVudEFuZFNlbmQoZnJhbWUsIGNiKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRCeXRlcyA9IGZ1bmN0aW9uKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRCeXRlcycpO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBhIE5vZGUgQnVmZmVyIG9iamVjdCB0byBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQnl0ZXMoKScpO1xuICAgIH1cbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDAyOyAvLyBXZWJTb2NrZXRPcGNvZGUuQklOQVJZX0ZSQU1FXG4gICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGRhdGE7XG4gICAgdGhpcy5mcmFnbWVudEFuZFNlbmQoZnJhbWUsIGNiKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BpbmcnKTtcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDA5OyAvLyBXZWJTb2NrZXRPcGNvZGUuUElOR1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBidWZmZXJGcm9tU3RyaW5nKGRhdGEudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdXZWJTb2NrZXQ6IERhdGEgZm9yIHBpbmcgaXMgbG9uZ2VyIHRoYW4gMTI1IGJ5dGVzLiAgVHJ1bmNhdGluZy4nKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsMTI0KTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB9XG4gICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUpO1xufTtcblxuLy8gUG9uZyBmcmFtZXMgaGF2ZSB0byBlY2hvIGJhY2sgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHBvcnRpb24gb2YgdGhlXG4vLyBwaW5nIGZyYW1lIGV4YWN0bHksIGJ5dGUgZm9yIGJ5dGUuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wb25nID0gZnVuY3Rpb24oYmluYXJ5UGF5bG9hZCkge1xuICAgIHRoaXMuX2RlYnVnKCdwb25nJyk7XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwQTsgLy8gV2ViU29ja2V0T3Bjb2RlLlBPTkdcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJpbmFyeVBheWxvYWQpICYmIGJpbmFyeVBheWxvYWQubGVuZ3RoID4gMTI1KSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdXZWJTb2NrZXQ6IERhdGEgZm9yIHBvbmcgaXMgbG9uZ2VyIHRoYW4gMTI1IGJ5dGVzLiAgVHJ1bmNhdGluZy4nKTtcbiAgICAgICAgYmluYXJ5UGF5bG9hZCA9IGJpbmFyeVBheWxvYWQuc2xpY2UoMCwxMjQpO1xuICAgIH1cbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gYmluYXJ5UGF5bG9hZDtcbiAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmZyYWdtZW50QW5kU2VuZCA9IGZ1bmN0aW9uKGZyYW1lLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdmcmFnbWVudEFuZFNlbmQnKTtcbiAgICBpZiAoZnJhbWUub3Bjb2RlID4gMHgwNykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZnJhZ21lbnQgY29udHJvbCBmcmFtZXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuY29uZmlnLmZyYWdtZW50YXRpb25UaHJlc2hvbGQ7XG4gICAgdmFyIGxlbmd0aCA9IGZyYW1lLmJpbmFyeVBheWxvYWQubGVuZ3RoO1xuXG4gICAgLy8gU2VuZCBpbW1lZGlhdGVseSBpZiBmcmFnbWVudGF0aW9uIGlzIGRpc2FibGVkIG9yIHRoZSBtZXNzYWdlIGlzIG5vdFxuICAgIC8vIGxhcmdlciB0aGFuIHRoZSBmcmFnbWVudGF0aW9uIHRocmVzaG9sZC5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyB8fCAoZnJhbWUuYmluYXJ5UGF5bG9hZCAmJiBsZW5ndGggPD0gdGhyZXNob2xkKSkge1xuICAgICAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBudW1GcmFnbWVudHMgPSBNYXRoLmNlaWwobGVuZ3RoIC8gdGhyZXNob2xkKTtcbiAgICB2YXIgc2VudEZyYWdtZW50cyA9IDA7XG4gICAgdmFyIHNlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGZyYWdtZW50U2VudENhbGxiYWNrKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBvbmx5IHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICsrc2VudEZyYWdtZW50cztcbiAgICAgICAgaWYgKChzZW50RnJhZ21lbnRzID09PSBudW1GcmFnbWVudHMpICYmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpPTE7IGkgPD0gbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgICAgICBcbiAgICAgICAgLy8gY29udGludWF0aW9uIG9wY29kZSBleGNlcHQgZm9yIGZpcnN0IGZyYW1lLlxuICAgICAgICBjdXJyZW50RnJhbWUub3Bjb2RlID0gKGkgPT09IDEpID8gZnJhbWUub3Bjb2RlIDogMHgwMDtcbiAgICAgICAgXG4gICAgICAgIC8vIGZpbiBzZXQgb24gbGFzdCBmcmFtZSBvbmx5XG4gICAgICAgIGN1cnJlbnRGcmFtZS5maW4gPSAoaSA9PT0gbnVtRnJhZ21lbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGxlbmd0aCBpcyBsaWtlbHkgdG8gYmUgc2hvcnRlciBvbiB0aGUgbGFzdCBmcmFnbWVudFxuICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IChpID09PSBudW1GcmFnbWVudHMpID8gbGVuZ3RoIC0gKHRocmVzaG9sZCAqIChpLTEpKSA6IHRocmVzaG9sZDtcbiAgICAgICAgdmFyIHNsaWNlU3RhcnQgPSB0aHJlc2hvbGQgKiAoaS0xKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNsaWNlIHRoZSByaWdodCBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCBwYXlsb2FkXG4gICAgICAgIGN1cnJlbnRGcmFtZS5iaW5hcnlQYXlsb2FkID0gZnJhbWUuYmluYXJ5UGF5bG9hZC5zbGljZShzbGljZVN0YXJ0LCBzbGljZVN0YXJ0ICsgY3VycmVudExlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNlbmRGcmFtZShjdXJyZW50RnJhbWUsIHNlbnRDYWxsYmFjayk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZENsb3NlRnJhbWUgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbiwgY2IpIHtcbiAgICBpZiAodHlwZW9mKHJlYXNvbkNvZGUpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZENsb3NlRnJhbWUgc3RhdGU6ICVzLCByZWFzb25Db2RlOiAlZCwgZGVzY3JpcHRpb246ICVzJywgdGhpcy5zdGF0ZSwgcmVhc29uQ29kZSwgZGVzY3JpcHRpb24pO1xuICAgIFxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9PUEVOICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFKSB7IHJldHVybjsgfVxuICAgIFxuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwODsgLy8gV2ViU29ja2V0T3Bjb2RlLkNPTk5FQ1RJT05fQ0xPU0VcbiAgICBmcmFtZS5jbG9zZVN0YXR1cyA9IHJlYXNvbkNvZGU7XG4gICAgaWYgKHR5cGVvZihkZXNjcmlwdGlvbikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBidWZmZXJGcm9tU3RyaW5nKGRlc2NyaXB0aW9uLCAndXRmOCcpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSwgY2IpO1xuICAgIHRoaXMuc29ja2V0LmVuZCgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRGcmFtZScpO1xuICAgIGZyYW1lLm1hc2sgPSB0aGlzLm1hc2tPdXRnb2luZ1BhY2tldHM7XG4gICAgdmFyIGZsdXNoZWQgPSB0aGlzLnNvY2tldC53cml0ZShmcmFtZS50b0J1ZmZlcigpLCBjYik7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gIWZsdXNoZWQ7XG4gICAgcmV0dXJuIGZsdXNoZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENvbm5lY3Rpb247XG5cblxuXG5mdW5jdGlvbiBpbnN0cnVtZW50U29ja2V0Rm9yRGVidWdnaW5nKGNvbm5lY3Rpb24sIHNvY2tldCkge1xuICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgIGlmICghY29ubmVjdGlvbi5fZGVidWcuZW5hYmxlZCkgeyByZXR1cm47IH1cbiAgICBcbiAgICB2YXIgb3JpZ2luYWxTb2NrZXRFbWl0ID0gc29ja2V0LmVtaXQ7XG4gICAgc29ja2V0LmVtaXQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBjb25uZWN0aW9uLl9kZWJ1ZygnfHx8IFNvY2tldCBFdmVudCAgXFwnJXNcXCcnLCBldmVudCk7XG4gICAgICAgIG9yaWdpbmFsU29ja2V0RW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgXG4gICAgZm9yICh2YXIga2V5IGluIHNvY2tldCkge1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mKHNvY2tldFtrZXldKSkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoWydlbWl0J10uaW5kZXhPZihrZXkpICE9PSAtMSkgeyBjb250aW51ZTsgfVxuICAgICAgICAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBzb2NrZXRba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXRba2V5XSA9IGZ1bmN0aW9uIHByb3h5TWV0aG9kX19FdmVudEVtaXR0ZXJfX09uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9kZWJ1ZygnfHx8IFNvY2tldCBtZXRob2QgY2FsbGVkOiAgJXMgKCVzKScsIGtleSwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXRba2V5XSA9IGZ1bmN0aW9uIHByb3h5TWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IG1ldGhvZCBjYWxsZWQ6ICAlcycsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShrZXkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsInV0aWxzIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0RnJhbWUiLCJCdWZmZXJMaXN0IiwiaXNWYWxpZFVURjgiLCJidWZmZXJBbGxvY1Vuc2FmZSIsImJ1ZmZlckZyb21TdHJpbmciLCJTVEFURV9PUEVOIiwiU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UiLCJTVEFURV9FTkRJTkciLCJTVEFURV9DTE9TRUQiLCJzZXRJbW1lZGlhdGVJbXBsIiwiZ2xvYmFsIiwic2V0SW1tZWRpYXRlIiwiYmluZCIsInByb2Nlc3MiLCJuZXh0VGljayIsImlkQ291bnRlciIsIldlYlNvY2tldENvbm5lY3Rpb24iLCJzb2NrZXQiLCJleHRlbnNpb25zIiwicHJvdG9jb2wiLCJtYXNrT3V0Z29pbmdQYWNrZXRzIiwiY29uZmlnIiwiX2RlYnVnIiwiQnVmZmVyaW5nTG9nZ2VyIiwiZW5hYmxlZCIsImluc3RydW1lbnRTb2NrZXRGb3JEZWJ1Z2dpbmciLCJjYWxsIiwiX3BpbmdMaXN0ZW5lckNvdW50Iiwib24iLCJldiIsInJlbW90ZUFkZHJlc3MiLCJjbG9zZVJlYXNvbkNvZGUiLCJjbG9zZURlc2NyaXB0aW9uIiwiY2xvc2VFdmVudEVtaXR0ZWQiLCJtYXNrQnl0ZXMiLCJmcmFtZUhlYWRlciIsImJ1ZmZlckxpc3QiLCJjdXJyZW50RnJhbWUiLCJmcmFnbWVudGF0aW9uU2l6ZSIsImZyYW1lUXVldWUiLCJjb25uZWN0ZWQiLCJzdGF0ZSIsIndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlIiwicmVjZWl2ZWRFbmQiLCJjbG9zZVRpbWVvdXQiLCJhc3NlbWJsZUZyYWdtZW50cyIsIm1heFJlY2VpdmVkTWVzc2FnZVNpemUiLCJvdXRwdXRCdWZmZXJGdWxsIiwiaW5wdXRQYXVzZWQiLCJyZWNlaXZlZERhdGFIYW5kbGVyIiwicHJvY2Vzc1JlY2VpdmVkRGF0YSIsIl9jbG9zZVRpbWVySGFuZGxlciIsImhhbmRsZUNsb3NlVGltZXIiLCJzZXROb0RlbGF5IiwiZGlzYWJsZU5hZ2xlQWxnb3JpdGhtIiwic2V0VGltZW91dCIsImtlZXBhbGl2ZSIsInVzZU5hdGl2ZUtlZXBhbGl2ZSIsImtlZXBhbGl2ZUludGVydmFsIiwiRXJyb3IiLCJfa2VlcGFsaXZlVGltZXJIYW5kbGVyIiwiaGFuZGxlS2VlcGFsaXZlVGltZXIiLCJzZXRLZWVwYWxpdmVUaW1lciIsImRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0Iiwia2VlcGFsaXZlR3JhY2VQZXJpb2QiLCJfZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIiLCJoYW5kbGVHcmFjZVBlcmlvZFRpbWVyIiwic2V0S2VlcEFsaXZlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiQ0xPU0VfUkVBU09OX05PUk1BTCIsIkNMT1NFX1JFQVNPTl9HT0lOR19BV0FZIiwiQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SIiwiQ0xPU0VfUkVBU09OX1VOUFJPQ0VTU0FCTEVfSU5QVVQiLCJDTE9TRV9SRUFTT05fUkVTRVJWRUQiLCJDTE9TRV9SRUFTT05fTk9UX1BST1ZJREVEIiwiQ0xPU0VfUkVBU09OX0FCTk9STUFMIiwiQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSIsIkNMT1NFX1JFQVNPTl9QT0xJQ1lfVklPTEFUSU9OIiwiQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRyIsIkNMT1NFX1JFQVNPTl9FWFRFTlNJT05fUkVRVUlSRUQiLCJDTE9TRV9SRUFTT05fSU5URVJOQUxfU0VSVkVSX0VSUk9SIiwiQ0xPU0VfUkVBU09OX1RMU19IQU5EU0hBS0VfRkFJTEVEIiwiQ0xPU0VfREVTQ1JJUFRJT05TIiwidmFsaWRhdGVDbG9zZVJlYXNvbiIsImNvZGUiLCJpbmRleE9mIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJfYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMiLCJoYW5kbGVTb2NrZXRFcnJvciIsImhhbmRsZVNvY2tldEVuZCIsImhhbmRsZVNvY2tldENsb3NlIiwiaGFuZGxlU29ja2V0RHJhaW4iLCJoYW5kbGVTb2NrZXRQYXVzZSIsImhhbmRsZVNvY2tldFJlc3VtZSIsImhhbmRsZVNvY2tldERhdGEiLCJjbGVhcktlZXBhbGl2ZVRpbWVyIiwiY2xlYXJHcmFjZVBlcmlvZFRpbWVyIiwiX2tlZXBhbGl2ZVRpbWVvdXRJRCIsImNsZWFyVGltZW91dCIsInBpbmciLCJzZXRHcmFjZVBlcmlvZFRpbWVyIiwiX2dyYWNlUGVyaW9kVGltZW91dElEIiwiZHJvcCIsImRhdGEiLCJ3cml0ZSIsImZyYW1lIiwiYWRkRGF0YSIsInNlbGYiLCJwcm90b2NvbEVycm9yIiwiZHJvcFJlYXNvbiIsImZyYW1lVG9vTGFyZ2UiLCJyc3YxIiwicnN2MiIsInJzdjMiLCJlbWl0IiwicHJvY2Vzc0ZyYW1lIiwibGVuZ3RoIiwiZXJyb3IiLCJzeXNjYWxsIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsImRlc3Ryb3kiLCJwcmludE91dHB1dCIsImVuZCIsImhhZEVycm9yIiwic29ja2V0SGFkRXJyb3IiLCJjbGVhckNsb3NlVGltZXIiLCJwYXVzZSIsInJlc3VtZSIsImNsb3NlIiwicmVhc29uQ29kZSIsImRlc2NyaXB0aW9uIiwic2V0Q2xvc2VUaW1lciIsInNlbmRDbG9zZUZyYW1lIiwic2tpcENsb3NlRnJhbWUiLCJjbG9zZVRpbWVyIiwib3Bjb2RlIiwidG9TdHJpbmciLCJmaW4iLCJ0eXBlIiwiYmluYXJ5RGF0YSIsImJpbmFyeVBheWxvYWQiLCJwdXNoIiwidXRmOERhdGEiLCJieXRlc0NvcGllZCIsImZvckVhY2giLCJjb3B5IiwiY2FuY2VsbGVkIiwiY2FuY2VsIiwicG9uZyIsInJlc3BvbmRDbG9zZVJlYXNvbkNvZGUiLCJpbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCIsImNsb3NlU3RhdHVzIiwic2VuZCIsImNiIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJzZW5kQnl0ZXMiLCJzZW5kVVRGIiwiZnJhZ21lbnRBbmRTZW5kIiwic2xpY2UiLCJzZW5kRnJhbWUiLCJ0aHJlc2hvbGQiLCJmcmFnbWVudGF0aW9uVGhyZXNob2xkIiwiZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIiwibnVtRnJhZ21lbnRzIiwiTWF0aCIsImNlaWwiLCJzZW50RnJhZ21lbnRzIiwic2VudENhbGxiYWNrIiwiZnJhZ21lbnRTZW50Q2FsbGJhY2siLCJlcnIiLCJpIiwiY3VycmVudExlbmd0aCIsInNsaWNlU3RhcnQiLCJtYXNrIiwiZmx1c2hlZCIsInRvQnVmZmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbm5lY3Rpb24iLCJvcmlnaW5hbFNvY2tldEVtaXQiLCJldmVudCIsImFwcGx5IiwiYXJndW1lbnRzIiwia2V5Iiwib3JpZ2luYWwiLCJwcm94eU1ldGhvZF9fRXZlbnRFbWl0dGVyX19PbiIsInByb3h5TWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar bufferUtil = __webpack_require__(/*! bufferutil */ \"(action-browser)/./node_modules/bufferutil/index.js\");\nvar bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n            this.fin = Boolean(firstByte & 0x80);\n            this.rsv1 = Boolean(firstByte & 0x40);\n            this.rsv2 = Boolean(firstByte & 0x20);\n            this.rsv3 = Boolean(firstByte & 0x10);\n            this.mask = Boolean(secondByte & 0x80);\n            this.opcode = firstByte & 0x0F;\n            this.length = secondByte & 0x7F;\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = \"Illegal control frame longer than 125 bytes.\";\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = \"Control frames must not be fragmented.\";\n                    return true;\n                }\n            }\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            } else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            } else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n                this.frameHeader.readUInt32BE(2),\n                this.frameHeader.readUInt32BE(2 + 4)\n            ];\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = \"Unsupported 64-bit length frame received\";\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        } else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = \"Frame size of \" + this.length.toString(10) + \" bytes exceeds maximum accepted frame size\";\n            return true;\n        }\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n            // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n            if (this.opcode === 0x08) {\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n    firstByte |= this.opcode & 0x0F;\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    } else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    } else {\n        this.length = 0;\n    }\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= this.length & 0x7F;\n    } else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    } else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n    outputPos = 2;\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    } else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n    if (this.mask) {\n        maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n        if (data) {\n            bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    } else if (data) {\n        data.copy(output, outputPos);\n    }\n    return output;\n};\nWebSocketFrame.prototype.toString = function() {\n    return \"Opcode: \" + this.opcode + \", fin: \" + this.fin + \", length: \" + this.length + \", hasPayload: \" + Boolean(this.binaryPayload) + \", masked: \" + this.mask;\n};\nmodule.exports = WebSocketFrame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldEZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDekIsSUFBSUMsb0JBQW9CRCxnSEFBb0M7QUFFNUQsTUFBTUUsZ0JBQWdCO0FBQ3RCLE1BQU1DLDRCQUE0QjtBQUNsQyxNQUFNQyw0QkFBNEI7QUFDbEMsTUFBTUMsdUJBQXVCO0FBQzdCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxXQUFXO0FBRWpCLHdFQUF3RTtBQUN4RSw2RUFBNkU7QUFDN0UseUVBQXlFO0FBQ3pFLDJCQUEyQjtBQUMzQixTQUFTQyxlQUFlQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsTUFBTTtJQUNsRCxJQUFJLENBQUNGLFNBQVMsR0FBR0E7SUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNkLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUdELE9BQU9DLG9CQUFvQjtJQUN2RCxJQUFJLENBQUNDLGFBQWEsR0FBRztJQUNyQixJQUFJLENBQUNDLGFBQWEsR0FBRztJQUNyQixJQUFJLENBQUNDLHVCQUF1QixHQUFHO0lBQy9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHZDtJQUNsQixJQUFJLENBQUNlLFdBQVcsR0FBRyxDQUFDO0FBQ3hCO0FBRUFULGVBQWVVLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHLFNBQVNDLFVBQVU7SUFDbEQsSUFBSSxJQUFJLENBQUNKLFVBQVUsS0FBS2QsZUFBZTtRQUNuQyxJQUFJa0IsV0FBV0MsTUFBTSxJQUFJLEdBQUc7WUFDeEJELFdBQVdFLFFBQVEsQ0FBQyxJQUFJLENBQUNaLFdBQVcsRUFBRSxHQUFHLEdBQUc7WUFDNUNVLFdBQVdHLE9BQU8sQ0FBQztZQUNuQixJQUFJQyxZQUFZLElBQUksQ0FBQ2QsV0FBVyxDQUFDLEVBQUU7WUFDbkMsSUFBSWUsYUFBYSxJQUFJLENBQUNmLFdBQVcsQ0FBQyxFQUFFO1lBRXBDLElBQUksQ0FBQ2dCLEdBQUcsR0FBT0MsUUFBUUgsWUFBYTtZQUNwQyxJQUFJLENBQUNJLElBQUksR0FBTUQsUUFBUUgsWUFBYTtZQUNwQyxJQUFJLENBQUNLLElBQUksR0FBTUYsUUFBUUgsWUFBYTtZQUNwQyxJQUFJLENBQUNNLElBQUksR0FBTUgsUUFBUUgsWUFBYTtZQUNwQyxJQUFJLENBQUNPLElBQUksR0FBTUosUUFBUUYsYUFBYTtZQUVwQyxJQUFJLENBQUNPLE1BQU0sR0FBSVIsWUFBYTtZQUM1QixJQUFJLENBQUNILE1BQU0sR0FBR0ksYUFBYTtZQUUzQiw2QkFBNkI7WUFDN0IsSUFBSSxJQUFJLENBQUNPLE1BQU0sSUFBSSxNQUFNO2dCQUNyQixJQUFJLElBQUksQ0FBQ1gsTUFBTSxHQUFHLEtBQUs7b0JBQ25CLElBQUksQ0FBQ1IsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNvQixVQUFVLEdBQUc7b0JBQ2xCLE9BQU87Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1AsR0FBRyxFQUFFO29CQUNYLElBQUksQ0FBQ2IsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNvQixVQUFVLEdBQUc7b0JBQ2xCLE9BQU87Z0JBQ1g7WUFDSjtZQUVBLElBQUksSUFBSSxDQUFDWixNQUFNLEtBQUssS0FBSztnQkFDckIsSUFBSSxDQUFDTCxVQUFVLEdBQUdiO1lBQ3RCLE9BQ0ssSUFBSSxJQUFJLENBQUNrQixNQUFNLEtBQUssS0FBSztnQkFDMUIsSUFBSSxDQUFDTCxVQUFVLEdBQUdaO1lBQ3RCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDWSxVQUFVLEdBQUdYO1lBQ3RCO1FBQ0o7SUFDSjtJQUNBLElBQUksSUFBSSxDQUFDVyxVQUFVLEtBQUtiLDJCQUEyQjtRQUMvQyxJQUFJaUIsV0FBV0MsTUFBTSxJQUFJLEdBQUc7WUFDeEJELFdBQVdFLFFBQVEsQ0FBQyxJQUFJLENBQUNaLFdBQVcsRUFBRSxHQUFHLEdBQUc7WUFDNUNVLFdBQVdHLE9BQU8sQ0FBQztZQUNuQixJQUFJLENBQUNGLE1BQU0sR0FBRyxJQUFJLENBQUNYLFdBQVcsQ0FBQ3dCLFlBQVksQ0FBQztZQUM1QyxJQUFJLENBQUNsQixVQUFVLEdBQUdYO1FBQ3RCO0lBQ0osT0FDSyxJQUFJLElBQUksQ0FBQ1csVUFBVSxLQUFLWiwyQkFBMkI7UUFDcEQsSUFBSWdCLFdBQVdDLE1BQU0sSUFBSSxHQUFHO1lBQ3hCRCxXQUFXRSxRQUFRLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsR0FBRyxHQUFHO1lBQzVDVSxXQUFXRyxPQUFPLENBQUM7WUFDbkIsSUFBSVksYUFBYTtnQkFDZixJQUFJLENBQUN6QixXQUFXLENBQUMwQixZQUFZLENBQUM7Z0JBQzlCLElBQUksQ0FBQzFCLFdBQVcsQ0FBQzBCLFlBQVksQ0FBQyxJQUFFO2FBQ2pDO1lBRUQsSUFBSUQsVUFBVSxDQUFDLEVBQUUsS0FBSyxHQUFHO2dCQUNyQixJQUFJLENBQUN0QixhQUFhLEdBQUc7Z0JBQ3JCLElBQUksQ0FBQ29CLFVBQVUsR0FBRztnQkFDbEIsT0FBTztZQUNYO1lBQ0EsSUFBSSxDQUFDWixNQUFNLEdBQUdjLFVBQVUsQ0FBQyxFQUFFO1lBQzNCLElBQUksQ0FBQ25CLFVBQVUsR0FBR1g7UUFDdEI7SUFDSjtJQUVBLElBQUksSUFBSSxDQUFDVyxVQUFVLEtBQUtYLHNCQUFzQjtRQUMxQyxJQUFJLElBQUksQ0FBQzBCLElBQUksRUFBRTtZQUNYLElBQUlYLFdBQVdDLE1BQU0sSUFBSSxHQUFHO2dCQUN4QkQsV0FBV0UsUUFBUSxDQUFDLElBQUksQ0FBQ2IsU0FBUyxFQUFFLEdBQUcsR0FBRztnQkFDMUNXLFdBQVdHLE9BQU8sQ0FBQztnQkFDbkIsSUFBSSxDQUFDUCxVQUFVLEdBQUdWO1lBQ3RCO1FBQ0osT0FDSztZQUNELElBQUksQ0FBQ1UsVUFBVSxHQUFHVjtRQUN0QjtJQUNKO0lBRUEsSUFBSSxJQUFJLENBQUNVLFVBQVUsS0FBS1YscUJBQXFCO1FBQ3pDLElBQUksSUFBSSxDQUFDZSxNQUFNLEdBQUcsSUFBSSxDQUFDVCxvQkFBb0IsRUFBRTtZQUN6QyxJQUFJLENBQUNFLGFBQWEsR0FBRztZQUNyQixJQUFJLENBQUNtQixVQUFVLEdBQUcsbUJBQW1CLElBQUksQ0FBQ1osTUFBTSxDQUFDZ0IsUUFBUSxDQUFDLE1BQ3hDO1lBQ2xCLE9BQU87UUFDWDtRQUVBLElBQUksSUFBSSxDQUFDaEIsTUFBTSxLQUFLLEdBQUc7WUFDbkIsSUFBSSxDQUFDaUIsYUFBYSxHQUFHckMsa0JBQWtCO1lBQ3ZDLElBQUksQ0FBQ2UsVUFBVSxHQUFHVDtZQUNsQixPQUFPO1FBQ1g7UUFDQSxJQUFJYSxXQUFXQyxNQUFNLElBQUksSUFBSSxDQUFDQSxNQUFNLEVBQUU7WUFDbEMsSUFBSSxDQUFDaUIsYUFBYSxHQUFHbEIsV0FBV21CLElBQUksQ0FBQyxJQUFJLENBQUNsQixNQUFNO1lBQ2hERCxXQUFXRyxPQUFPLENBQUMsSUFBSSxDQUFDRixNQUFNO1lBQzlCLElBQUksSUFBSSxDQUFDVSxJQUFJLEVBQUU7Z0JBQ1hoQyxXQUFXeUMsTUFBTSxDQUFDLElBQUksQ0FBQ0YsYUFBYSxFQUFFLElBQUksQ0FBQzdCLFNBQVM7WUFDcEQsOENBQThDO1lBQ2xEO1lBRUEsSUFBSSxJQUFJLENBQUN1QixNQUFNLEtBQUssTUFBTTtnQkFDdEIsSUFBSSxJQUFJLENBQUNYLE1BQU0sS0FBSyxHQUFHO29CQUNuQixtRUFBbUU7b0JBQ25FLElBQUksQ0FBQ2lCLGFBQWEsR0FBR3JDLGtCQUFrQjtvQkFDdkMsSUFBSSxDQUFDYyx1QkFBdUIsR0FBRztnQkFDbkM7Z0JBQ0EsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSSxHQUFHO29CQUNsQixJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJLENBQUNxQixhQUFhLENBQUNKLFlBQVksQ0FBQztvQkFDbkQsSUFBSSxDQUFDSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLENBQUNHLEtBQUssQ0FBQztnQkFDbEQ7WUFDSjtZQUVBLElBQUksQ0FBQ3pCLFVBQVUsR0FBR1Q7WUFDbEIsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFQUMsZUFBZVUsU0FBUyxDQUFDd0IsZ0JBQWdCLEdBQUcsU0FBU3RCLFVBQVU7SUFDM0QsSUFBSUEsV0FBV0MsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1FBQ2xDRCxXQUFXRyxPQUFPLENBQUMsSUFBSSxDQUFDRixNQUFNO1FBQzlCLElBQUksQ0FBQ0wsVUFBVSxHQUFHVDtRQUNsQixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFFQUMsZUFBZVUsU0FBUyxDQUFDeUIsUUFBUSxHQUFHLFNBQVNDLFFBQVE7SUFDakQsSUFBSUM7SUFDSixJQUFJQyxlQUFlO0lBQ25CLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJeEIsWUFBWTtJQUNoQixJQUFJQyxhQUFhO0lBRWpCLElBQUksSUFBSSxDQUFDQyxHQUFHLEVBQUU7UUFDVkYsYUFBYTtJQUNqQjtJQUNBLElBQUksSUFBSSxDQUFDSSxJQUFJLEVBQUU7UUFDWEosYUFBYTtJQUNqQjtJQUNBLElBQUksSUFBSSxDQUFDSyxJQUFJLEVBQUU7UUFDWEwsYUFBYTtJQUNqQjtJQUNBLElBQUksSUFBSSxDQUFDTSxJQUFJLEVBQUU7UUFDWE4sYUFBYTtJQUNqQjtJQUNBLElBQUksSUFBSSxDQUFDTyxJQUFJLEVBQUU7UUFDWE4sY0FBYztJQUNsQjtJQUVBRCxhQUFjLElBQUksQ0FBQ1EsTUFBTSxHQUFHO0lBRTVCLGdFQUFnRTtJQUNoRSxpQ0FBaUM7SUFDakMsSUFBSSxJQUFJLENBQUNBLE1BQU0sS0FBSyxNQUFNO1FBQ3RCLElBQUksQ0FBQ1gsTUFBTSxHQUFHO1FBQ2QsSUFBSSxJQUFJLENBQUNpQixhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDakIsTUFBTSxJQUFJLElBQUksQ0FBQ2lCLGFBQWEsQ0FBQ2pCLE1BQU07UUFDNUM7UUFDQTBCLE9BQU85QyxrQkFBa0IsSUFBSSxDQUFDb0IsTUFBTTtRQUNwQzBCLEtBQUtFLGFBQWEsQ0FBQyxJQUFJLENBQUNoQyxXQUFXLEVBQUU7UUFDckMsSUFBSSxJQUFJLENBQUNJLE1BQU0sR0FBRyxHQUFHO1lBQ2pCLElBQUksQ0FBQ2lCLGFBQWEsQ0FBQ1ksSUFBSSxDQUFDSCxNQUFNO1FBQ2xDO0lBQ0osT0FDSyxJQUFJLElBQUksQ0FBQ1QsYUFBYSxFQUFFO1FBQ3pCUyxPQUFPLElBQUksQ0FBQ1QsYUFBYTtRQUN6QixJQUFJLENBQUNqQixNQUFNLEdBQUcwQixLQUFLMUIsTUFBTTtJQUM3QixPQUNLO1FBQ0QsSUFBSSxDQUFDQSxNQUFNLEdBQUc7SUFDbEI7SUFFQSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxJQUFJLEtBQUs7UUFDcEIsNERBQTREO1FBQzVESSxjQUFlLElBQUksQ0FBQ0osTUFBTSxHQUFHO0lBQ2pDLE9BQ0ssSUFBSSxJQUFJLENBQUNBLE1BQU0sR0FBRyxPQUFPLElBQUksQ0FBQ0EsTUFBTSxJQUFJLFFBQVE7UUFDakQsb0JBQW9CO1FBQ3BCSSxjQUFjO1FBQ2RxQixnQkFBZ0I7SUFDcEIsT0FDSyxJQUFJLElBQUksQ0FBQ3pCLE1BQU0sR0FBRyxRQUFRO1FBQzNCLG9CQUFvQjtRQUNwQkksY0FBYztRQUNkcUIsZ0JBQWdCO0lBQ3BCO0lBRUEsSUFBSUssU0FBU2xELGtCQUFrQixJQUFJLENBQUNvQixNQUFNLEdBQUd5QixlQUFnQixLQUFJLENBQUNmLElBQUksR0FBRyxJQUFJO0lBRTdFLHlCQUF5QjtJQUN6Qm9CLE1BQU0sQ0FBQyxFQUFFLEdBQUczQjtJQUNaMkIsTUFBTSxDQUFDLEVBQUUsR0FBRzFCO0lBRVp1QixZQUFZO0lBRVosSUFBSSxJQUFJLENBQUMzQixNQUFNLEdBQUcsT0FBTyxJQUFJLENBQUNBLE1BQU0sSUFBSSxRQUFRO1FBQzVDLHNCQUFzQjtRQUN0QjhCLE9BQU9GLGFBQWEsQ0FBQyxJQUFJLENBQUM1QixNQUFNLEVBQUUyQjtRQUNsQ0EsYUFBYTtJQUNqQixPQUNLLElBQUksSUFBSSxDQUFDM0IsTUFBTSxHQUFHLFFBQVE7UUFDM0Isc0JBQXNCO1FBQ3RCOEIsT0FBT0MsYUFBYSxDQUFDLFlBQVlKO1FBQ2pDRyxPQUFPQyxhQUFhLENBQUMsSUFBSSxDQUFDL0IsTUFBTSxFQUFFMkIsWUFBWTtRQUM5Q0EsYUFBYTtJQUNqQjtJQUVBLElBQUksSUFBSSxDQUFDakIsSUFBSSxFQUFFO1FBQ1hjLFVBQVVELFdBQVcsSUFBSyxLQUFNVSxNQUFNLEtBQUssZUFBZ0I7UUFDM0QsSUFBSSxDQUFDN0MsU0FBUyxDQUFDMkMsYUFBYSxDQUFDUCxTQUFTO1FBRXRDLHFCQUFxQjtRQUNyQixJQUFJLENBQUNwQyxTQUFTLENBQUN5QyxJQUFJLENBQUNDLFFBQVFIO1FBQzVCQSxhQUFhO1FBRWIsSUFBSUQsTUFBTTtZQUNSaEQsV0FBV2dDLElBQUksQ0FBQ2dCLE1BQU0sSUFBSSxDQUFDdEMsU0FBUyxFQUFFMEMsUUFBUUgsV0FBVyxJQUFJLENBQUMzQixNQUFNO1FBQ3RFO0lBQ0osT0FDSyxJQUFJMEIsTUFBTTtRQUNYQSxLQUFLRyxJQUFJLENBQUNDLFFBQVFIO0lBQ3RCO0lBRUEsT0FBT0c7QUFDWDtBQUVBM0MsZUFBZVUsU0FBUyxDQUFDbUIsUUFBUSxHQUFHO0lBQ2hDLE9BQU8sYUFBYSxJQUFJLENBQUNMLE1BQU0sR0FBRyxZQUFZLElBQUksQ0FBQ04sR0FBRyxHQUFHLGVBQWUsSUFBSSxDQUFDTCxNQUFNLEdBQUcsbUJBQW1CTSxRQUFRLElBQUksQ0FBQ1csYUFBYSxJQUFJLGVBQWUsSUFBSSxDQUFDUCxJQUFJO0FBQ25LO0FBR0F3QixPQUFPQyxPQUFPLEdBQUdoRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldEZyYW1lLmpzP2M2ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5idWZmZXJBbGxvY1Vuc2FmZTtcblxuY29uc3QgREVDT0RFX0hFQURFUiA9IDE7XG5jb25zdCBXQUlUSU5HX0ZPUl8xNl9CSVRfTEVOR1RIID0gMjtcbmNvbnN0IFdBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEggPSAzO1xuY29uc3QgV0FJVElOR19GT1JfTUFTS19LRVkgPSA0O1xuY29uc3QgV0FJVElOR19GT1JfUEFZTE9BRCA9IDU7XG5jb25zdCBDT01QTEVURSA9IDY7XG5cbi8vIFdlYlNvY2tldENvbm5lY3Rpb24gd2lsbCBwYXNzIHNoYXJlZCBidWZmZXIgb2JqZWN0cyBmb3IgbWFza0J5dGVzIGFuZFxuLy8gZnJhbWVIZWFkZXIgaW50byB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgdG9ucyBvZiBzbWFsbCBtZW1vcnkgYWxsb2NhdGlvbnNcbi8vIGZvciBlYWNoIGZyYW1lIHdlIGhhdmUgdG8gcGFyc2UuICBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgcGFyc2luZyBmcmFtZXNcbi8vIHdlIHJlY2VpdmUgb2ZmIHRoZSB3aXJlLlxuZnVuY3Rpb24gV2ViU29ja2V0RnJhbWUobWFza0J5dGVzLCBmcmFtZUhlYWRlciwgY29uZmlnKSB7XG4gICAgdGhpcy5tYXNrQnl0ZXMgPSBtYXNrQnl0ZXM7XG4gICAgdGhpcy5mcmFtZUhlYWRlciA9IGZyYW1lSGVhZGVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWF4UmVjZWl2ZWRGcmFtZVNpemUgPSBjb25maWcubWF4UmVjZWl2ZWRGcmFtZVNpemU7XG4gICAgdGhpcy5wcm90b2NvbEVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZVRvb0xhcmdlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCA9IGZhbHNlO1xuICAgIHRoaXMucGFyc2VTdGF0ZSA9IERFQ09ERV9IRUFERVI7XG4gICAgdGhpcy5jbG9zZVN0YXR1cyA9IC0xO1xufVxuXG5XZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUuYWRkRGF0YSA9IGZ1bmN0aW9uKGJ1ZmZlckxpc3QpIHtcbiAgICBpZiAodGhpcy5wYXJzZVN0YXRlID09PSBERUNPREVfSEVBREVSKSB7XG4gICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmpvaW5JbnRvKHRoaXMuZnJhbWVIZWFkZXIsIDAsIDAsIDIpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDIpO1xuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IHRoaXMuZnJhbWVIZWFkZXJbMF07XG4gICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IHRoaXMuZnJhbWVIZWFkZXJbMV07XG5cbiAgICAgICAgICAgIHRoaXMuZmluICAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4ODApO1xuICAgICAgICAgICAgdGhpcy5yc3YxICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHg0MCk7XG4gICAgICAgICAgICB0aGlzLnJzdjIgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDIwKTtcbiAgICAgICAgICAgIHRoaXMucnN2MyAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4MTApO1xuICAgICAgICAgICAgdGhpcy5tYXNrICAgID0gQm9vbGVhbihzZWNvbmRCeXRlICYgMHg4MCk7XG5cbiAgICAgICAgICAgIHRoaXMub3Bjb2RlICA9IGZpcnN0Qnl0ZSAgJiAweDBGO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBzZWNvbmRCeXRlICYgMHg3RjtcblxuICAgICAgICAgICAgLy8gQ29udHJvbCBmcmFtZSBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmICh0aGlzLm9wY29kZSA+PSAweDA4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMTI1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcFJlYXNvbiA9ICdJbGxlZ2FsIGNvbnRyb2wgZnJhbWUgbG9uZ2VyIHRoYW4gMTI1IGJ5dGVzLic7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmluKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcFJlYXNvbiA9ICdDb250cm9sIGZyYW1lcyBtdXN0IG5vdCBiZSBmcmFnbWVudGVkLic7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl8xNl9CSVRfTEVOR1RIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJzZVN0YXRlID09PSBXQUlUSU5HX0ZPUl8xNl9CSVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmpvaW5JbnRvKHRoaXMuZnJhbWVIZWFkZXIsIDIsIDAsIDIpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDIpO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmZyYW1lSGVhZGVyLnJlYWRVSW50MTZCRSgyKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX01BU0tfS0VZO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfNjRfQklUX0xFTkdUSCkge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gOCkge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAyLCAwLCA4KTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSg4KTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhQYWlyID0gW1xuICAgICAgICAgICAgICB0aGlzLmZyYW1lSGVhZGVyLnJlYWRVSW50MzJCRSgyKSxcbiAgICAgICAgICAgICAgdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDMyQkUoMis0KVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aFBhaXJbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcFJlYXNvbiA9ICdVbnN1cHBvcnRlZCA2NC1iaXQgbGVuZ3RoIGZyYW1lIHJlY2VpdmVkJztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoUGFpclsxXTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX01BU0tfS0VZO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfTUFTS19LRVkpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJMaXN0LmpvaW5JbnRvKHRoaXMubWFza0J5dGVzLCAwLCAwLCA0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfUEFZTE9BRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX1BBWUxPQUQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJzZVN0YXRlID09PSBXQUlUSU5HX0ZPUl9QQVlMT0FEKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZWRGcmFtZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVUb29MYXJnZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnRnJhbWUgc2l6ZSBvZiAnICsgdGhpcy5sZW5ndGgudG9TdHJpbmcoMTApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMgZXhjZWVkcyBtYXhpbXVtIGFjY2VwdGVkIGZyYW1lIHNpemUnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gQ09NUExFVEU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckxpc3QudGFrZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UodGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclV0aWwudW5tYXNrKHRoaXMuYmluYXJ5UGF5bG9hZCwgdGhpcy5tYXNrQnl0ZXMpO1xuICAgICAgICAgICAgICAgIC8vIHhvcih0aGlzLmJpbmFyeVBheWxvYWQsIHRoaXMubWFza0J5dGVzLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3Bjb2RlID09PSAweDA4KSB7IC8vIFdlYlNvY2tldE9wY29kZS5DT05ORUNUSU9OX0NMT1NFXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgbGVuZ3RoIGZvciBhIGNsb3NlIGZyYW1lLiAgTXVzdCBiZSB6ZXJvIG9yIGF0IGxlYXN0IHR3by5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5hcnlQYXlsb2FkID0gYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZENsb3NlRnJhbWVMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU3RhdHVzID0gdGhpcy5iaW5hcnlQYXlsb2FkLnJlYWRVSW50MTZCRSgwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5hcnlQYXlsb2FkID0gdGhpcy5iaW5hcnlQYXlsb2FkLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gQ09NUExFVEU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5XZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUudGhyb3dBd2F5UGF5bG9hZCA9IGZ1bmN0aW9uKGJ1ZmZlckxpc3QpIHtcbiAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gQ09NUExFVEU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5XZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihudWxsTWFzaykge1xuICAgIHZhciBtYXNrS2V5O1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSAyO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBvdXRwdXRQb3M7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IDB4MDA7XG4gICAgdmFyIHNlY29uZEJ5dGUgPSAweDAwO1xuXG4gICAgaWYgKHRoaXMuZmluKSB7XG4gICAgICAgIGZpcnN0Qnl0ZSB8PSAweDgwO1xuICAgIH1cbiAgICBpZiAodGhpcy5yc3YxKSB7XG4gICAgICAgIGZpcnN0Qnl0ZSB8PSAweDQwO1xuICAgIH1cbiAgICBpZiAodGhpcy5yc3YyKSB7XG4gICAgICAgIGZpcnN0Qnl0ZSB8PSAweDIwO1xuICAgIH1cbiAgICBpZiAodGhpcy5yc3YzKSB7XG4gICAgICAgIGZpcnN0Qnl0ZSB8PSAweDEwO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXNrKSB7XG4gICAgICAgIHNlY29uZEJ5dGUgfD0gMHg4MDtcbiAgICB9XG5cbiAgICBmaXJzdEJ5dGUgfD0gKHRoaXMub3Bjb2RlICYgMHgwRik7XG5cbiAgICAvLyB0aGUgY2xvc2UgZnJhbWUgaXMgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSB0aGUgY2xvc2UgcmVhc29uIGlzXG4gICAgLy8gcHJlcGVuZGVkIHRvIHRoZSBwYXlsb2FkIGRhdGEuXG4gICAgaWYgKHRoaXMub3Bjb2RlID09PSAweDA4KSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5UGF5bG9hZCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gdGhpcy5iaW5hcnlQYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gYnVmZmVyQWxsb2NVbnNhZmUodGhpcy5sZW5ndGgpO1xuICAgICAgICBkYXRhLndyaXRlVUludDE2QkUodGhpcy5jbG9zZVN0YXR1cywgMCk7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZC5jb3B5KGRhdGEsIDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuYmluYXJ5UGF5bG9hZCkge1xuICAgICAgICBkYXRhID0gdGhpcy5iaW5hcnlQYXlsb2FkO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSAxMjUpIHtcbiAgICAgICAgLy8gZW5jb2RlIHRoZSBsZW5ndGggZGlyZWN0bHkgaW50byB0aGUgdHdvLWJ5dGUgZnJhbWUgaGVhZGVyXG4gICAgICAgIHNlY29uZEJ5dGUgfD0gKHRoaXMubGVuZ3RoICYgMHg3Rik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMTI1ICYmIHRoaXMubGVuZ3RoIDw9IDB4RkZGRikge1xuICAgICAgICAvLyBVc2UgMTYtYml0IGxlbmd0aFxuICAgICAgICBzZWNvbmRCeXRlIHw9IDEyNjtcbiAgICAgICAgaGVhZGVyTGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMHhGRkZGKSB7XG4gICAgICAgIC8vIFVzZSA2NC1iaXQgbGVuZ3RoXG4gICAgICAgIHNlY29uZEJ5dGUgfD0gMTI3O1xuICAgICAgICBoZWFkZXJMZW5ndGggKz0gODtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gYnVmZmVyQWxsb2NVbnNhZmUodGhpcy5sZW5ndGggKyBoZWFkZXJMZW5ndGggKyAodGhpcy5tYXNrID8gNCA6IDApKTtcblxuICAgIC8vIHdyaXRlIHRoZSBmcmFtZSBoZWFkZXJcbiAgICBvdXRwdXRbMF0gPSBmaXJzdEJ5dGU7XG4gICAgb3V0cHV0WzFdID0gc2Vjb25kQnl0ZTtcblxuICAgIG91dHB1dFBvcyA9IDI7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxMjUgJiYgdGhpcy5sZW5ndGggPD0gMHhGRkZGKSB7XG4gICAgICAgIC8vIHdyaXRlIDE2LWJpdCBsZW5ndGhcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDE2QkUodGhpcy5sZW5ndGgsIG91dHB1dFBvcyk7XG4gICAgICAgIG91dHB1dFBvcyArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDB4RkZGRikge1xuICAgICAgICAvLyB3cml0ZSA2NC1iaXQgbGVuZ3RoXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKDB4MDAwMDAwMDAsIG91dHB1dFBvcyk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKHRoaXMubGVuZ3RoLCBvdXRwdXRQb3MgKyA0KTtcbiAgICAgICAgb3V0cHV0UG9zICs9IDg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICBtYXNrS2V5ID0gbnVsbE1hc2sgPyAwIDogKChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkZGRikgPj4+IDApO1xuICAgICAgICB0aGlzLm1hc2tCeXRlcy53cml0ZVVJbnQzMkJFKG1hc2tLZXksIDApO1xuXG4gICAgICAgIC8vIHdyaXRlIHRoZSBtYXNrIGtleVxuICAgICAgICB0aGlzLm1hc2tCeXRlcy5jb3B5KG91dHB1dCwgb3V0cHV0UG9zKTtcbiAgICAgICAgb3V0cHV0UG9zICs9IDQ7XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBidWZmZXJVdGlsLm1hc2soZGF0YSwgdGhpcy5tYXNrQnl0ZXMsIG91dHB1dCwgb3V0cHV0UG9zLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNvcHkob3V0cHV0LCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5XZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ09wY29kZTogJyArIHRoaXMub3Bjb2RlICsgJywgZmluOiAnICsgdGhpcy5maW4gKyAnLCBsZW5ndGg6ICcgKyB0aGlzLmxlbmd0aCArICcsIGhhc1BheWxvYWQ6ICcgKyBCb29sZWFuKHRoaXMuYmluYXJ5UGF5bG9hZCkgKyAnLCBtYXNrZWQ6ICcgKyB0aGlzLm1hc2s7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0RnJhbWU7XG4iXSwibmFtZXMiOlsiYnVmZmVyVXRpbCIsInJlcXVpcmUiLCJidWZmZXJBbGxvY1Vuc2FmZSIsIkRFQ09ERV9IRUFERVIiLCJXQUlUSU5HX0ZPUl8xNl9CSVRfTEVOR1RIIiwiV0FJVElOR19GT1JfNjRfQklUX0xFTkdUSCIsIldBSVRJTkdfRk9SX01BU0tfS0VZIiwiV0FJVElOR19GT1JfUEFZTE9BRCIsIkNPTVBMRVRFIiwiV2ViU29ja2V0RnJhbWUiLCJtYXNrQnl0ZXMiLCJmcmFtZUhlYWRlciIsImNvbmZpZyIsIm1heFJlY2VpdmVkRnJhbWVTaXplIiwicHJvdG9jb2xFcnJvciIsImZyYW1lVG9vTGFyZ2UiLCJpbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCIsInBhcnNlU3RhdGUiLCJjbG9zZVN0YXR1cyIsInByb3RvdHlwZSIsImFkZERhdGEiLCJidWZmZXJMaXN0IiwibGVuZ3RoIiwiam9pbkludG8iLCJhZHZhbmNlIiwiZmlyc3RCeXRlIiwic2Vjb25kQnl0ZSIsImZpbiIsIkJvb2xlYW4iLCJyc3YxIiwicnN2MiIsInJzdjMiLCJtYXNrIiwib3Bjb2RlIiwiZHJvcFJlYXNvbiIsInJlYWRVSW50MTZCRSIsImxlbmd0aFBhaXIiLCJyZWFkVUludDMyQkUiLCJ0b1N0cmluZyIsImJpbmFyeVBheWxvYWQiLCJ0YWtlIiwidW5tYXNrIiwic2xpY2UiLCJ0aHJvd0F3YXlQYXlsb2FkIiwidG9CdWZmZXIiLCJudWxsTWFzayIsIm1hc2tLZXkiLCJoZWFkZXJMZW5ndGgiLCJkYXRhIiwib3V0cHV0UG9zIiwid3JpdGVVSW50MTZCRSIsImNvcHkiLCJvdXRwdXQiLCJ3cml0ZVVJbnQzMkJFIiwiTWF0aCIsInJhbmRvbSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketFrame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/./node_modules/bufferutil/index.js\");\nvar bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n            this.fin = Boolean(firstByte & 0x80);\n            this.rsv1 = Boolean(firstByte & 0x40);\n            this.rsv2 = Boolean(firstByte & 0x20);\n            this.rsv3 = Boolean(firstByte & 0x10);\n            this.mask = Boolean(secondByte & 0x80);\n            this.opcode = firstByte & 0x0F;\n            this.length = secondByte & 0x7F;\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = \"Illegal control frame longer than 125 bytes.\";\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = \"Control frames must not be fragmented.\";\n                    return true;\n                }\n            }\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            } else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            } else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n                this.frameHeader.readUInt32BE(2),\n                this.frameHeader.readUInt32BE(2 + 4)\n            ];\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = \"Unsupported 64-bit length frame received\";\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        } else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = \"Frame size of \" + this.length.toString(10) + \" bytes exceeds maximum accepted frame size\";\n            return true;\n        }\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n            // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n            if (this.opcode === 0x08) {\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n    firstByte |= this.opcode & 0x0F;\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    } else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    } else {\n        this.length = 0;\n    }\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= this.length & 0x7F;\n    } else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    } else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n    outputPos = 2;\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    } else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n    if (this.mask) {\n        maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n        if (data) {\n            bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    } else if (data) {\n        data.copy(output, outputPos);\n    }\n    return output;\n};\nWebSocketFrame.prototype.toString = function() {\n    return \"Opcode: \" + this.opcode + \", fin: \" + this.fin + \", length: \" + this.length + \", hasPayload: \" + Boolean(this.binaryPayload) + \", masked: \" + this.mask;\n};\nmodule.exports = WebSocketFrame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLG9CQUFvQkQscUdBQW9DO0FBRTVELE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyw0QkFBNEI7QUFDbEMsTUFBTUMsNEJBQTRCO0FBQ2xDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsV0FBVztBQUVqQix3RUFBd0U7QUFDeEUsNkVBQTZFO0FBQzdFLHlFQUF5RTtBQUN6RSwyQkFBMkI7QUFDM0IsU0FBU0MsZUFBZUMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLE1BQU07SUFDbEQsSUFBSSxDQUFDRixTQUFTLEdBQUdBO0lBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDZCxJQUFJLENBQUNDLG9CQUFvQixHQUFHRCxPQUFPQyxvQkFBb0I7SUFDdkQsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRztJQUMvQixJQUFJLENBQUNDLFVBQVUsR0FBR2Q7SUFDbEIsSUFBSSxDQUFDZSxXQUFXLEdBQUcsQ0FBQztBQUN4QjtBQUVBVCxlQUFlVSxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxVQUFVO0lBQ2xELElBQUksSUFBSSxDQUFDSixVQUFVLEtBQUtkLGVBQWU7UUFDbkMsSUFBSWtCLFdBQVdDLE1BQU0sSUFBSSxHQUFHO1lBQ3hCRCxXQUFXRSxRQUFRLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsR0FBRyxHQUFHO1lBQzVDVSxXQUFXRyxPQUFPLENBQUM7WUFDbkIsSUFBSUMsWUFBWSxJQUFJLENBQUNkLFdBQVcsQ0FBQyxFQUFFO1lBQ25DLElBQUll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T0FBT0MsYUFBYSxDQUFDLElBQUksQ0FBQy9CLE1BQU0sRUFBRTJCLFlBQVk7UUFDOUNBLGFBQWE7SUFDakI7SUFFQSxJQUFJLElBQUksQ0FBQ2pCLElBQUksRUFBRTtRQUNYYyxVQUFVRCxXQUFXLElBQUssS0FBTVUsTUFBTSxLQUFLLGVBQWdCO1FBQzNELElBQUksQ0FBQzdDLFNBQVMsQ0FBQzJDLGFBQWEsQ0FBQ1AsU0FBUztRQUV0QyxxQkFBcUI7UUFDckIsSUFBSSxDQUFDcEMsU0FBUyxDQUFDeUMsSUFBSSxDQUFDQyxRQUFRSDtRQUM1QkEsYUFBYTtRQUViLElBQUlELE1BQU07WUFDUmhELFdBQVdnQyxJQUFJLENBQUNnQixNQUFNLElBQUksQ0FBQ3RDLFNBQVMsRUFBRTBDLFFBQVFILFdBQVcsSUFBSSxDQUFDM0IsTUFBTTtRQUN0RTtJQUNKLE9BQ0ssSUFBSTBCLE1BQU07UUFDWEEsS0FBS0csSUFBSSxDQUFDQyxRQUFRSDtJQUN0QjtJQUVBLE9BQU9HO0FBQ1g7QUFFQTNDLGVBQWVVLFNBQVMsQ0FBQ21CLFFBQVEsR0FBRztJQUNoQyxPQUFPLGFBQWEsSUFBSSxDQUFDTCxNQUFNLEdBQUcsWUFBWSxJQUFJLENBQUNOLEdBQUcsR0FBRyxlQUFlLElBQUksQ0FBQ0wsTUFBTSxHQUFHLG1CQUFtQk0sUUFBUSxJQUFJLENBQUNXLGFBQWEsSUFBSSxlQUFlLElBQUksQ0FBQ1AsSUFBSTtBQUNuSztBQUdBd0IsT0FBT0MsT0FBTyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcz9jNmYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSByZXF1aXJlKCcuL3V0aWxzJykuYnVmZmVyQWxsb2NVbnNhZmU7XG5cbmNvbnN0IERFQ09ERV9IRUFERVIgPSAxO1xuY29uc3QgV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCA9IDI7XG5jb25zdCBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIID0gMztcbmNvbnN0IFdBSVRJTkdfRk9SX01BU0tfS0VZID0gNDtcbmNvbnN0IFdBSVRJTkdfRk9SX1BBWUxPQUQgPSA1O1xuY29uc3QgQ09NUExFVEUgPSA2O1xuXG4vLyBXZWJTb2NrZXRDb25uZWN0aW9uIHdpbGwgcGFzcyBzaGFyZWQgYnVmZmVyIG9iamVjdHMgZm9yIG1hc2tCeXRlcyBhbmRcbi8vIGZyYW1lSGVhZGVyIGludG8gdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHRvbnMgb2Ygc21hbGwgbWVtb3J5IGFsbG9jYXRpb25zXG4vLyBmb3IgZWFjaCBmcmFtZSB3ZSBoYXZlIHRvIHBhcnNlLiAgVGhpcyBpcyBvbmx5IHVzZWQgZm9yIHBhcnNpbmcgZnJhbWVzXG4vLyB3ZSByZWNlaXZlIG9mZiB0aGUgd2lyZS5cbmZ1bmN0aW9uIFdlYlNvY2tldEZyYW1lKG1hc2tCeXRlcywgZnJhbWVIZWFkZXIsIGNvbmZpZykge1xuICAgIHRoaXMubWFza0J5dGVzID0gbWFza0J5dGVzO1xuICAgIHRoaXMuZnJhbWVIZWFkZXIgPSBmcmFtZUhlYWRlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplID0gY29uZmlnLm1heFJlY2VpdmVkRnJhbWVTaXplO1xuICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVUb29MYXJnZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52YWxpZENsb3NlRnJhbWVMZW5ndGggPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlU3RhdGUgPSBERUNPREVfSEVBREVSO1xuICAgIHRoaXMuY2xvc2VTdGF0dXMgPSAtMTtcbn1cblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gREVDT0RFX0hFQURFUikge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAwLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzBdO1xuICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzFdO1xuXG4gICAgICAgICAgICB0aGlzLmZpbiAgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDgwKTtcbiAgICAgICAgICAgIHRoaXMucnN2MSAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4NDApO1xuICAgICAgICAgICAgdGhpcy5yc3YyICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHgyMCk7XG4gICAgICAgICAgICB0aGlzLnJzdjMgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDEwKTtcbiAgICAgICAgICAgIHRoaXMubWFzayAgICA9IEJvb2xlYW4oc2Vjb25kQnl0ZSAmIDB4ODApO1xuXG4gICAgICAgICAgICB0aGlzLm9wY29kZSAgPSBmaXJzdEJ5dGUgICYgMHgwRjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gc2Vjb25kQnl0ZSAmIDB4N0Y7XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2wgZnJhbWUgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICBpZiAodGhpcy5vcGNvZGUgPj0gMHgwOCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnSWxsZWdhbCBjb250cm9sIGZyYW1lIGxvbmdlciB0aGFuIDEyNSBieXRlcy4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnQ29udHJvbCBmcmFtZXMgbXVzdCBub3QgYmUgZnJhZ21lbnRlZC4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxMjcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfTUFTS19LRVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCkge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAyLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDE2QkUoMik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5mcmFtZUhlYWRlciwgMiwgMCwgOCk7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoOCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGFpciA9IFtcbiAgICAgICAgICAgICAgdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDMyQkUoMiksXG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVIZWFkZXIucmVhZFVJbnQzMkJFKDIrNClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhQYWlyWzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnVW5zdXBwb3J0ZWQgNjQtYml0IGxlbmd0aCBmcmFtZSByZWNlaXZlZCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFBhaXJbMV07XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SX01BU0tfS0VZKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLm1hc2tCeXRlcywgMCwgMCwgNCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX1BBWUxPQUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9QQVlMT0FEO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfUEFZTE9BRCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVG9vTGFyZ2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ0ZyYW1lIHNpemUgb2YgJyArIHRoaXMubGVuZ3RoLnRvU3RyaW5nKDEwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzIGV4Y2VlZHMgbWF4aW11bSBhY2NlcHRlZCBmcmFtZSBzaXplJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJMaXN0LnRha2UodGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgICAgICBidWZmZXJVdGlsLnVubWFzayh0aGlzLmJpbmFyeVBheWxvYWQsIHRoaXMubWFza0J5dGVzKTtcbiAgICAgICAgICAgICAgICAvLyB4b3IodGhpcy5iaW5hcnlQYXlsb2FkLCB0aGlzLm1hc2tCeXRlcywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkgeyAvLyBXZWJTb2NrZXRPcGNvZGUuQ09OTkVDVElPTl9DTE9TRVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxlbmd0aCBmb3IgYSBjbG9zZSBmcmFtZS4gIE11c3QgYmUgemVybyBvciBhdCBsZWFzdCB0d28uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRDbG9zZUZyYW1lTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN0YXR1cyA9IHRoaXMuYmluYXJ5UGF5bG9hZC5yZWFkVUludDE2QkUoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IHRoaXMuYmluYXJ5UGF5bG9hZC5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRocm93QXdheVBheWxvYWQgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24obnVsbE1hc2spIHtcbiAgICB2YXIgbWFza0tleTtcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gMjtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3V0cHV0UG9zO1xuICAgIHZhciBmaXJzdEJ5dGUgPSAweDAwO1xuICAgIHZhciBzZWNvbmRCeXRlID0gMHgwMDtcblxuICAgIGlmICh0aGlzLmZpbikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg4MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2MSkge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg0MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgyMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mykge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgxMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICBzZWNvbmRCeXRlIHw9IDB4ODA7XG4gICAgfVxuXG4gICAgZmlyc3RCeXRlIHw9ICh0aGlzLm9wY29kZSAmIDB4MEYpO1xuXG4gICAgLy8gdGhlIGNsb3NlIGZyYW1lIGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgdGhlIGNsb3NlIHJlYXNvbiBpc1xuICAgIC8vIHByZXBlbmRlZCB0byB0aGUgcGF5bG9hZCBkYXRhLlxuICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRoaXMuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZGF0YS53cml0ZVVJbnQxNkJFKHRoaXMuY2xvc2VTdGF0dXMsIDApO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQuY29weShkYXRhLCAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuYmluYXJ5UGF5bG9hZDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gMTI1KSB7XG4gICAgICAgIC8vIGVuY29kZSB0aGUgbGVuZ3RoIGRpcmVjdGx5IGludG8gdGhlIHR3by1ieXRlIGZyYW1lIGhlYWRlclxuICAgICAgICBzZWNvbmRCeXRlIHw9ICh0aGlzLmxlbmd0aCAmIDB4N0YpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDEyNSAmJiB0aGlzLmxlbmd0aCA8PSAweEZGRkYpIHtcbiAgICAgICAgLy8gVXNlIDE2LWJpdCBsZW5ndGhcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAxMjY7XG4gICAgICAgIGhlYWRlckxlbmd0aCArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDB4RkZGRikge1xuICAgICAgICAvLyBVc2UgNjQtYml0IGxlbmd0aFxuICAgICAgICBzZWNvbmRCeXRlIHw9IDEyNztcbiAgICAgICAgaGVhZGVyTGVuZ3RoICs9IDg7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoICsgaGVhZGVyTGVuZ3RoICsgKHRoaXMubWFzayA/IDQgOiAwKSk7XG5cbiAgICAvLyB3cml0ZSB0aGUgZnJhbWUgaGVhZGVyXG4gICAgb3V0cHV0WzBdID0gZmlyc3RCeXRlO1xuICAgIG91dHB1dFsxXSA9IHNlY29uZEJ5dGU7XG5cbiAgICBvdXRwdXRQb3MgPSAyO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMTI1ICYmIHRoaXMubGVuZ3RoIDw9IDB4RkZGRikge1xuICAgICAgICAvLyB3cml0ZSAxNi1iaXQgbGVuZ3RoXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQxNkJFKHRoaXMubGVuZ3RoLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXRQb3MgKz0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPiAweEZGRkYpIHtcbiAgICAgICAgLy8gd3JpdGUgNjQtYml0IGxlbmd0aFxuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSgweDAwMDAwMDAwLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSh0aGlzLmxlbmd0aCwgb3V0cHV0UG9zICsgNCk7XG4gICAgICAgIG91dHB1dFBvcyArPSA4O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgbWFza0tleSA9IG51bGxNYXNrID8gMCA6ICgoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpID4+PiAwKTtcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMud3JpdGVVSW50MzJCRShtYXNrS2V5LCAwKTtcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWFzayBrZXlcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMuY29weShvdXRwdXQsIG91dHB1dFBvcyk7XG4gICAgICAgIG91dHB1dFBvcyArPSA0O1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgYnVmZmVyVXRpbC5tYXNrKGRhdGEsIHRoaXMubWFza0J5dGVzLCBvdXRwdXQsIG91dHB1dFBvcywgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jb3B5KG91dHB1dCwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdPcGNvZGU6ICcgKyB0aGlzLm9wY29kZSArICcsIGZpbjogJyArIHRoaXMuZmluICsgJywgbGVuZ3RoOiAnICsgdGhpcy5sZW5ndGggKyAnLCBoYXNQYXlsb2FkOiAnICsgQm9vbGVhbih0aGlzLmJpbmFyeVBheWxvYWQpICsgJywgbWFza2VkOiAnICsgdGhpcy5tYXNrO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldEZyYW1lO1xuIl0sIm5hbWVzIjpbImJ1ZmZlclV0aWwiLCJyZXF1aXJlIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJERUNPREVfSEVBREVSIiwiV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCIsIldBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEgiLCJXQUlUSU5HX0ZPUl9NQVNLX0tFWSIsIldBSVRJTkdfRk9SX1BBWUxPQUQiLCJDT01QTEVURSIsIldlYlNvY2tldEZyYW1lIiwibWFza0J5dGVzIiwiZnJhbWVIZWFkZXIiLCJjb25maWciLCJtYXhSZWNlaXZlZEZyYW1lU2l6ZSIsInByb3RvY29sRXJyb3IiLCJmcmFtZVRvb0xhcmdlIiwiaW52YWxpZENsb3NlRnJhbWVMZW5ndGgiLCJwYXJzZVN0YXRlIiwiY2xvc2VTdGF0dXMiLCJwcm90b3R5cGUiLCJhZGREYXRhIiwiYnVmZmVyTGlzdCIsImxlbmd0aCIsImpvaW5JbnRvIiwiYWR2YW5jZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJmaW4iLCJCb29sZWFuIiwicnN2MSIsInJzdjIiLCJyc3YzIiwibWFzayIsIm9wY29kZSIsImRyb3BSZWFzb24iLCJyZWFkVUludDE2QkUiLCJsZW5ndGhQYWlyIiwicmVhZFVJbnQzMkJFIiwidG9TdHJpbmciLCJiaW5hcnlQYXlsb2FkIiwidGFrZSIsInVubWFzayIsInNsaWNlIiwidGhyb3dBd2F5UGF5bG9hZCIsInRvQnVmZmVyIiwibnVsbE1hc2siLCJtYXNrS2V5IiwiaGVhZGVyTGVuZ3RoIiwiZGF0YSIsIm91dHB1dFBvcyIsIndyaXRlVUludDE2QkUiLCJjb3B5Iiwib3V0cHV0Iiwid3JpdGVVSW50MzJCRSIsIk1hdGgiLCJyYW5kb20iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(action-browser)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar controlChars = [\n    String.fromCharCode(127)\n];\nfor(var i = 0; i < 31; i++){\n    /* US-ASCII Control Characters */ controlChars.push(String.fromCharCode(i));\n}\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\nvar cookieSeparatorRegEx = /[;,] */;\nvar httpStatusDescriptions = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    200: \"OK\",\n    201: \"Created\",\n    203: \"Non-Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    307: \"Temporary Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authorization Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Long\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    426: \"Upgrade Required\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\"\n};\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [\n        this.remoteAddress\n    ];\n    this.serverConfig = serverConfig;\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on(\"end\", this._socketCloseHandler);\n    this.socket.on(\"close\", this._socketCloseHandler);\n    this._resolved = false;\n}\nutil.inherits(WebSocketRequest, EventEmitter);\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n    this.host = request.headers[\"host\"];\n    if (!this.host) {\n        throw new Error(\"Client must provide a Host header.\");\n    }\n    this.key = request.headers[\"sec-websocket-key\"];\n    if (!this.key) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Key.\");\n    }\n    this.webSocketVersion = parseInt(request.headers[\"sec-websocket-version\"], 10);\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Version.\");\n    }\n    switch(this.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error(\"Unsupported websocket client version: \" + this.webSocketVersion + \"Only versions 8 and 13 are supported.\");\n            e.httpCode = 426;\n            e.headers = {\n                \"Sec-WebSocket-Version\": \"13\"\n            };\n            throw e;\n    }\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers[\"origin\"];\n    } else if (this.webSocketVersion === 8) {\n        this.origin = request.headers[\"sec-websocket-origin\"];\n    }\n    // Protocol is optional.\n    var protocolString = request.headers[\"sec-websocket-protocol\"];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n    if (!this.serverConfig.ignoreXForwardedFor && request.headers[\"x-forwarded-for\"]) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers[\"x-forwarded-for\"].split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers[\"sec-websocket-extensions\"];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers[\"cookie\"];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split(\"=\");\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof str !== \"string\") {\n        return [];\n    }\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf(\"=\");\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n    return cookies;\n};\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n    // TODO: Handle extensions\n    var protocolFullCase;\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof protocolFullCase === \"undefined\") {\n            protocolFullCase = acceptedProtocol;\n        }\n    } else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n    // Create key validation hash\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var acceptKey = sha1.digest(\"base64\");\n    var response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" + \"Upgrade: websocket\\r\\n\" + \"Connection: Upgrade\\r\\n\" + \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\";\n    if (protocolFullCase) {\n        // validate protocol\n        for(var i = 0; i < protocolFullCase.length; i++){\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error(\"Specified protocol was not requested by the client.\");\n        }\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, \"\");\n        response += \"Sec-WebSocket-Protocol: \" + protocolFullCase + \"\\r\\n\";\n    }\n    this.requestedProtocols = null;\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, \"\");\n        if (this.webSocketVersion === 13) {\n            response += \"Origin: \" + allowedOrigin + \"\\r\\n\";\n        } else if (this.webSocketVersion === 8) {\n            response += \"Sec-WebSocket-Origin: \" + allowedOrigin + \"\\r\\n\";\n        }\n    }\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach((function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, \"\");\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, \"\");\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error(\"You may not specify the same cookie name twice.\");\n            }\n            seenCookies[cookie.name] = true;\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie name\");\n            }\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie value\");\n            }\n            var cookieParts = [\n                cookie.name + \"=\" + cookie.value\n            ];\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if (cookie.path) {\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie path\");\n                }\n                cookieParts.push(\"Path=\" + cookie.path);\n            }\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof cookie.domain !== \"string\") {\n                    this.reject(500);\n                    throw new Error(\"Domain must be specified and must be a string.\");\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie domain\");\n                }\n                cookieParts.push(\"Domain=\" + cookie.domain.toLowerCase());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push(\"Expires=\" + cookie.expires.toGMTString());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof maxage === \"string\") {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push(\"Max-Age=\" + maxage.toString(10));\n            }\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof cookie.secure !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push(\"Secure\");\n            }\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof cookie.httponly !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push(\"HttpOnly\");\n            }\n            response += \"Set-Cookie: \" + cookieParts.join(\";\") + \"\\r\\n\";\n        }).bind(this));\n    }\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    response += \"\\r\\n\";\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n    var self = this;\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    } else {\n        this.socket.write(response, \"ascii\", function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    if (typeof status !== \"number\") {\n        status = 403;\n    }\n    var response = \"HTTP/1.1 \" + status + \" \" + httpStatusDescriptions[status] + \"\\r\\n\" + \"Connection: close\\r\\n\";\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, \"\");\n        response += \"X-WebSocket-Reject-Reason: \" + reason + \"\\r\\n\";\n    }\n    if (extraHeaders) {\n        for(var key in extraHeaders){\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, \"\");\n            var sanitizedKey = key.replace(headerSanitizeRegExp, \"\");\n            response += sanitizedKey + \": \" + sanitizedValue + \"\\r\\n\";\n        }\n    }\n    response += \"\\r\\n\";\n    this.socket.end(response, \"ascii\");\n    this.emit(\"requestRejected\", this);\n};\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener(\"end\", this._socketCloseHandler);\n    this.socket.removeListener(\"close\", this._socketCloseHandler);\n};\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error(\"WebSocketRequest may only be accepted or rejected one time.\");\n    }\n};\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, \"TCP connection lost before handshake completed.\", true);\n    });\n}\nmodule.exports = WebSocketRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxNQUFNRixtQkFBT0EsQ0FBQztBQUNsQixJQUFJRyxlQUFlSCwwREFBOEI7QUFDakQsSUFBSUksc0JBQXNCSixtQkFBT0EsQ0FBQztBQUVsQyxJQUFJSyx5QkFBeUI7QUFDN0IsSUFBSUMseUJBQXlCO0FBQzdCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQywrQkFBK0I7QUFDbkMsSUFBSUMsYUFBYTtJQUNiO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDcEI7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUNyQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLQyxPQUFPQyxZQUFZLENBQUM7Q0FDdEM7QUFDRCxJQUFJQyxlQUFlO0lBQUNGLE9BQU9DLFlBQVksQ0FBQztDQUFlO0FBQ3ZELElBQUssSUFBSUUsSUFBRSxHQUFHQSxJQUFJLElBQUlBLElBQU07SUFDeEIsK0JBQStCLEdBQy9CRCxhQUFhRSxJQUFJLENBQUNKLE9BQU9DLFlBQVksQ0FBQ0U7QUFDMUM7QUFFQSxJQUFJRSwwQkFBMEI7QUFDOUIsSUFBSUMsMkJBQTJCO0FBQy9CLElBQUlDLGlDQUFpQztBQUNyQyxJQUFJQyxnQ0FBZ0M7QUFFcEMsSUFBSUMsdUJBQXVCO0FBRTNCLElBQUlDLHlCQUF5QjtJQUN6QixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFD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cEUsb0VBQW9FO0lBQ3BFLHVEQUF1RDtJQUN2RGEsUUFBUUMsUUFBUSxDQUFDO1FBQ2IsbURBQW1EO1FBQ25ELDZEQUE2RDtRQUM3RGQsV0FBV2UsSUFBSSxDQUFDLE1BQU0sbURBQW1EO0lBQzdFO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSZXF1ZXN0LmpzPzJiZTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Q29ubmVjdGlvbicpO1xuXG52YXIgaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCA9IC8sXFxzKi87XG52YXIgaGVhZGVyUGFyYW1TcGxpdFJlZ0V4cCA9IC87XFxzKi87XG52YXIgaGVhZGVyU2FuaXRpemVSZWdFeHAgPSAvW1xcclxcbl0vZztcbnZhciB4Rm9yd2FyZGVkRm9yU2VwYXJhdG9yUmVnRXhwID0gLyxcXHMqLztcbnZhciBzZXBhcmF0b3JzID0gW1xuICAgICcoJywgJyknLCAnPCcsICc+JywgJ0AnLFxuICAgICcsJywgJzsnLCAnOicsICdcXFxcJywgJ1xcXCInLFxuICAgICcvJywgJ1snLCAnXScsICc/JywgJz0nLFxuICAgICd7JywgJ30nLCAnICcsIFN0cmluZy5mcm9tQ2hhckNvZGUoOSlcbl07XG52YXIgY29udHJvbENoYXJzID0gW1N0cmluZy5mcm9tQ2hhckNvZGUoMTI3KSAvKiBERUwgKi9dO1xuZm9yICh2YXIgaT0wOyBpIDwgMzE7IGkgKyspIHtcbiAgICAvKiBVUy1BU0NJSSBDb250cm9sIENoYXJhY3RlcnMgKi9cbiAgICBjb250cm9sQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcbn1cblxudmFyIGNvb2tpZU5hbWVWYWxpZGF0ZVJlZ0V4ID0gLyhbXFx4MDAtXFx4MjBcXHgyMlxceDI4XFx4MjlcXHgyY1xceDJmXFx4M2EtXFx4M2ZcXHg0MFxceDViLVxceDVlXFx4N2JcXHg3ZFxceDdmXSkvO1xudmFyIGNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCA9IC9bXlxceDIxXFx4MjMtXFx4MmJcXHgyZC1cXHgzYVxceDNjLVxceDViXFx4NWQtXFx4N2VdLztcbnZhciBjb29raWVWYWx1ZURRdW90ZVZhbGlkYXRlUmVnRXggPSAvXlwiW15cIl0qXCIkLztcbnZhciBjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCA9IC9bXFx4MDAtXFx4MjBcXHgzYl0vZztcblxudmFyIGNvb2tpZVNlcGFyYXRvclJlZ0V4ID0gL1s7LF0gKi87XG5cbnZhciBodHRwU3RhdHVzRGVzY3JpcHRpb25zID0ge1xuICAgIDEwMDogJ0NvbnRpbnVlJyxcbiAgICAxMDE6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAyMDA6ICdPSycsXG4gICAgMjAxOiAnQ3JlYXRlZCcsXG4gICAgMjAzOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgIDIwNDogJ05vIENvbnRlbnQnLFxuICAgIDIwNTogJ1Jlc2V0IENvbnRlbnQnLFxuICAgIDIwNjogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgMzAwOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAgIDMwMjogJ0ZvdW5kJyxcbiAgICAzMDM6ICdTZWUgT3RoZXInLFxuICAgIDMwNDogJ05vdCBNb2RpZmllZCcsXG4gICAgMzA1OiAnVXNlIFByb3h5JyxcbiAgICAzMDc6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICAgIDQwMDogJ0JhZCBSZXF1ZXN0JyxcbiAgICA0MDE6ICdVbmF1dGhvcml6ZWQnLFxuICAgIDQwMjogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMzogJ0ZvcmJpZGRlbicsXG4gICAgNDA0OiAnTm90IEZvdW5kJyxcbiAgICA0MDY6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3OiAnUHJveHkgQXV0aG9yaXphdGlvbiBSZXF1aXJlZCcsXG4gICAgNDA4OiAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICA0MDk6ICdDb25mbGljdCcsXG4gICAgNDEwOiAnR29uZScsXG4gICAgNDExOiAnTGVuZ3RoIFJlcXVpcmVkJyxcbiAgICA0MTI6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcbiAgICA0MTM6ICdSZXF1ZXN0IEVudGl0eSBUb28gTG9uZycsXG4gICAgNDE0OiAnUmVxdWVzdC1VUkkgVG9vIExvbmcnLFxuICAgIDQxNTogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLFxuICAgIDQxNjogJ1JlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGUnLFxuICAgIDQxNzogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgNDI2OiAnVXBncmFkZSBSZXF1aXJlZCcsXG4gICAgNTAwOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDE6ICdOb3QgSW1wbGVtZW50ZWQnLFxuICAgIDUwMjogJ0JhZCBHYXRld2F5JyxcbiAgICA1MDM6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQ6ICdHYXRld2F5IFRpbWVvdXQnLFxuICAgIDUwNTogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJ1xufTtcblxuZnVuY3Rpb24gV2ViU29ja2V0UmVxdWVzdChzb2NrZXQsIGh0dHBSZXF1ZXN0LCBzZXJ2ZXJDb25maWcpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gICAgdGhpcy5yZXNvdXJjZSA9IGh0dHBSZXF1ZXN0LnVybDtcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3NlcyA9IFt0aGlzLnJlbW90ZUFkZHJlc3NdO1xuICAgIHRoaXMuc2VydmVyQ29uZmlnID0gc2VydmVyQ29uZmlnO1xuXG4gICAgLy8gV2F0Y2ggZm9yIHRoZSB1bmRlcmx5aW5nIFRDUCBzb2NrZXQgY2xvc2luZyBiZWZvcmUgd2UgY2FsbCBhY2NlcHRcbiAgICB0aGlzLl9zb2NrZXRJc0Nsb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVTb2NrZXRDbG9zZUJlZm9yZUFjY2VwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlbmQnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG5cbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFJlcXVlc3QsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLnJlYWRIYW5kc2hha2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLmh0dHBSZXF1ZXN0O1xuXG4gICAgLy8gRGVjb2RlIFVSTFxuICAgIHRoaXMucmVzb3VyY2VVUkwgPSB1cmwucGFyc2UodGhpcy5yZXNvdXJjZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmhvc3QgPSByZXF1ZXN0LmhlYWRlcnNbJ2hvc3QnXTtcbiAgICBpZiAoIXRoaXMuaG9zdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBtdXN0IHByb3ZpZGUgYSBIb3N0IGhlYWRlci4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG11c3QgcHJvdmlkZSBhIHZhbHVlIGZvciBTZWMtV2ViU29ja2V0LUtleS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLndlYlNvY2tldFZlcnNpb24gPSBwYXJzZUludChyZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddLCAxMCk7XG5cbiAgICBpZiAoIXRoaXMud2ViU29ja2V0VmVyc2lvbiB8fCBpc05hTih0aGlzLndlYlNvY2tldFZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG11c3QgcHJvdmlkZSBhIHZhbHVlIGZvciBTZWMtV2ViU29ja2V0LVZlcnNpb24uJyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLndlYlNvY2tldFZlcnNpb24pIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgd2Vic29ja2V0IGNsaWVudCB2ZXJzaW9uOiAnICsgdGhpcy53ZWJTb2NrZXRWZXJzaW9uICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdPbmx5IHZlcnNpb25zIDggYW5kIDEzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICBlLmh0dHBDb2RlID0gNDI2O1xuICAgICAgICAgICAgZS5oZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiAnMTMnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSAxMykge1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHJlcXVlc3QuaGVhZGVyc1snb3JpZ2luJ107XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gOCkge1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1vcmlnaW4nXTtcbiAgICB9XG5cbiAgICAvLyBQcm90b2NvbCBpcyBvcHRpb25hbC5cbiAgICB2YXIgcHJvdG9jb2xTdHJpbmcgPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICB0aGlzLnByb3RvY29sRnVsbENhc2VNYXAgPSB7fTtcbiAgICB0aGlzLnJlcXVlc3RlZFByb3RvY29scyA9IFtdO1xuICAgIGlmIChwcm90b2NvbFN0cmluZykge1xuICAgICAgICB2YXIgcmVxdWVzdGVkUHJvdG9jb2xzRnVsbENhc2UgPSBwcm90b2NvbFN0cmluZy5zcGxpdChoZWFkZXJWYWx1ZVNwbGl0UmVnRXhwKTtcbiAgICAgICAgcmVxdWVzdGVkUHJvdG9jb2xzRnVsbENhc2UuZm9yRWFjaChmdW5jdGlvbihwcm90b2NvbCkge1xuICAgICAgICAgICAgdmFyIGxjUHJvdG9jb2wgPSBwcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ZWRQcm90b2NvbHMucHVzaChsY1Byb3RvY29sKTtcbiAgICAgICAgICAgIHNlbGYucHJvdG9jb2xGdWxsQ2FzZU1hcFtsY1Byb3RvY29sXSA9IHByb3RvY29sO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2VydmVyQ29uZmlnLmlnbm9yZVhGb3J3YXJkZWRGb3IgJiZcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXSkge1xuICAgICAgICB2YXIgaW1tZWRpYXRlUGVlcklQID0gdGhpcy5yZW1vdGVBZGRyZXNzO1xuICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3NlcyA9IHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ11cbiAgICAgICAgICAgIC5zcGxpdCh4Rm9yd2FyZGVkRm9yU2VwYXJhdG9yUmVnRXhwKTtcbiAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzZXMucHVzaChpbW1lZGlhdGVQZWVySVApO1xuICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB0aGlzLnJlbW90ZUFkZHJlc3Nlc1swXTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbnNpb25zIGFyZSBvcHRpb25hbC5cbiAgICBpZiAodGhpcy5zZXJ2ZXJDb25maWcucGFyc2VFeHRlbnNpb25zKSB7XG4gICAgICAgIHZhciBleHRlbnNpb25zU3RyaW5nID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRFeHRlbnNpb25zID0gdGhpcy5wYXJzZUV4dGVuc2lvbnMoZXh0ZW5zaW9uc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRFeHRlbnNpb25zID0gW107XG4gICAgfVxuXG4gICAgLy8gQ29va2llcyBhcmUgb3B0aW9uYWxcbiAgICBpZiAodGhpcy5zZXJ2ZXJDb25maWcucGFyc2VDb29raWVzKSB7XG4gICAgICAgIHZhciBjb29raWVTdHJpbmcgPSByZXF1ZXN0LmhlYWRlcnNbJ2Nvb2tpZSddO1xuICAgICAgICB0aGlzLmNvb2tpZXMgPSB0aGlzLnBhcnNlQ29va2llcyhjb29raWVTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29va2llcyA9IFtdO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLnBhcnNlRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKGV4dGVuc2lvbnNTdHJpbmcpIHtcbiAgICBpZiAoIWV4dGVuc2lvbnNTdHJpbmcgfHwgZXh0ZW5zaW9uc1N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNTdHJpbmcudG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdChoZWFkZXJWYWx1ZVNwbGl0UmVnRXhwKTtcbiAgICBleHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZXh0ZW5zaW9uLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV4dGVuc2lvbi5zcGxpdChoZWFkZXJQYXJhbVNwbGl0UmVnRXhwKTtcbiAgICAgICAgdmFyIGV4dGVuc2lvbk5hbWUgPSBwYXJhbXNbMF07XG4gICAgICAgIHZhciBleHRlbnNpb25QYXJhbXMgPSBwYXJhbXMuc2xpY2UoMSk7XG4gICAgICAgIGV4dGVuc2lvblBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHJhd1BhcmFtLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSByYXdQYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhcnJbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyclsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgb2JqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb25OYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBleHRlbnNpb25QYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCBvYmopO1xuICAgIH0pO1xuICAgIHJldHVybiBleHRlbnNpb25zO1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBhZGFwdGVkIGZyb20gbm9kZS1jb29raWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaHR5bG1hbi9ub2RlLWNvb2tpZVxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucGFyc2VDb29raWVzID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgLy8gU2FuaXR5IENoZWNrXG4gICAgaWYgKCFzdHIgfHwgdHlwZW9mKHN0cikgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29va2llcyA9IFtdO1xuICAgIHZhciBwYWlycyA9IHN0ci5zcGxpdChjb29raWVTZXBhcmF0b3JSZWdFeCk7XG5cbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIGVxX2lkeCA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgICAgICBpZiAoZXFfaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgY29va2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYWlyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSBwYWlyLnN1YnN0cigwLCBlcV9pZHgpLnRyaW0oKTtcbiAgICAgICAgdmFyIHZhbCA9IHBhaXIuc3Vic3RyKCsrZXFfaWR4LCBwYWlyLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgICAgIC8vIHF1b3RlZCB2YWx1ZXNcbiAgICAgICAgaWYgKCdcIicgPT09IHZhbFswXSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb2tpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogZGVjb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29va2llcztcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKGFjY2VwdGVkUHJvdG9jb2wsIGFsbG93ZWRPcmlnaW4sIGNvb2tpZXMpIHtcbiAgICB0aGlzLl92ZXJpZnlSZXNvbHV0aW9uKCk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgZXh0ZW5zaW9uc1xuXG4gICAgdmFyIHByb3RvY29sRnVsbENhc2U7XG5cbiAgICBpZiAoYWNjZXB0ZWRQcm90b2NvbCkge1xuICAgICAgICBwcm90b2NvbEZ1bGxDYXNlID0gdGhpcy5wcm90b2NvbEZ1bGxDYXNlTWFwW2FjY2VwdGVkUHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKV07XG4gICAgICAgIGlmICh0eXBlb2YocHJvdG9jb2xGdWxsQ2FzZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwcm90b2NvbEZ1bGxDYXNlID0gYWNjZXB0ZWRQcm90b2NvbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IGFjY2VwdGVkUHJvdG9jb2w7XG4gICAgfVxuICAgIHRoaXMucHJvdG9jb2xGdWxsQ2FzZU1hcCA9IG51bGw7XG5cbiAgICAvLyBDcmVhdGUga2V5IHZhbGlkYXRpb24gaGFzaFxuICAgIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBzaGExLnVwZGF0ZSh0aGlzLmtleSArICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnKTtcbiAgICB2YXIgYWNjZXB0S2V5ID0gc2hhMS5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgdmFyIHJlc3BvbnNlID0gJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldFxcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAgJ1NlYy1XZWJTb2NrZXQtQWNjZXB0OiAnICsgYWNjZXB0S2V5ICsgJ1xcclxcbic7XG5cbiAgICBpZiAocHJvdG9jb2xGdWxsQ2FzZSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSBwcm90b2NvbFxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwcm90b2NvbEZ1bGxDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwcm90b2NvbEZ1bGxDYXNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gcHJvdG9jb2xGdWxsQ2FzZS5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDIxIHx8IGNoYXJDb2RlID4gMHg3RSB8fCBzZXBhcmF0b3JzLmluZGV4T2YoY2hhcmFjdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgXCInICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyYWN0ZXIpICsgJ1wiIGluIHN1YnByb3RvY29sLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RlZFByb3RvY29scy5pbmRleE9mKGFjY2VwdGVkUHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3BlY2lmaWVkIHByb3RvY29sIHdhcyBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b2NvbEZ1bGxDYXNlID0gcHJvdG9jb2xGdWxsQ2FzZS5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgIHJlc3BvbnNlICs9ICdTZWMtV2ViU29ja2V0LVByb3RvY29sOiAnICsgcHJvdG9jb2xGdWxsQ2FzZSArICdcXHJcXG4nO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RlZFByb3RvY29scyA9IG51bGw7XG5cbiAgICBpZiAoYWxsb3dlZE9yaWdpbikge1xuICAgICAgICBhbGxvd2VkT3JpZ2luID0gYWxsb3dlZE9yaWdpbi5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDEzKSB7XG4gICAgICAgICAgICByZXNwb25zZSArPSAnT3JpZ2luOiAnICsgYWxsb3dlZE9yaWdpbiArICdcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gOCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgKz0gJ1NlYy1XZWJTb2NrZXQtT3JpZ2luOiAnICsgYWxsb3dlZE9yaWdpbiArICdcXHJcXG4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb2tpZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgXCJjb29raWVzXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VlbkNvb2tpZXMgPSB7fTtcbiAgICAgICAgY29va2llcy5mb3JFYWNoKGZ1bmN0aW9uKGNvb2tpZSkge1xuICAgICAgICAgICAgaWYgKCFjb29raWUubmFtZSB8fCAhY29va2llLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VhY2ggY29va2llIHRvIHNldCBtdXN0IGF0IGxlYXN0IHByb3ZpZGUgYSBcIm5hbWVcIiBhbmQgXCJ2YWx1ZVwiJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gXFxyXFxuIHNlcXVlbmNlcyBpbnNlcnRlZFxuICAgICAgICAgICAgY29va2llLm5hbWUgPSBjb29raWUubmFtZS5yZXBsYWNlKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4LCAnJyk7XG4gICAgICAgICAgICBjb29raWUudmFsdWUgPSBjb29raWUudmFsdWUucmVwbGFjZShjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCwgJycpO1xuXG4gICAgICAgICAgICBpZiAoc2VlbkNvb2tpZXNbY29va2llLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IHNwZWNpZnkgdGhlIHNhbWUgY29va2llIG5hbWUgdHdpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuQ29va2llc1tjb29raWUubmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB0b2tlbiAoUkZDIDI2MTYsIFNlY3Rpb24gMi4yKVxuICAgICAgICAgICAgdmFyIGludmFsaWRDaGFyID0gY29va2llLm5hbWUubWF0Y2goY29va2llTmFtZVZhbGlkYXRlUmVnRXgpO1xuICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyICcgKyBpbnZhbGlkQ2hhclswXSArICcgaW4gY29va2llIG5hbWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApIHwgJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAgICAgICAgICAgIGlmIChjb29raWUudmFsdWUubWF0Y2goY29va2llVmFsdWVEUXVvdGVWYWxpZGF0ZVJlZ0V4KSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLnZhbHVlLnNsaWNlKDEsIC0xKS5tYXRjaChjb29raWVWYWx1ZVZhbGlkYXRlUmVnRXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS52YWx1ZS5tYXRjaChjb29raWVWYWx1ZVZhbGlkYXRlUmVnRXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyICcgKyBpbnZhbGlkQ2hhclswXSArICcgaW4gY29va2llIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb29raWVQYXJ0cyA9IFtjb29raWUubmFtZSArICc9JyArIGNvb2tpZS52YWx1ZV07XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLyAnUGF0aD0nIHBhdGgtdmFsdWUgfCA8YW55IENIQVIgZXhjZXB0IENUTHMgb3IgJzsnPlxuICAgICAgICAgICAgaWYoY29va2llLnBhdGgpe1xuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLnBhdGgubWF0Y2goY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgpO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyICcgKyBpbnZhbGlkQ2hhclswXSArICcgaW4gY29va2llIHBhdGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnUGF0aD0nICsgY29va2llLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMi4zXG4gICAgICAgICAgICAvLyAnRG9tYWluPScgc3ViZG9tYWluXG4gICAgICAgICAgICBpZiAoY29va2llLmRvbWFpbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29va2llLmRvbWFpbikgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRG9tYWluIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS5kb21haW4ubWF0Y2goY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgpO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyICcgKyBpbnZhbGlkQ2hhclswXSArICcgaW4gY29va2llIGRvbWFpbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdEb21haW49JyArIGNvb2tpZS5kb21haW4udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLydFeHBpcmVzPScgc2FuZS1jb29raWUtZGF0ZSB8IEZvcmNlIERhdGUgb2JqZWN0IHJlcXVpcmVtZW50IGJ5IHVzaW5nIG9ubHkgZXBvY2hcbiAgICAgICAgICAgIGlmIChjb29raWUuZXhwaXJlcykge1xuICAgICAgICAgICAgICAgIGlmICghKGNvb2tpZS5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJleHBpcmVzXCIgbXVzdCBiZSBhIHZhaWxkIGRhdGUgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ0V4cGlyZXM9JyArIGNvb2tpZS5leHBpcmVzLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nTWF4LUFnZT0nIG5vbi16ZXJvLWRpZ2l0ICpESUdJVFxuICAgICAgICAgICAgaWYgKGNvb2tpZS5tYXhhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4YWdlID0gY29va2llLm1heGFnZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKG1heGFnZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heGFnZSA9IHBhcnNlSW50KG1heGFnZSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWF4YWdlKSB8fCBtYXhhZ2UgPD0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgY29va2llIFwibWF4YWdlXCIgbXVzdCBiZSBhIG5vbi16ZXJvIG51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhhZ2UgPSBNYXRoLnJvdW5kKG1heGFnZSk7XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnTWF4LUFnZT0nICsgbWF4YWdlLnRvU3RyaW5nKDEwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLydTZWN1cmU7J1xuICAgICAgICAgICAgaWYgKGNvb2tpZS5zZWN1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvb2tpZS5zZWN1cmUpICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgY29va2llIFwic2VjdXJlXCIgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnU2VjdXJlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLydIdHRwT25seTsnXG4gICAgICAgICAgICBpZiAoY29va2llLmh0dHBvbmx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb29raWUuaHR0cG9ubHkpICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgY29va2llIFwiaHR0cG9ubHlcIiBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdIdHRwT25seScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZSArPSAoJ1NldC1Db29raWU6ICcgKyBjb29raWVQYXJ0cy5qb2luKCc7JykgKyAnXFxyXFxuJyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogaGFuZGxlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgIC8vIGlmIChuZWdvdGlhdGVkRXh0ZW5zaW9ucykge1xuICAgIC8vICAgICByZXNwb25zZSArPSAnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAnICsgbmVnb3RpYXRlZEV4dGVuc2lvbnMuam9pbignLCAnKSArICdcXHJcXG4nO1xuICAgIC8vIH1cblxuICAgIC8vIE1hcmsgdGhlIHJlcXVlc3QgcmVzb2x2ZWQgbm93IHNvIHRoYXQgdGhlIHVzZXIgY2FuJ3QgY2FsbCBhY2NlcHQgb3JcbiAgICAvLyByZWplY3QgYSBzZWNvbmQgdGltZS5cbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVzb2x2ZWQnLCB0aGlzKTtcblxuICAgIHJlc3BvbnNlICs9ICdcXHJcXG4nO1xuXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLnNvY2tldCwgW10sIGFjY2VwdGVkUHJvdG9jb2wsIGZhbHNlLCB0aGlzLnNlcnZlckNvbmZpZyk7XG4gICAgY29ubmVjdGlvbi53ZWJTb2NrZXRWZXJzaW9uID0gdGhpcy53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIGNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyA9IHRoaXMucmVtb3RlQWRkcmVzcztcbiAgICBjb25uZWN0aW9uLnJlbW90ZUFkZHJlc3NlcyA9IHRoaXMucmVtb3RlQWRkcmVzc2VzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX3NvY2tldElzQ2xvc2luZykge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRoZSBjbGllbnQgaGFuZ3MgdXAgYmVmb3JlIHdlIGdldCBhIGNoYW5jZSB0b1xuICAgICAgICAvLyBhY2NlcHQgdGhlIGNvbm5lY3Rpb24gYW5kIHNlbmQgb3VyIHNpZGUgb2YgdGhlIG9wZW5pbmcgaGFuZHNoYWtlLlxuICAgICAgICBjbGVhbnVwRmFpbGVkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKHJlc3BvbnNlLCAnYXNjaWknLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cEZhaWxlZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5fYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0QWNjZXB0ZWQnLCBjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHN0YXR1cywgcmVhc29uLCBleHRyYUhlYWRlcnMpIHtcbiAgICB0aGlzLl92ZXJpZnlSZXNvbHV0aW9uKCk7XG5cbiAgICAvLyBNYXJrIHRoZSByZXF1ZXN0IHJlc29sdmVkIG5vdyBzbyB0aGF0IHRoZSB1c2VyIGNhbid0IGNhbGwgYWNjZXB0IG9yXG4gICAgLy8gcmVqZWN0IGEgc2Vjb25kIHRpbWUuXG4gICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlc29sdmVkJywgdGhpcyk7XG5cbiAgICBpZiAodHlwZW9mKHN0YXR1cykgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YXR1cyA9IDQwMztcbiAgICB9XG4gICAgdmFyIHJlc3BvbnNlID0gJ0hUVFAvMS4xICcgKyBzdGF0dXMgKyAnICcgKyBodHRwU3RhdHVzRGVzY3JpcHRpb25zW3N0YXR1c10gKyAnXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJztcbiAgICBpZiAocmVhc29uKSB7XG4gICAgICAgIHJlYXNvbiA9IHJlYXNvbi5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgIHJlc3BvbnNlICs9ICdYLVdlYlNvY2tldC1SZWplY3QtUmVhc29uOiAnICsgcmVhc29uICsgJ1xcclxcbic7XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhSGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBleHRyYUhlYWRlcnNba2V5XS50b1N0cmluZygpLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRLZXkgPSBrZXkucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgcmVzcG9uc2UgKz0gKHNhbml0aXplZEtleSArICc6ICcgKyBzYW5pdGl6ZWRWYWx1ZSArICdcXHJcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3BvbnNlICs9ICdcXHJcXG4nO1xuICAgIHRoaXMuc29ja2V0LmVuZChyZXNwb25zZSwgJ2FzY2lpJyk7XG5cbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZWplY3RlZCcsIHRoaXMpO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuX2hhbmRsZVNvY2tldENsb3NlQmVmb3JlQWNjZXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc29ja2V0SXNDbG9zaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLl92ZXJpZnlSZXNvbHV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0UmVxdWVzdCBtYXkgb25seSBiZSBhY2NlcHRlZCBvciByZWplY3RlZCBvbmUgdGltZS4nKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjbGVhbnVwRmFpbGVkQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgLy8gU2luY2Ugd2UgaGF2ZSB0byByZXR1cm4gYSBjb25uZWN0aW9uIG9iamVjdCBldmVuIGlmIHRoZSBzb2NrZXQgaXNcbiAgICAvLyBhbHJlYWR5IGRlYWQgaW4gb3JkZXIgbm90IHRvIGJyZWFrIHRoZSBBUEksIHdlIHNjaGVkdWxlIGEgJ2Nsb3NlJ1xuICAgIC8vIGV2ZW50IG9uIHRoZSBjb25uZWN0aW9uIG9iamVjdCB0byBvY2N1ciBpbW1lZGlhdGVseS5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTCA9IDEwMDZcbiAgICAgICAgLy8gVGhpcmQgcGFyYW06IFNraXAgc2VuZGluZyB0aGUgY2xvc2UgZnJhbWUgdG8gYSBkZWFkIHNvY2tldFxuICAgICAgICBjb25uZWN0aW9uLmRyb3AoMTAwNiwgJ1RDUCBjb25uZWN0aW9uIGxvc3QgYmVmb3JlIGhhbmRzaGFrZSBjb21wbGV0ZWQuJywgdHJ1ZSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0UmVxdWVzdDtcbiJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwidXRpbCIsInVybCIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldENvbm5lY3Rpb24iLCJoZWFkZXJWYWx1ZVNwbGl0UmVnRXhwIiwiaGVhZGVyUGFyYW1TcGxpdFJlZ0V4cCIsImhlYWRlclNhbml0aXplUmVnRXhwIiwieEZvcndhcmRlZEZvclNlcGFyYXRvclJlZ0V4cCIsInNlcGFyYXRvcnMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjb250cm9sQ2hhcnMiLCJpIiwicHVzaCIsImNvb2tpZU5hbWVWYWxpZGF0ZVJlZ0V4IiwiY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4IiwiY29va2llVmFsdWVEUXVvdGVWYWxpZGF0ZVJlZ0V4IiwiY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgiLCJjb29raWVTZXBhcmF0b3JSZWdFeCIsImh0dHBTdGF0dXNEZXNjcmlwdGlvbnMiLCJXZWJTb2NrZXRSZXF1ZXN0Iiwic29ja2V0IiwiaHR0cFJlcXVlc3QiLCJzZXJ2ZXJDb25maWciLCJjYWxsIiwicmVzb3VyY2UiLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlQWRkcmVzc2VzIiwiX3NvY2tldElzQ2xvc2luZyIsIl9zb2NrZXRDbG9zZUhhbmRsZXIiLCJfaGFuZGxlU29ja2V0Q2xvc2VCZWZvcmVBY2NlcHQiLCJiaW5kIiwib24iLCJfcmVzb2x2ZWQiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInJlYWRIYW5kc2hha2UiLCJzZWxmIiwicmVxdWVzdCIsInJlc291cmNlVVJMIiwicGFyc2UiLCJob3N0IiwiaGVhZGVycyIsIkVycm9yIiwia2V5Iiwid2ViU29ja2V0VmVyc2lvbiIsInBhcnNlSW50IiwiaXNOYU4iLCJlIiwiaHR0cENvZGUiLCJvcmlnaW4iLCJwcm90b2NvbFN0cmluZyIsInByb3RvY29sRnVsbENhc2VNYXAiLCJyZXF1ZXN0ZWRQcm90b2NvbHMiLCJyZXF1ZXN0ZWRQcm90b2NvbHNGdWxsQ2FzZSIsInNwbGl0IiwiZm9yRWFjaCIsInByb3RvY29sIiwibGNQcm90b2NvbCIsInRvTG9jYWxlTG93ZXJDYXNlIiwiaWdub3JlWEZvcndhcmRlZEZvciIsImltbWVkaWF0ZVBlZXJJUCIsInBhcnNlRXh0ZW5zaW9ucyIsImV4dGVuc2lvbnNTdHJpbmciLCJyZXF1ZXN0ZWRFeHRlbnNpb25zIiwicGFyc2VDb29raWVzIiwiY29va2llU3RyaW5nIiwiY29va2llcyIsImxlbmd0aCIsImV4dGVuc2lvbnMiLCJleHRlbnNpb24iLCJpbmRleCIsImFycmF5IiwicGFyYW1zIiwiZXh0ZW5zaW9uTmFtZSIsImV4dGVuc2lvblBhcmFtcyIsInNsaWNlIiwicmF3UGFyYW0iLCJhcnIiLCJvYmoiLCJuYW1lIiwidmFsdWUiLCJzcGxpY2UiLCJzdHIiLCJwYWlycyIsInBhaXIiLCJlcV9pZHgiLCJpbmRleE9mIiwic3Vic3RyIiwidHJpbSIsInZhbCIsImRlY29kZVVSSUNvbXBvbmVudCIsImFjY2VwdCIsImFjY2VwdGVkUHJvdG9jb2wiLCJhbGxvd2VkT3JpZ2luIiwiX3ZlcmlmeVJlc29sdXRpb24iLCJwcm90b2NvbEZ1bGxDYXNlIiwic2hhMSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJhY2NlcHRLZXkiLCJkaWdlc3QiLCJyZXNwb25zZSIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImNoYXJhY3RlciIsImNoYXJBdCIsInJlamVjdCIsInJlcGxhY2UiLCJBcnJheSIsImlzQXJyYXkiLCJzZWVuQ29va2llcyIsImNvb2tpZSIsImludmFsaWRDaGFyIiwibWF0Y2giLCJjb29raWVQYXJ0cyIsInBhdGgiLCJkb21haW4iLCJ0b0xvd2VyQ2FzZSIsImV4cGlyZXMiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJtYXhhZ2UiLCJNYXRoIiwicm91bmQiLCJ0b1N0cmluZyIsInNlY3VyZSIsImh0dHBvbmx5Iiwiam9pbiIsImVtaXQiLCJjb25uZWN0aW9uIiwiY2xlYW51cEZhaWxlZENvbm5lY3Rpb24iLCJ3cml0ZSIsImVycm9yIiwiX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzIiwiX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzIiwic3RhdHVzIiwicmVhc29uIiwiZXh0cmFIZWFkZXJzIiwic2FuaXRpemVkVmFsdWUiLCJzYW5pdGl6ZWRLZXkiLCJlbmQiLCJyZW1vdmVMaXN0ZW5lciIsInByb2Nlc3MiLCJuZXh0VGljayIsImRyb3AiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketRequest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar controlChars = [\n    String.fromCharCode(127)\n];\nfor(var i = 0; i < 31; i++){\n    /* US-ASCII Control Characters */ controlChars.push(String.fromCharCode(i));\n}\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\nvar cookieSeparatorRegEx = /[;,] */;\nvar httpStatusDescriptions = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    200: \"OK\",\n    201: \"Created\",\n    203: \"Non-Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    307: \"Temporary Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authorization Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Long\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    426: \"Upgrade Required\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\"\n};\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [\n        this.remoteAddress\n    ];\n    this.serverConfig = serverConfig;\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on(\"end\", this._socketCloseHandler);\n    this.socket.on(\"close\", this._socketCloseHandler);\n    this._resolved = false;\n}\nutil.inherits(WebSocketRequest, EventEmitter);\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n    this.host = request.headers[\"host\"];\n    if (!this.host) {\n        throw new Error(\"Client must provide a Host header.\");\n    }\n    this.key = request.headers[\"sec-websocket-key\"];\n    if (!this.key) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Key.\");\n    }\n    this.webSocketVersion = parseInt(request.headers[\"sec-websocket-version\"], 10);\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Version.\");\n    }\n    switch(this.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error(\"Unsupported websocket client version: \" + this.webSocketVersion + \"Only versions 8 and 13 are supported.\");\n            e.httpCode = 426;\n            e.headers = {\n                \"Sec-WebSocket-Version\": \"13\"\n            };\n            throw e;\n    }\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers[\"origin\"];\n    } else if (this.webSocketVersion === 8) {\n        this.origin = request.headers[\"sec-websocket-origin\"];\n    }\n    // Protocol is optional.\n    var protocolString = request.headers[\"sec-websocket-protocol\"];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n    if (!this.serverConfig.ignoreXForwardedFor && request.headers[\"x-forwarded-for\"]) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers[\"x-forwarded-for\"].split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers[\"sec-websocket-extensions\"];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers[\"cookie\"];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split(\"=\");\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof str !== \"string\") {\n        return [];\n    }\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf(\"=\");\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n    return cookies;\n};\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n    // TODO: Handle extensions\n    var protocolFullCase;\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof protocolFullCase === \"undefined\") {\n            protocolFullCase = acceptedProtocol;\n        }\n    } else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n    // Create key validation hash\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var acceptKey = sha1.digest(\"base64\");\n    var response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" + \"Upgrade: websocket\\r\\n\" + \"Connection: Upgrade\\r\\n\" + \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\";\n    if (protocolFullCase) {\n        // validate protocol\n        for(var i = 0; i < protocolFullCase.length; i++){\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error(\"Specified protocol was not requested by the client.\");\n        }\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, \"\");\n        response += \"Sec-WebSocket-Protocol: \" + protocolFullCase + \"\\r\\n\";\n    }\n    this.requestedProtocols = null;\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, \"\");\n        if (this.webSocketVersion === 13) {\n            response += \"Origin: \" + allowedOrigin + \"\\r\\n\";\n        } else if (this.webSocketVersion === 8) {\n            response += \"Sec-WebSocket-Origin: \" + allowedOrigin + \"\\r\\n\";\n        }\n    }\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach((function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, \"\");\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, \"\");\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error(\"You may not specify the same cookie name twice.\");\n            }\n            seenCookies[cookie.name] = true;\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie name\");\n            }\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie value\");\n            }\n            var cookieParts = [\n                cookie.name + \"=\" + cookie.value\n            ];\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if (cookie.path) {\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie path\");\n                }\n                cookieParts.push(\"Path=\" + cookie.path);\n            }\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof cookie.domain !== \"string\") {\n                    this.reject(500);\n                    throw new Error(\"Domain must be specified and must be a string.\");\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie domain\");\n                }\n                cookieParts.push(\"Domain=\" + cookie.domain.toLowerCase());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push(\"Expires=\" + cookie.expires.toGMTString());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof maxage === \"string\") {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push(\"Max-Age=\" + maxage.toString(10));\n            }\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof cookie.secure !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push(\"Secure\");\n            }\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof cookie.httponly !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push(\"HttpOnly\");\n            }\n            response += \"Set-Cookie: \" + cookieParts.join(\";\") + \"\\r\\n\";\n        }).bind(this));\n    }\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    response += \"\\r\\n\";\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n    var self = this;\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    } else {\n        this.socket.write(response, \"ascii\", function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    if (typeof status !== \"number\") {\n        status = 403;\n    }\n    var response = \"HTTP/1.1 \" + status + \" \" + httpStatusDescriptions[status] + \"\\r\\n\" + \"Connection: close\\r\\n\";\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, \"\");\n        response += \"X-WebSocket-Reject-Reason: \" + reason + \"\\r\\n\";\n    }\n    if (extraHeaders) {\n        for(var key in extraHeaders){\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, \"\");\n            var sanitizedKey = key.replace(headerSanitizeRegExp, \"\");\n            response += sanitizedKey + \": \" + sanitizedValue + \"\\r\\n\";\n        }\n    }\n    response += \"\\r\\n\";\n    this.socket.end(response, \"ascii\");\n    this.emit(\"requestRejected\", this);\n};\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener(\"end\", this._socketCloseHandler);\n    this.socket.removeListener(\"close\", this._socketCloseHandler);\n};\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error(\"WebSocketRequest may only be accepted or rejected one time.\");\n    }\n};\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, \"TCP connection lost before handshake completed.\", true);\n    });\n}\nmodule.exports = WebSocketRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDbEIsSUFBSUcsZUFBZUgsMERBQThCO0FBQ2pELElBQUlJLHNCQUFzQkosbUJBQU9BLENBQUM7QUFFbEMsSUFBSUsseUJBQXlCO0FBQzdCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsK0JBQStCO0FBQ25DLElBQUlDLGFBQWE7SUFDYjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBQ0QsSUFBSUMsZUFBZTtJQUFDRixPQUFPQyxZQUFZLENBQUM7Q0FBZTtBQUN2RCxJQUFLLElBQUlFLElBQUUsR0FBR0EsSUFBSSxJQUFJQSxJQUFNO0lBQ3hCLCtCQUErQixHQUMvQkQsYUFBYUUsSUFBSSxDQUFDSixPQUFPQyxZQUFZLENBQUNFO0FBQzFDO0FBRUEsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUMvQixJQUFJQyxpQ0FBaUM7QUFDckMsSUFBSUMsZ0NBQWdDO0FBRXBDLElBQUlDLHVCQUF1QjtBQUUzQixJQUFJQyx5QkFBeUI7SUFDekIsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNM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QUNwRSx1REFBdUQ7SUFDdkRhLFFBQVFDLFFBQVEsQ0FBQztRQUNiLG1EQUFtRDtRQUNuRCw2REFBNkQ7UUFDN0RkLFdBQVdlLElBQUksQ0FBQyxNQUFNLG1EQUFtRDtJQUM3RTtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0UmVxdWVzdC5qcz8yYmU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL1dlYlNvY2tldENvbm5lY3Rpb24nKTtcblxudmFyIGhlYWRlclZhbHVlU3BsaXRSZWdFeHAgPSAvLFxccyovO1xudmFyIGhlYWRlclBhcmFtU3BsaXRSZWdFeHAgPSAvO1xccyovO1xudmFyIGhlYWRlclNhbml0aXplUmVnRXhwID0gL1tcXHJcXG5dL2c7XG52YXIgeEZvcndhcmRlZEZvclNlcGFyYXRvclJlZ0V4cCA9IC8sXFxzKi87XG52YXIgc2VwYXJhdG9ycyA9IFtcbiAgICAnKCcsICcpJywgJzwnLCAnPicsICdAJyxcbiAgICAnLCcsICc7JywgJzonLCAnXFxcXCcsICdcXFwiJyxcbiAgICAnLycsICdbJywgJ10nLCAnPycsICc9JyxcbiAgICAneycsICd9JywgJyAnLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpXG5dO1xudmFyIGNvbnRyb2xDaGFycyA9IFtTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNykgLyogREVMICovXTtcbmZvciAodmFyIGk9MDsgaSA8IDMxOyBpICsrKSB7XG4gICAgLyogVVMtQVNDSUkgQ29udHJvbCBDaGFyYWN0ZXJzICovXG4gICAgY29udHJvbENoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG59XG5cbnZhciBjb29raWVOYW1lVmFsaWRhdGVSZWdFeCA9IC8oW1xceDAwLVxceDIwXFx4MjJcXHgyOFxceDI5XFx4MmNcXHgyZlxceDNhLVxceDNmXFx4NDBcXHg1Yi1cXHg1ZVxceDdiXFx4N2RcXHg3Zl0pLztcbnZhciBjb29raWVWYWx1ZVZhbGlkYXRlUmVnRXggPSAvW15cXHgyMVxceDIzLVxceDJiXFx4MmQtXFx4M2FcXHgzYy1cXHg1YlxceDVkLVxceDdlXS87XG52YXIgY29va2llVmFsdWVEUXVvdGVWYWxpZGF0ZVJlZ0V4ID0gL15cIlteXCJdKlwiJC87XG52YXIgY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXggPSAvW1xceDAwLVxceDIwXFx4M2JdL2c7XG5cbnZhciBjb29raWVTZXBhcmF0b3JSZWdFeCA9IC9bOyxdICovO1xuXG52YXIgaHR0cFN0YXR1c0Rlc2NyaXB0aW9ucyA9IHtcbiAgICAxMDA6ICdDb250aW51ZScsXG4gICAgMTAxOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgMjAwOiAnT0snLFxuICAgIDIwMTogJ0NyZWF0ZWQnLFxuICAgIDIwMzogJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJyxcbiAgICAyMDQ6ICdObyBDb250ZW50JyxcbiAgICAyMDU6ICdSZXNldCBDb250ZW50JyxcbiAgICAyMDY6ICdQYXJ0aWFsIENvbnRlbnQnLFxuICAgIDMwMDogJ011bHRpcGxlIENob2ljZXMnLFxuICAgIDMwMTogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDI6ICdGb3VuZCcsXG4gICAgMzAzOiAnU2VlIE90aGVyJyxcbiAgICAzMDQ6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNTogJ1VzZSBQcm94eScsXG4gICAgMzA3OiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcbiAgICA0MDA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxOiAnVW5hdXRob3JpemVkJyxcbiAgICA0MDI6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgIDQwNDogJ05vdCBGb3VuZCcsXG4gICAgNDA2OiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNzogJ1Byb3h5IEF1dGhvcml6YXRpb24gUmVxdWlyZWQnLFxuICAgIDQwODogJ1JlcXVlc3QgVGltZW91dCcsXG4gICAgNDA5OiAnQ29uZmxpY3QnLFxuICAgIDQxMDogJ0dvbmUnLFxuICAgIDQxMTogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyOiAnUHJlY29uZGl0aW9uIEZhaWxlZCcsXG4gICAgNDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExvbmcnLFxuICAgIDQxNDogJ1JlcXVlc3QtVVJJIFRvbyBMb25nJyxcbiAgICA0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTY6ICdSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcbiAgICA0MTc6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuICAgIDQyNjogJ1VwZ3JhZGUgUmVxdWlyZWQnLFxuICAgIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDI6ICdCYWQgR2F0ZXdheScsXG4gICAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0OiAnR2F0ZXdheSBUaW1lb3V0JyxcbiAgICA1MDU6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCdcbn07XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFJlcXVlc3Qoc29ja2V0LCBodHRwUmVxdWVzdCwgc2VydmVyQ29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICAgIHRoaXMucmVzb3VyY2UgPSBodHRwUmVxdWVzdC51cmw7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzZXMgPSBbdGhpcy5yZW1vdGVBZGRyZXNzXTtcbiAgICB0aGlzLnNlcnZlckNvbmZpZyA9IHNlcnZlckNvbmZpZztcblxuICAgIC8vIFdhdGNoIGZvciB0aGUgdW5kZXJseWluZyBUQ1Agc29ja2V0IGNsb3NpbmcgYmVmb3JlIHdlIGNhbGwgYWNjZXB0XG4gICAgdGhpcy5fc29ja2V0SXNDbG9zaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlU29ja2V0Q2xvc2VCZWZvcmVBY2NlcHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcbiAgICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xuXG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRSZXF1ZXN0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5yZWFkSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5odHRwUmVxdWVzdDtcblxuICAgIC8vIERlY29kZSBVUkxcbiAgICB0aGlzLnJlc291cmNlVVJMID0gdXJsLnBhcnNlKHRoaXMucmVzb3VyY2UsIHRydWUpO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVxdWVzdC5oZWFkZXJzWydob3N0J107XG4gICAgaWYgKCF0aGlzLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgSG9zdCBoZWFkZXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J107XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBtdXN0IHByb3ZpZGUgYSB2YWx1ZSBmb3IgU2VjLVdlYlNvY2tldC1LZXkuJyk7XG4gICAgfVxuXG4gICAgdGhpcy53ZWJTb2NrZXRWZXJzaW9uID0gcGFyc2VJbnQocmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXSwgMTApO1xuXG4gICAgaWYgKCF0aGlzLndlYlNvY2tldFZlcnNpb24gfHwgaXNOYU4odGhpcy53ZWJTb2NrZXRWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBtdXN0IHByb3ZpZGUgYSB2YWx1ZSBmb3IgU2VjLVdlYlNvY2tldC1WZXJzaW9uLicpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy53ZWJTb2NrZXRWZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHdlYnNvY2tldCBjbGllbnQgdmVyc2lvbjogJyArIHRoaXMud2ViU29ja2V0VmVyc2lvbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnT25seSB2ZXJzaW9ucyA4IGFuZCAxMyBhcmUgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZS5odHRwQ29kZSA9IDQyNjtcbiAgICAgICAgICAgIGUuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogJzEzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnNbJ29yaWdpbiddO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJ107XG4gICAgfVxuXG4gICAgLy8gUHJvdG9jb2wgaXMgb3B0aW9uYWwuXG4gICAgdmFyIHByb3RvY29sU3RyaW5nID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgdGhpcy5wcm90b2NvbEZ1bGxDYXNlTWFwID0ge307XG4gICAgdGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMgPSBbXTtcbiAgICBpZiAocHJvdG9jb2xTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZFByb3RvY29sc0Z1bGxDYXNlID0gcHJvdG9jb2xTdHJpbmcuc3BsaXQoaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCk7XG4gICAgICAgIHJlcXVlc3RlZFByb3RvY29sc0Z1bGxDYXNlLmZvckVhY2goZnVuY3Rpb24ocHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHZhciBsY1Byb3RvY29sID0gcHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdGVkUHJvdG9jb2xzLnB1c2gobGNQcm90b2NvbCk7XG4gICAgICAgICAgICBzZWxmLnByb3RvY29sRnVsbENhc2VNYXBbbGNQcm90b2NvbF0gPSBwcm90b2NvbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlcnZlckNvbmZpZy5pZ25vcmVYRm9yd2FyZGVkRm9yICYmXG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ10pIHtcbiAgICAgICAgdmFyIGltbWVkaWF0ZVBlZXJJUCA9IHRoaXMucmVtb3RlQWRkcmVzcztcbiAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzZXMgPSByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddXG4gICAgICAgICAgICAuc3BsaXQoeEZvcndhcmRlZEZvclNlcGFyYXRvclJlZ0V4cCk7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzLnB1c2goaW1tZWRpYXRlUGVlcklQKTtcbiAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gdGhpcy5yZW1vdGVBZGRyZXNzZXNbMF07XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9ucyBhcmUgb3B0aW9uYWwuXG4gICAgaWYgKHRoaXMuc2VydmVyQ29uZmlnLnBhcnNlRXh0ZW5zaW9ucykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uc1N0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IHRoaXMucGFyc2VFeHRlbnNpb25zKGV4dGVuc2lvbnNTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8vIENvb2tpZXMgYXJlIG9wdGlvbmFsXG4gICAgaWYgKHRoaXMuc2VydmVyQ29uZmlnLnBhcnNlQ29va2llcykge1xuICAgICAgICB2YXIgY29va2llU3RyaW5nID0gcmVxdWVzdC5oZWFkZXJzWydjb29raWUnXTtcbiAgICAgICAgdGhpcy5jb29raWVzID0gdGhpcy5wYXJzZUNvb2tpZXMoY29va2llU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvb2tpZXMgPSBbXTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5wYXJzZUV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRlbnNpb25zU3RyaW5nKSB7XG4gICAgaWYgKCFleHRlbnNpb25zU3RyaW5nIHx8IGV4dGVuc2lvbnNTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGV4dGVuc2lvbnMgPSBleHRlbnNpb25zU3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCk7XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbiwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBleHRlbnNpb24uc3BsaXQoaGVhZGVyUGFyYW1TcGxpdFJlZ0V4cCk7XG4gICAgICAgIHZhciBleHRlbnNpb25OYW1lID0gcGFyYW1zWzBdO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uUGFyYW1zID0gcGFyYW1zLnNsaWNlKDEpO1xuICAgICAgICBleHRlbnNpb25QYXJhbXMuZm9yRWFjaChmdW5jdGlvbihyYXdQYXJhbSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gcmF3UGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogYXJyWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcnJbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogZXh0ZW5zaW9uUGFyYW1zXG4gICAgICAgIH07XG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgb2JqKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWRhcHRlZCBmcm9tIG5vZGUtY29va2llXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2h0eWxtYW4vbm9kZS1jb29raWVcbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLnBhcnNlQ29va2llcyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIC8vIFNhbml0eSBDaGVja1xuICAgIGlmICghc3RyIHx8IHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNvb2tpZXMgPSBbXTtcbiAgICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoY29va2llU2VwYXJhdG9yUmVnRXgpO1xuXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciBlcV9pZHggPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICAgICAgaWYgKGVxX2lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvb2tpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFpcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gcGFpci5zdWJzdHIoMCwgZXFfaWR4KS50cmltKCk7XG4gICAgICAgIHZhciB2YWwgPSBwYWlyLnN1YnN0cigrK2VxX2lkeCwgcGFpci5sZW5ndGgpLnRyaW0oKTtcblxuICAgICAgICAvLyBxdW90ZWQgdmFsdWVzXG4gICAgICAgIGlmICgnXCInID09PSB2YWxbMF0pIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29raWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvb2tpZXM7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbihhY2NlcHRlZFByb3RvY29sLCBhbGxvd2VkT3JpZ2luLCBjb29raWVzKSB7XG4gICAgdGhpcy5fdmVyaWZ5UmVzb2x1dGlvbigpO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIGV4dGVuc2lvbnNcblxuICAgIHZhciBwcm90b2NvbEZ1bGxDYXNlO1xuXG4gICAgaWYgKGFjY2VwdGVkUHJvdG9jb2wpIHtcbiAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IHRoaXMucHJvdG9jb2xGdWxsQ2FzZU1hcFthY2NlcHRlZFByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAodHlwZW9mKHByb3RvY29sRnVsbENhc2UpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IGFjY2VwdGVkUHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBhY2NlcHRlZFByb3RvY29sO1xuICAgIH1cbiAgICB0aGlzLnByb3RvY29sRnVsbENhc2VNYXAgPSBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGtleSB2YWxpZGF0aW9uIGhhc2hcbiAgICB2YXIgc2hhMSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgc2hhMS51cGRhdGUodGhpcy5rZXkgKyAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyk7XG4gICAgdmFyIGFjY2VwdEtleSA9IHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIHZhciByZXNwb25zZSA9ICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29sc1xcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXRcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogVXBncmFkZVxcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdTZWMtV2ViU29ja2V0LUFjY2VwdDogJyArIGFjY2VwdEtleSArICdcXHJcXG4nO1xuXG4gICAgaWYgKHByb3RvY29sRnVsbENhc2UpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgcHJvdG9jb2xcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcHJvdG9jb2xGdWxsQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcHJvdG9jb2xGdWxsQ2FzZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHByb3RvY29sRnVsbENhc2UuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHgyMSB8fCBjaGFyQ29kZSA+IDB4N0UgfHwgc2VwYXJhdG9ycy5pbmRleE9mKGNoYXJhY3RlcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyIFwiJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcmFjdGVyKSArICdcIiBpbiBzdWJwcm90b2NvbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMuaW5kZXhPZihhY2NlcHRlZFByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwZWNpZmllZCBwcm90b2NvbCB3YXMgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IHByb3RvY29sRnVsbENhc2UucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICByZXNwb25zZSArPSAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJyArIHByb3RvY29sRnVsbENhc2UgKyAnXFxyXFxuJztcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMgPSBudWxsO1xuXG4gICAgaWYgKGFsbG93ZWRPcmlnaW4pIHtcbiAgICAgICAgYWxsb3dlZE9yaWdpbiA9IGFsbG93ZWRPcmlnaW4ucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSAxMykge1xuICAgICAgICAgICAgcmVzcG9uc2UgKz0gJ09yaWdpbjogJyArIGFsbG93ZWRPcmlnaW4gKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICdTZWMtV2ViU29ja2V0LU9yaWdpbjogJyArIGFsbG93ZWRPcmlnaW4gKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb29raWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIFwiY29va2llc1wiIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZW5Db29raWVzID0ge307XG4gICAgICAgIGNvb2tpZXMuZm9yRWFjaChmdW5jdGlvbihjb29raWUpIHtcbiAgICAgICAgICAgIGlmICghY29va2llLm5hbWUgfHwgIWNvb2tpZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIGNvb2tpZSB0byBzZXQgbXVzdCBhdCBsZWFzdCBwcm92aWRlIGEgXCJuYW1lXCIgYW5kIFwidmFsdWVcIicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIFxcclxcbiBzZXF1ZW5jZXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGNvb2tpZS5uYW1lID0gY29va2llLm5hbWUucmVwbGFjZShjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCwgJycpO1xuICAgICAgICAgICAgY29va2llLnZhbHVlID0gY29va2llLnZhbHVlLnJlcGxhY2UoY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgsICcnKTtcblxuICAgICAgICAgICAgaWYgKHNlZW5Db29raWVzW2Nvb2tpZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBzcGVjaWZ5IHRoZSBzYW1lIGNvb2tpZSBuYW1lIHR3aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbkNvb2tpZXNbY29va2llLm5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdG9rZW4gKFJGQyAyNjE2LCBTZWN0aW9uIDIuMilcbiAgICAgICAgICAgIHZhciBpbnZhbGlkQ2hhciA9IGNvb2tpZS5uYW1lLm1hdGNoKGNvb2tpZU5hbWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLyAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKSB8ICV4MjEgLyAleDIzLTJCIC8gJXgyRC0zQSAvICV4M0MtNUIgLyAleDVELTdFXG4gICAgICAgICAgICBpZiAoY29va2llLnZhbHVlLm1hdGNoKGNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCkpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS52YWx1ZS5zbGljZSgxLCAtMSkubWF0Y2goY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUudmFsdWUubWF0Y2goY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29va2llUGFydHMgPSBbY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWVdO1xuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8gJ1BhdGg9JyBwYXRoLXZhbHVlIHwgPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yICc7Jz5cbiAgICAgICAgICAgIGlmKGNvb2tpZS5wYXRoKXtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS5wYXRoLm1hdGNoKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4KTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBwYXRoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ1BhdGg9JyArIGNvb2tpZS5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjIuM1xuICAgICAgICAgICAgLy8gJ0RvbWFpbj0nIHN1YmRvbWFpblxuICAgICAgICAgICAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvb2tpZS5kb21haW4pICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvbWFpbiBtdXN0IGJlIHNwZWNpZmllZCBhbmQgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUuZG9tYWluLm1hdGNoKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4KTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBkb21haW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnRG9tYWluPScgKyBjb29raWUuZG9tYWluLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nRXhwaXJlcz0nIHNhbmUtY29va2llLWRhdGUgfCBGb3JjZSBEYXRlIG9iamVjdCByZXF1aXJlbWVudCBieSB1c2luZyBvbmx5IGVwb2NoXG4gICAgICAgICAgICBpZiAoY29va2llLmV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjb29raWUuZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgY29va2llIFwiZXhwaXJlc1wiIG11c3QgYmUgYSB2YWlsZCBkYXRlIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdFeHBpcmVzPScgKyBjb29raWUuZXhwaXJlcy50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ01heC1BZ2U9JyBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgIGlmIChjb29raWUubWF4YWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heGFnZSA9IGNvb2tpZS5tYXhhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihtYXhhZ2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBtYXhhZ2UgPSBwYXJzZUludChtYXhhZ2UsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1heGFnZSkgfHwgbWF4YWdlIDw9IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcIm1heGFnZVwiIG11c3QgYmUgYSBub24temVybyBudW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF4YWdlID0gTWF0aC5yb3VuZChtYXhhZ2UpO1xuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ01heC1BZ2U9JyArIG1heGFnZS50b1N0cmluZygxMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nU2VjdXJlOydcbiAgICAgICAgICAgIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb29raWUuc2VjdXJlKSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcInNlY3VyZVwiIG11c3QgYmUgb2YgdHlwZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ1NlY3VyZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nSHR0cE9ubHk7J1xuICAgICAgICAgICAgaWYgKGNvb2tpZS5odHRwb25seSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29va2llLmh0dHBvbmx5KSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcImh0dHBvbmx5XCIgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnSHR0cE9ubHknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2UgKz0gKCdTZXQtQ29va2llOiAnICsgY29va2llUGFydHMuam9pbignOycpICsgJ1xcclxcbicpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGhhbmRsZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICAvLyBpZiAobmVnb3RpYXRlZEV4dGVuc2lvbnMpIHtcbiAgICAvLyAgICAgcmVzcG9uc2UgKz0gJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJyArIG5lZ290aWF0ZWRFeHRlbnNpb25zLmpvaW4oJywgJykgKyAnXFxyXFxuJztcbiAgICAvLyB9XG5cbiAgICAvLyBNYXJrIHRoZSByZXF1ZXN0IHJlc29sdmVkIG5vdyBzbyB0aGF0IHRoZSB1c2VyIGNhbid0IGNhbGwgYWNjZXB0IG9yXG4gICAgLy8gcmVqZWN0IGEgc2Vjb25kIHRpbWUuXG4gICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlc29sdmVkJywgdGhpcyk7XG5cbiAgICByZXNwb25zZSArPSAnXFxyXFxuJztcblxuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldENvbm5lY3Rpb24odGhpcy5zb2NrZXQsIFtdLCBhY2NlcHRlZFByb3RvY29sLCBmYWxzZSwgdGhpcy5zZXJ2ZXJDb25maWcpO1xuICAgIGNvbm5lY3Rpb24ud2ViU29ja2V0VmVyc2lvbiA9IHRoaXMud2ViU29ja2V0VmVyc2lvbjtcbiAgICBjb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MgPSB0aGlzLnJlbW90ZUFkZHJlc3M7XG4gICAgY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzZXMgPSB0aGlzLnJlbW90ZUFkZHJlc3NlcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9zb2NrZXRJc0Nsb3NpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0aGUgY2xpZW50IGhhbmdzIHVwIGJlZm9yZSB3ZSBnZXQgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gYWNjZXB0IHRoZSBjb25uZWN0aW9uIGFuZCBzZW5kIG91ciBzaWRlIG9mIHRoZSBvcGVuaW5nIGhhbmRzaGFrZS5cbiAgICAgICAgY2xlYW51cEZhaWxlZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShyZXNwb25zZSwgJ2FzY2lpJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgncmVxdWVzdEFjY2VwdGVkJywgY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKSB7XG4gICAgdGhpcy5fdmVyaWZ5UmVzb2x1dGlvbigpO1xuXG4gICAgLy8gTWFyayB0aGUgcmVxdWVzdCByZXNvbHZlZCBub3cgc28gdGhhdCB0aGUgdXNlciBjYW4ndCBjYWxsIGFjY2VwdCBvclxuICAgIC8vIHJlamVjdCBhIHNlY29uZCB0aW1lLlxuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZihzdGF0dXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdGF0dXMgPSA0MDM7XG4gICAgfVxuICAgIHZhciByZXNwb25zZSA9ICdIVFRQLzEuMSAnICsgc3RhdHVzICsgJyAnICsgaHR0cFN0YXR1c0Rlc2NyaXB0aW9uc1tzdGF0dXNdICsgJ1xcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdDb25uZWN0aW9uOiBjbG9zZVxcclxcbic7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgICByZWFzb24gPSByZWFzb24ucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICByZXNwb25zZSArPSAnWC1XZWJTb2NrZXQtUmVqZWN0LVJlYXNvbjogJyArIHJlYXNvbiArICdcXHJcXG4nO1xuICAgIH1cblxuICAgIGlmIChleHRyYUhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gZXh0cmFIZWFkZXJzW2tleV0udG9TdHJpbmcoKS5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkS2V5ID0ga2V5LnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9IChzYW5pdGl6ZWRLZXkgKyAnOiAnICsgc2FuaXRpemVkVmFsdWUgKyAnXFxyXFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNwb25zZSArPSAnXFxyXFxuJztcbiAgICB0aGlzLnNvY2tldC5lbmQocmVzcG9uc2UsICdhc2NpaScpO1xuXG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVqZWN0ZWQnLCB0aGlzKTtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLl9oYW5kbGVTb2NrZXRDbG9zZUJlZm9yZUFjY2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NvY2tldElzQ2xvc2luZyA9IHRydWU7XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xuICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5fdmVyaWZ5UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldFJlcXVlc3QgbWF5IG9ubHkgYmUgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgb25lIHRpbWUuJyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2xlYW51cEZhaWxlZENvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIC8vIFNpbmNlIHdlIGhhdmUgdG8gcmV0dXJuIGEgY29ubmVjdGlvbiBvYmplY3QgZXZlbiBpZiB0aGUgc29ja2V0IGlzXG4gICAgLy8gYWxyZWFkeSBkZWFkIGluIG9yZGVyIG5vdCB0byBicmVhayB0aGUgQVBJLCB3ZSBzY2hlZHVsZSBhICdjbG9zZSdcbiAgICAvLyBldmVudCBvbiB0aGUgY29ubmVjdGlvbiBvYmplY3QgdG8gb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwgPSAxMDA2XG4gICAgICAgIC8vIFRoaXJkIHBhcmFtOiBTa2lwIHNlbmRpbmcgdGhlIGNsb3NlIGZyYW1lIHRvIGEgZGVhZCBzb2NrZXRcbiAgICAgICAgY29ubmVjdGlvbi5kcm9wKDEwMDYsICdUQ1AgY29ubmVjdGlvbiBsb3N0IGJlZm9yZSBoYW5kc2hha2UgY29tcGxldGVkLicsIHRydWUpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJlcXVlc3Q7XG4iXSwibmFtZXMiOlsiY3J5cHRvIiwicmVxdWlyZSIsInV0aWwiLCJ1cmwiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRDb25uZWN0aW9uIiwiaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCIsImhlYWRlclBhcmFtU3BsaXRSZWdFeHAiLCJoZWFkZXJTYW5pdGl6ZVJlZ0V4cCIsInhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHAiLCJzZXBhcmF0b3JzIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY29udHJvbENoYXJzIiwiaSIsInB1c2giLCJjb29raWVOYW1lVmFsaWRhdGVSZWdFeCIsImNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCIsImNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCIsImNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4IiwiY29va2llU2VwYXJhdG9yUmVnRXgiLCJodHRwU3RhdHVzRGVzY3JpcHRpb25zIiwiV2ViU29ja2V0UmVxdWVzdCIsInNvY2tldCIsImh0dHBSZXF1ZXN0Iiwic2VydmVyQ29uZmlnIiwiY2FsbCIsInJlc291cmNlIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZUFkZHJlc3NlcyIsIl9zb2NrZXRJc0Nsb3NpbmciLCJfc29ja2V0Q2xvc2VIYW5kbGVyIiwiX2hhbmRsZVNvY2tldENsb3NlQmVmb3JlQWNjZXB0IiwiYmluZCIsIm9uIiwiX3Jlc29sdmVkIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJyZWFkSGFuZHNoYWtlIiwic2VsZiIsInJlcXVlc3QiLCJyZXNvdXJjZVVSTCIsInBhcnNlIiwiaG9zdCIsImhlYWRlcnMiLCJFcnJvciIsImtleSIsIndlYlNvY2tldFZlcnNpb24iLCJwYXJzZUludCIsImlzTmFOIiwiZSIsImh0dHBDb2RlIiwib3JpZ2luIiwicHJvdG9jb2xTdHJpbmciLCJwcm90b2NvbEZ1bGxDYXNlTWFwIiwicmVxdWVzdGVkUHJvdG9jb2xzIiwicmVxdWVzdGVkUHJvdG9jb2xzRnVsbENhc2UiLCJzcGxpdCIsImZvckVhY2giLCJwcm90b2NvbCIsImxjUHJvdG9jb2wiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImlnbm9yZVhGb3J3YXJkZWRGb3IiLCJpbW1lZGlhdGVQZWVySVAiLCJwYXJzZUV4dGVuc2lvbnMiLCJleHRlbnNpb25zU3RyaW5nIiwicmVxdWVzdGVkRXh0ZW5zaW9ucyIsInBhcnNlQ29va2llcyIsImNvb2tpZVN0cmluZyIsImNvb2tpZXMiLCJsZW5ndGgiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiaW5kZXgiLCJhcnJheSIsInBhcmFtcyIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25QYXJhbXMiLCJzbGljZSIsInJhd1BhcmFtIiwiYXJyIiwib2JqIiwibmFtZSIsInZhbHVlIiwic3BsaWNlIiwic3RyIiwicGFpcnMiLCJwYWlyIiwiZXFfaWR4IiwiaW5kZXhPZiIsInN1YnN0ciIsInRyaW0iLCJ2YWwiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhY2NlcHQiLCJhY2NlcHRlZFByb3RvY29sIiwiYWxsb3dlZE9yaWdpbiIsIl92ZXJpZnlSZXNvbHV0aW9uIiwicHJvdG9jb2xGdWxsQ2FzZSIsInNoYTEiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiYWNjZXB0S2V5IiwiZGlnZXN0IiwicmVzcG9uc2UiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJjaGFyYWN0ZXIiLCJjaGFyQXQiLCJyZWplY3QiLCJyZXBsYWNlIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VlbkNvb2tpZXMiLCJjb29raWUiLCJpbnZhbGlkQ2hhciIsIm1hdGNoIiwiY29va2llUGFydHMiLCJwYXRoIiwiZG9tYWluIiwidG9Mb3dlckNhc2UiLCJleHBpcmVzIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwibWF4YWdlIiwiTWF0aCIsInJvdW5kIiwidG9TdHJpbmciLCJzZWN1cmUiLCJodHRwb25seSIsImpvaW4iLCJlbWl0IiwiY29ubmVjdGlvbiIsImNsZWFudXBGYWlsZWRDb25uZWN0aW9uIiwid3JpdGUiLCJlcnJvciIsIl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycyIsIl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyIsInN0YXR1cyIsInJlYXNvbiIsImV4dHJhSGVhZGVycyIsInNhbml0aXplZFZhbHVlIiwic2FuaXRpemVkS2V5IiwiZW5kIiwicmVtb3ZlTGlzdGVuZXIiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJkcm9wIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\").extend);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"(action-browser)/./node_modules/websocket/lib/WebSocketRouterRequest.js\");\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\nutil.inherits(WebSocketRouter, EventEmitter);\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on(\"request\", this._requestHandler);\n    } else {\n        throw new Error(\"You must specify a WebSocketServer instance to attach to.\");\n    }\n};\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener(\"request\", this._requestHandler);\n        this.server = null;\n    } else {\n        throw new Error(\"Cannot detach from server: not attached.\");\n    }\n};\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error(\"You must specify a path for this handler.\");\n    }\n    if (!protocol) {\n        protocol = \"____no_protocol____\";\n    }\n    if (!callback) {\n        throw new Error(\"You must specify a callback for this handler.\");\n    }\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error(\"Path must be specified as either a string or a RegExp.\");\n    }\n    var pathString = path.toString();\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error(\"You may only mount one handler per path/protocol combination.\");\n    }\n    this.handlers.push({\n        \"path\": path,\n        \"pathString\": pathString,\n        \"protocol\": protocol,\n        \"callback\": callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    } else {\n        throw new Error(\"Unable to find a route matching the specified path and protocol.\");\n    }\n};\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for(var i = 0, len = this.handlers.length; i < len; i++){\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof path === \"string\") {\n        if (path === \"*\") {\n            path = /^.*$/;\n        } else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            path = new RegExp(\"^\" + path + \"$\");\n        }\n    }\n    return path;\n};\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = [\n            \"____no_protocol____\"\n        ];\n    }\n    // Find a handler with the first requested protocol first\n    for(var i = 0; i < requestedProtocols.length; i++){\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n        // find the first handler that can process this request\n        for(var j = 0, len = this.handlers.length; j < len; j++){\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol || handler.protocol === \"*\") {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, \"No handler is available for the given request.\");\n};\nmodule.exports = WebSocketRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLFNBQVNDLHFHQUF5QjtBQUN0QyxJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxlQUFlRiwwREFBOEI7QUFDakQsSUFBSUcseUJBQXlCSCxtQkFBT0EsQ0FBQztBQUVyQyxTQUFTSSxnQkFBZ0JDLE1BQU07SUFDM0IseUJBQXlCO0lBQ3pCSCxhQUFhSSxJQUFJLENBQUMsSUFBSTtJQUV0QixJQUFJLENBQUNELE1BQU0sR0FBRztRQUNWLDZDQUE2QztRQUM3Q0UsUUFBUTtJQUNaO0lBQ0EsSUFBSUYsUUFBUTtRQUNSTixPQUFPLElBQUksQ0FBQ00sTUFBTSxFQUFFQTtJQUN4QjtJQUNBLElBQUksQ0FBQ0csUUFBUSxHQUFHLEVBQUU7SUFFbEIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsSUFBSSxDQUFDQyxhQUFhLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQ25ELElBQUksSUFBSSxDQUFDTixNQUFNLENBQUNFLE1BQU0sRUFBRTtRQUNwQixJQUFJLENBQUNLLFlBQVksQ0FBQyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0UsTUFBTTtJQUN4QztBQUNKO0FBRUFOLEtBQUtZLFFBQVEsQ0FBQ1QsaUJBQWlCRjtBQUUvQkUsZ0JBQWdCVSxTQUFTLENBQUNGLFlBQVksR0FBRyxTQUFTTCxNQUFNO0lBQ3BELElBQUlBLFFBQVE7UUFDUixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNBLE1BQU0sQ0FBQ1EsRUFBRSxDQUFDLFdBQVcsSUFBSSxDQUFDTixlQUFlO0lBQ2xELE9BQ0s7UUFDRCxNQUFNLElBQUlPLE1BQU07SUFDcEI7QUFDSjtBQUVBWixnQkFBZ0JVLFNBQVMsQ0FBQ0csWUFBWSxHQUFHO0lBQ3JDLElBQUksSUFBSSxDQUFDVixNQUFN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MkIsTUFBTSxFQUFFTSxJQUFJUCxLQUFLTyxJQUFLO1lBQ2xELElBQUlMLFVBQVUsSUFBSSxDQUFDNUIsUUFBUSxDQUFDaUMsRUFBRTtZQUM5QixJQUFJTCxRQUFRaEIsSUFBSSxDQUFDc0IsSUFBSSxDQUFDSixRQUFRSyxXQUFXLENBQUNDLFFBQVEsR0FBRztnQkFDakQsSUFBSUosc0JBQXNCSixRQUFRZixRQUFRLElBQ3RDZSxRQUFRZixRQUFRLEtBQUssS0FDekI7b0JBQ0ksSUFBSXdCLGdCQUFnQixJQUFJMUMsdUJBQXVCbUMsU0FBU0U7b0JBQ3hESixRQUFRZCxRQUFRLENBQUN1QjtvQkFDakI7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFFQSw0REFBNEQ7SUFDNURQLFFBQVFRLE1BQU0sQ0FBQyxLQUFLO0FBQ3hCO0FBRUFDLE9BQU9DLE9BQU8sR0FBRzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Um91dGVyLmpzPzkxYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscycpLmV4dGVuZDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0ID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0Jyk7XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFJvdXRlcihjb25maWcpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLy8gVGhlIFdlYlNvY2tldFNlcnZlciBpbnN0YW5jZSB0byBhdHRhY2ggdG8uXG4gICAgICAgIHNlcnZlcjogbnVsbFxuICAgIH07XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gdGhpcy5oYW5kbGVSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNlcnZlcikge1xuICAgICAgICB0aGlzLmF0dGFjaFNlcnZlcih0aGlzLmNvbmZpZy5zZXJ2ZXIpO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRSb3V0ZXIsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUuYXR0YWNoU2VydmVyID0gZnVuY3Rpb24oc2VydmVyKSB7XG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5zZXJ2ZXIub24oJ3JlcXVlc3QnLCB0aGlzLl9yZXF1ZXN0SGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBXZWJTb2NrZXRTZXJ2ZXIgaW5zdGFuY2UgdG8gYXR0YWNoIHRvLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUuZGV0YWNoU2VydmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0JywgdGhpcy5fcmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRhY2ggZnJvbSBzZXJ2ZXI6IG5vdCBhdHRhY2hlZC4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24ocGF0aCwgcHJvdG9jb2wsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIHBhdGggZm9yIHRoaXMgaGFuZGxlci4nKTtcbiAgICB9XG4gICAgaWYgKCFwcm90b2NvbCkge1xuICAgICAgICBwcm90b2NvbCA9ICdfX19fbm9fcHJvdG9jb2xfX19fJztcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBjYWxsYmFjayBmb3IgdGhpcyBoYW5kbGVyLicpO1xuICAgIH1cblxuICAgIHBhdGggPSB0aGlzLnBhdGhUb1JlZ0V4cChwYXRoKTtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGEgc3RyaW5nIG9yIGEgUmVnRXhwLicpO1xuICAgIH1cbiAgICB2YXIgcGF0aFN0cmluZyA9IHBhdGgudG9TdHJpbmcoKTtcblxuICAgIC8vIG5vcm1hbGl6ZSBwcm90b2NvbCB0byBsb3dlci1jYXNlXG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHRoaXMuZmluZEhhbmRsZXJJbmRleChwYXRoU3RyaW5nLCBwcm90b2NvbCkgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBvbmx5IG1vdW50IG9uZSBoYW5kbGVyIHBlciBwYXRoL3Byb3RvY29sIGNvbWJpbmF0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICAgICdwYXRoJzogcGF0aCxcbiAgICAgICAgJ3BhdGhTdHJpbmcnOiBwYXRoU3RyaW5nLFxuICAgICAgICAncHJvdG9jb2wnOiBwcm90b2NvbCxcbiAgICAgICAgJ2NhbGxiYWNrJzogY2FsbGJhY2tcbiAgICB9KTtcbn07XG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbihwYXRoLCBwcm90b2NvbCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEhhbmRsZXJJbmRleCh0aGlzLnBhdGhUb1JlZ0V4cChwYXRoKS50b1N0cmluZygpLCBwcm90b2NvbCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGEgcm91dGUgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGFuZCBwcm90b2NvbC4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmZpbmRIYW5kbGVySW5kZXggPSBmdW5jdGlvbihwYXRoU3RyaW5nLCBwcm90b2NvbCkge1xuICAgIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciBpPTAsIGxlbj10aGlzLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tpXTtcbiAgICAgICAgaWYgKGhhbmRsZXIucGF0aFN0cmluZyA9PT0gcGF0aFN0cmluZyAmJiBoYW5kbGVyLnByb3RvY29sID09PSBwcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5wYXRoVG9SZWdFeHAgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHR5cGVvZihwYXRoKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHBhdGggPT09ICcqJykge1xuICAgICAgICAgICAgcGF0aCA9IC9eLiokLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICBwYXRoID0gbmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgJyQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgcmVxdWVzdGVkUHJvdG9jb2xzID0gcmVxdWVzdC5yZXF1ZXN0ZWRQcm90b2NvbHM7XG4gICAgaWYgKHJlcXVlc3RlZFByb3RvY29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVxdWVzdGVkUHJvdG9jb2xzID0gWydfX19fbm9fcHJvdG9jb2xfX19fJ107XG4gICAgfVxuXG4gICAgLy8gRmluZCBhIGhhbmRsZXIgd2l0aCB0aGUgZmlyc3QgcmVxdWVzdGVkIHByb3RvY29sIGZpcnN0XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgcmVxdWVzdGVkUHJvdG9jb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWRQcm90b2NvbCA9IHJlcXVlc3RlZFByb3RvY29sc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGhhbmRsZXIgdGhhdCBjYW4gcHJvY2VzcyB0aGlzIHJlcXVlc3RcbiAgICAgICAgZm9yICh2YXIgaj0wLCBsZW49dGhpcy5oYW5kbGVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2pdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIucGF0aC50ZXN0KHJlcXVlc3QucmVzb3VyY2VVUkwucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFByb3RvY29sID09PSBoYW5kbGVyLnByb3RvY29sIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIucHJvdG9jb2wgPT09ICcqJylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZXJSZXF1ZXN0ID0gbmV3IFdlYlNvY2tldFJvdXRlclJlcXVlc3QocmVxdWVzdCwgcmVxdWVzdGVkUHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKHJvdXRlclJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUgd2Ugd2VyZSB1bmFibGUgdG8gZmluZCBhIHN1aXRhYmxlIGhhbmRsZXIuXG4gICAgcmVxdWVzdC5yZWplY3QoNDA0LCAnTm8gaGFuZGxlciBpcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRSb3V0ZXI7XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwicmVxdWlyZSIsInV0aWwiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0IiwiV2ViU29ja2V0Um91dGVyIiwiY29uZmlnIiwiY2FsbCIsInNlcnZlciIsImhhbmRsZXJzIiwiX3JlcXVlc3RIYW5kbGVyIiwiaGFuZGxlUmVxdWVzdCIsImJpbmQiLCJhdHRhY2hTZXJ2ZXIiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsIm9uIiwiRXJyb3IiLCJkZXRhY2hTZXJ2ZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vdW50IiwicGF0aCIsInByb3RvY29sIiwiY2FsbGJhY2siLCJwYXRoVG9SZWdFeHAiLCJSZWdFeHAiLCJwYXRoU3RyaW5nIiwidG9TdHJpbmciLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImZpbmRIYW5kbGVySW5kZXgiLCJwdXNoIiwidW5tb3VudCIsImluZGV4Iiwic3BsaWNlIiwiaSIsImxlbiIsImxlbmd0aCIsImhhbmRsZXIiLCJyZXBsYWNlIiwicmVxdWVzdCIsInJlcXVlc3RlZFByb3RvY29scyIsInJlcXVlc3RlZFByb3RvY29sIiwiaiIsInRlc3QiLCJyZXNvdXJjZVVSTCIsInBhdGhuYW1lIiwicm91dGVyUmVxdWVzdCIsInJlamVjdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketRouter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").extend);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js\");\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\nutil.inherits(WebSocketRouter, EventEmitter);\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on(\"request\", this._requestHandler);\n    } else {\n        throw new Error(\"You must specify a WebSocketServer instance to attach to.\");\n    }\n};\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener(\"request\", this._requestHandler);\n        this.server = null;\n    } else {\n        throw new Error(\"Cannot detach from server: not attached.\");\n    }\n};\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error(\"You must specify a path for this handler.\");\n    }\n    if (!protocol) {\n        protocol = \"____no_protocol____\";\n    }\n    if (!callback) {\n        throw new Error(\"You must specify a callback for this handler.\");\n    }\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error(\"Path must be specified as either a string or a RegExp.\");\n    }\n    var pathString = path.toString();\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error(\"You may only mount one handler per path/protocol combination.\");\n    }\n    this.handlers.push({\n        \"path\": path,\n        \"pathString\": pathString,\n        \"protocol\": protocol,\n        \"callback\": callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    } else {\n        throw new Error(\"Unable to find a route matching the specified path and protocol.\");\n    }\n};\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for(var i = 0, len = this.handlers.length; i < len; i++){\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof path === \"string\") {\n        if (path === \"*\") {\n            path = /^.*$/;\n        } else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            path = new RegExp(\"^\" + path + \"$\");\n        }\n    }\n    return path;\n};\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = [\n            \"____no_protocol____\"\n        ];\n    }\n    // Find a handler with the first requested protocol first\n    for(var i = 0; i < requestedProtocols.length; i++){\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n        // find the first handler that can process this request\n        for(var j = 0, len = this.handlers.length; j < len; j++){\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol || handler.protocol === \"*\") {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, \"No handler is available for the given request.\");\n};\nmodule.exports = WebSocketRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLHlCQUF5QkgsbUJBQU9BLENBQUM7QUFFckMsU0FBU0ksZ0JBQWdCQyxNQUFNO0lBQzNCLHlCQUF5QjtJQUN6QkgsYUFBYUksSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDRCxNQUFNLEdBQUc7UUFDViw2Q0FBNkM7UUFDN0NFLFFBQVE7SUFDWjtJQUNBLElBQUlGLFFBQVE7UUFDUk4sT0FBTyxJQUFJLENBQUNNLE1BQU0sRUFBRUE7SUFDeEI7SUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBRyxFQUFFO0lBRWxCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUNuRCxJQUFJLElBQUksQ0FBQ04sTUFBTSxDQUFDRSxNQUFNLEVBQUU7UUFDcEIsSUFBSSxDQUFDSyxZQUFZLENBQUMsSUFBSSxDQUFDUCxNQUFNLENBQUNFLE1BQU07SUFDeEM7QUFDSjtBQUVBTixLQUFLWSxRQUFRLENBQUNULGlCQUFpQkY7QUFFL0JFLGdCQUFnQlUsU0FBUyxDQUFDRixZQUFZLEdBQUcsU0FBU0wsTUFBTTtJQUNwRCxJQUFJQSxRQUFRO1FBQ1IsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQSxNQUFNLENBQUNRLEVBQUUsQ0FBQyxXQUFXLElBQUksQ0FBQ04sZUFBZTtJQUNsRCxPQUNLO1FBQ0QsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCO0FBQ0o7QUFFQVosZ0JBQWdCVSxTQUFTLENBQUNHLFlBQVksR0FBRztJQUNyQyxJQUFJLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1FBQ2Is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RU0sSUFBSVAsS0FBS08sSUFBSztZQUNsRCxJQUFJTCxVQUFVLElBQUksQ0FBQzVCLFFBQVEsQ0FBQ2lDLEVBQUU7WUFDOUIsSUFBSUwsUUFBUWhCLElBQUksQ0FBQ3NCLElBQUksQ0FBQ0osUUFBUUssV0FBVyxDQUFDQyxRQUFRLEdBQUc7Z0JBQ2pELElBQUlKLHNCQUFzQkosUUFBUWYsUUFBUSxJQUN0Q2UsUUFBUWYsUUFBUSxLQUFLLEtBQ3pCO29CQUNJLElBQUl3QixnQkFBZ0IsSUFBSTFDLHVCQUF1Qm1DLFNBQVNFO29CQUN4REosUUFBUWQsUUFBUSxDQUFDdUI7b0JBQ2pCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBRUEsNERBQTREO0lBQzVEUCxRQUFRUSxNQUFNLENBQUMsS0FBSztBQUN4QjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlci5qcz85MWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5leHRlbmQ7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgV2ViU29ja2V0Um91dGVyUmVxdWVzdCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Um91dGVyUmVxdWVzdCcpO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSb3V0ZXIoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC8vIFRoZSBXZWJTb2NrZXRTZXJ2ZXIgaW5zdGFuY2UgdG8gYXR0YWNoIHRvLlxuICAgICAgICBzZXJ2ZXI6IG51bGxcbiAgICB9O1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMuY29uZmlnLCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG5cbiAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IHRoaXMuaGFuZGxlUmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hTZXJ2ZXIodGhpcy5jb25maWcuc2VydmVyKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Um91dGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmF0dGFjaFNlcnZlciA9IGZ1bmN0aW9uKHNlcnZlcikge1xuICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuc2VydmVyLm9uKCdyZXF1ZXN0JywgdGhpcy5fcmVxdWVzdEhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgV2ViU29ja2V0U2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmRldGFjaFNlcnZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICB0aGlzLnNlcnZlci5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIHRoaXMuX3JlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0YWNoIGZyb20gc2VydmVyOiBub3QgYXR0YWNoZWQuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKHBhdGgsIHByb3RvY29sLCBjYWxsYmFjaykge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBwYXRoIGZvciB0aGlzIGhhbmRsZXIuJyk7XG4gICAgfVxuICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgcHJvdG9jb2wgPSAnX19fX25vX3Byb3RvY29sX19fXyc7XG4gICAgfVxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY2FsbGJhY2sgZm9yIHRoaXMgaGFuZGxlci4nKTtcbiAgICB9XG5cbiAgICBwYXRoID0gdGhpcy5wYXRoVG9SZWdFeHAocGF0aCk7XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhIHN0cmluZyBvciBhIFJlZ0V4cC4nKTtcbiAgICB9XG4gICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBub3JtYWxpemUgcHJvdG9jb2wgdG8gbG93ZXItY2FzZVxuICAgIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICAgIGlmICh0aGlzLmZpbmRIYW5kbGVySW5kZXgocGF0aFN0cmluZywgcHJvdG9jb2wpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgb25seSBtb3VudCBvbmUgaGFuZGxlciBwZXIgcGF0aC9wcm90b2NvbCBjb21iaW5hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgICAncGF0aCc6IHBhdGgsXG4gICAgICAgICdwYXRoU3RyaW5nJzogcGF0aFN0cmluZyxcbiAgICAgICAgJ3Byb3RvY29sJzogcHJvdG9jb2wsXG4gICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrXG4gICAgfSk7XG59O1xuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24ocGF0aCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRIYW5kbGVySW5kZXgodGhpcy5wYXRoVG9SZWdFeHAocGF0aCkudG9TdHJpbmcoKSwgcHJvdG9jb2wpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIHJvdXRlIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcGF0aCBhbmQgcHJvdG9jb2wuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5maW5kSGFuZGxlckluZGV4ID0gZnVuY3Rpb24ocGF0aFN0cmluZywgcHJvdG9jb2wpIHtcbiAgICBwcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49dGhpcy5oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbaV07XG4gICAgICAgIGlmIChoYW5kbGVyLnBhdGhTdHJpbmcgPT09IHBhdGhTdHJpbmcgJiYgaGFuZGxlci5wcm90b2NvbCA9PT0gcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUucGF0aFRvUmVnRXhwID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICh0eXBlb2YocGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChwYXRoID09PSAnKicpIHtcbiAgICAgICAgICAgIHBhdGggPSAvXi4qJC87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICAgICAgICAgICAgcGF0aCA9IG5ldyBSZWdFeHAoJ14nICsgcGF0aCArICckJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHJlcXVlc3RlZFByb3RvY29scyA9IHJlcXVlc3QucmVxdWVzdGVkUHJvdG9jb2xzO1xuICAgIGlmIChyZXF1ZXN0ZWRQcm90b2NvbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlcXVlc3RlZFByb3RvY29scyA9IFsnX19fX25vX3Byb3RvY29sX19fXyddO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYSBoYW5kbGVyIHdpdGggdGhlIGZpcnN0IHJlcXVlc3RlZCBwcm90b2NvbCBmaXJzdFxuICAgIGZvciAodmFyIGk9MDsgaSA8IHJlcXVlc3RlZFByb3RvY29scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVxdWVzdGVkUHJvdG9jb2wgPSByZXF1ZXN0ZWRQcm90b2NvbHNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRoYXQgY2FuIHByb2Nlc3MgdGhpcyByZXF1ZXN0XG4gICAgICAgIGZvciAodmFyIGo9MCwgbGVuPXRoaXMuaGFuZGxlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tqXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLnBhdGgudGVzdChyZXF1ZXN0LnJlc291cmNlVVJMLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRQcm90b2NvbCA9PT0gaGFuZGxlci5wcm90b2NvbCB8fFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnByb3RvY29sID09PSAnKicpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVyUmVxdWVzdCA9IG5ldyBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0KHJlcXVlc3QsIHJlcXVlc3RlZFByb3RvY29sKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhyb3V0ZXJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlIHdlIHdlcmUgdW5hYmxlIHRvIGZpbmQgYSBzdWl0YWJsZSBoYW5kbGVyLlxuICAgIHJlcXVlc3QucmVqZWN0KDQwNCwgJ05vIGhhbmRsZXIgaXMgYXZhaWxhYmxlIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdC4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Um91dGVyO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsInJlcXVpcmUiLCJ1dGlsIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0Um91dGVyUmVxdWVzdCIsIldlYlNvY2tldFJvdXRlciIsImNvbmZpZyIsImNhbGwiLCJzZXJ2ZXIiLCJoYW5kbGVycyIsIl9yZXF1ZXN0SGFuZGxlciIsImhhbmRsZVJlcXVlc3QiLCJiaW5kIiwiYXR0YWNoU2VydmVyIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJvbiIsIkVycm9yIiwiZGV0YWNoU2VydmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtb3VudCIsInBhdGgiLCJwcm90b2NvbCIsImNhbGxiYWNrIiwicGF0aFRvUmVnRXhwIiwiUmVnRXhwIiwicGF0aFN0cmluZyIsInRvU3RyaW5nIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJmaW5kSGFuZGxlckluZGV4IiwicHVzaCIsInVubW91bnQiLCJpbmRleCIsInNwbGljZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJoYW5kbGVyIiwicmVwbGFjZSIsInJlcXVlc3QiLCJyZXF1ZXN0ZWRQcm90b2NvbHMiLCJyZXF1ZXN0ZWRQcm90b2NvbCIsImoiLCJ0ZXN0IiwicmVzb3VyY2VVUkwiLCJwYXRobmFtZSIsInJvdXRlclJlcXVlc3QiLCJyZWplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRouter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === \"____no_protocol____\") {\n        this.protocol = null;\n    } else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\nutil.inherits(WebSocketRouterRequest, EventEmitter);\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit(\"requestRejected\", this);\n};\nmodule.exports = WebSocketRouterRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlclJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxlQUFlRCwwREFBOEI7QUFFakQsU0FBU0UsdUJBQXVCQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCO0lBQzlELHlCQUF5QjtJQUN6QkgsYUFBYUksSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDRixnQkFBZ0IsR0FBR0E7SUFDeEIsSUFBSUMscUJBQXFCLHVCQUF1QjtRQUM1QyxJQUFJLENBQUNFLFFBQVEsR0FBRztJQUNwQixPQUNLO1FBQ0QsSUFBSSxDQUFDQSxRQUFRLEdBQUdGO0lBQ3BCO0lBQ0EsSUFBSSxDQUFDRyxNQUFNLEdBQUdKLGlCQUFpQkksTUFBTTtJQUNyQyxJQUFJLENBQUNDLFFBQVEsR0FBR0wsaUJBQWlCSyxRQUFRO0lBQ3pDLElBQUksQ0FBQ0MsV0FBVyxHQUFHTixpQkFBaUJNLFdBQVc7SUFDL0MsSUFBSSxDQUFDQyxXQUFXLEdBQUdQLGlCQUFpQk8sV0FBVztJQUMvQyxJQUFJLENBQUNDLGFBQWEsR0FBR1IsaUJBQWlCUSxhQUFhO0lBQ25ELElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdULGlCQUFpQlMsZ0JBQWdCO0lBQ3pELElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdWLGlCQUFpQlUsbUJBQW1CO0lBQy9ELElBQUksQ0FBQ0MsT0FBTyxHQUFHWCxpQkFBaUJXLE9BQU87QUFDM0M7QUFFQWYsS0FBS2dCLFFBQVEsQ0FBQ2Isd0JBQXdCRDtBQUV0Q0MsdUJBQXVCYyxTQUFTLENBQUNDLE1BQU0sR0FBRyxTQUFTVixNQUFNLEVBQUVPLE9BQU87SUFDOUQsSUFBSUksYUFBYSxJQUFJLENBQUNmLGdCQUFnQixDQUFDYyxNQUFNLENBQUMsSUFBSSxDQUFDWCxRQUFRLEVBQUVDLFFBQVFPO0lBQ3JFLElBQUksQ0FBQ0ssSUFBSSxDQUFDLG1CQUFtQkQ7SUFDN0IsT0FBT0E7QUFDWDtBQUVBaEIsdUJBQXVCYyxTQUFTLENBQUNJLE1BQU0sR0FBRyxTQUFTQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUMzRSxJQUFJLENBQUNwQixnQkFBZ0IsQ0FBQ2lCLE1BQU0sQ0FBQ0MsUUFBUUMsUUFBUUM7SUFDN0MsSUFBSSxDQUFDSixJQUFJLENBQUMsbUJBQW1CLElBQUk7QUFDckM7QUFFQUssT0FBT0MsT0FBTyxHQUFHdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LmpzPzNiOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFJvdXRlclJlcXVlc3Qod2ViU29ja2V0UmVxdWVzdCwgcmVzb2x2ZWRQcm90b2NvbCkge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMud2ViU29ja2V0UmVxdWVzdCA9IHdlYlNvY2tldFJlcXVlc3Q7XG4gICAgaWYgKHJlc29sdmVkUHJvdG9jb2wgPT09ICdfX19fbm9fcHJvdG9jb2xfX19fJykge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSByZXNvbHZlZFByb3RvY29sO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbiA9IHdlYlNvY2tldFJlcXVlc3Qub3JpZ2luO1xuICAgIHRoaXMucmVzb3VyY2UgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlc291cmNlO1xuICAgIHRoaXMucmVzb3VyY2VVUkwgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlc291cmNlVVJMO1xuICAgIHRoaXMuaHR0cFJlcXVlc3QgPSB3ZWJTb2NrZXRSZXF1ZXN0Lmh0dHBSZXF1ZXN0O1xuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHdlYlNvY2tldFJlcXVlc3QucmVtb3RlQWRkcmVzcztcbiAgICB0aGlzLndlYlNvY2tldFZlcnNpb24gPSB3ZWJTb2NrZXRSZXF1ZXN0LndlYlNvY2tldFZlcnNpb247XG4gICAgdGhpcy5yZXF1ZXN0ZWRFeHRlbnNpb25zID0gd2ViU29ja2V0UmVxdWVzdC5yZXF1ZXN0ZWRFeHRlbnNpb25zO1xuICAgIHRoaXMuY29va2llcyA9IHdlYlNvY2tldFJlcXVlc3QuY29va2llcztcbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbihvcmlnaW4sIGNvb2tpZXMpIHtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMud2ViU29ja2V0UmVxdWVzdC5hY2NlcHQodGhpcy5wcm90b2NvbCwgb3JpZ2luLCBjb29raWVzKTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RBY2NlcHRlZCcsIGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuV2ViU29ja2V0Um91dGVyUmVxdWVzdC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oc3RhdHVzLCByZWFzb24sIGV4dHJhSGVhZGVycykge1xuICAgIHRoaXMud2ViU29ja2V0UmVxdWVzdC5yZWplY3Qoc3RhdHVzLCByZWFzb24sIGV4dHJhSGVhZGVycyk7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVqZWN0ZWQnLCB0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Um91dGVyUmVxdWVzdDtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldFJvdXRlclJlcXVlc3QiLCJ3ZWJTb2NrZXRSZXF1ZXN0IiwicmVzb2x2ZWRQcm90b2NvbCIsImNhbGwiLCJwcm90b2NvbCIsIm9yaWdpbiIsInJlc291cmNlIiwicmVzb3VyY2VVUkwiLCJodHRwUmVxdWVzdCIsInJlbW90ZUFkZHJlc3MiLCJ3ZWJTb2NrZXRWZXJzaW9uIiwicmVxdWVzdGVkRXh0ZW5zaW9ucyIsImNvb2tpZXMiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImFjY2VwdCIsImNvbm5lY3Rpb24iLCJlbWl0IiwicmVqZWN0Iiwic3RhdHVzIiwicmVhc29uIiwiZXh0cmFIZWFkZXJzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketRouterRequest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === \"____no_protocol____\") {\n        this.protocol = null;\n    } else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\nutil.inherits(WebSocketRouterRequest, EventEmitter);\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit(\"requestRejected\", this);\n};\nmodule.exports = WebSocketRouterRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsZUFBZUQsMERBQThCO0FBRWpELFNBQVNFLHVCQUF1QkMsZ0JBQWdCLEVBQUVDLGdCQUFnQjtJQUM5RCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUdBO0lBQ3hCLElBQUlDLHFCQUFxQix1QkFBdUI7UUFDNUMsSUFBSSxDQUFDRSxRQUFRLEdBQUc7SUFDcEIsT0FDSztRQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFHRjtJQUNwQjtJQUNBLElBQUksQ0FBQ0csTUFBTSxHQUFHSixpQkFBaUJJLE1BQU07SUFDckMsSUFBSSxDQUFDQyxRQUFRLEdBQUdMLGlCQUFpQkssUUFBUTtJQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR04saUJBQWlCTSxXQUFXO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxHQUFHUCxpQkFBaUJPLFdBQVc7SUFDL0MsSUFBSSxDQUFDQyxhQUFhLEdBQUdSLGlCQUFpQlEsYUFBYTtJQUNuRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHVCxpQkFBaUJTLGdCQUFnQjtJQUN6RCxJQUFJLENBQUNDLG1CQUFtQixHQUFHVixpQkFBaUJVLG1CQUFtQjtJQUMvRCxJQUFJLENBQUNDLE9BQU8sR0FBR1gsaUJBQWlCVyxPQUFPO0FBQzNDO0FBRUFmLEtBQUtnQixRQUFRLENBQUNiLHdCQUF3QkQ7QUFFdENDLHVCQUF1QmMsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU1YsTUFBTSxFQUFFTyxPQUFPO0lBQzlELElBQUlJLGFBQWEsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQ2MsTUFBTSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxFQUFFQyxRQUFRTztJQUNyRSxJQUFJLENBQUNLLElBQUksQ0FBQyxtQkFBbUJEO0lBQzdCLE9BQU9BO0FBQ1g7QUFFQWhCLHVCQUF1QmMsU0FBUyxDQUFDSSxNQUFNLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0UsSUFBSSxDQUFDcEIsZ0JBQWdCLENBQUNpQixNQUFNLENBQUNDLFFBQVFDLFFBQVFDO0lBQzdDLElBQUksQ0FBQ0osSUFBSSxDQUFDLG1CQUFtQixJQUFJO0FBQ3JDO0FBRUFLLE9BQU9DLE9BQU8sR0FBR3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Um91dGVyUmVxdWVzdC5qcz8zYjk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0KHdlYlNvY2tldFJlcXVlc3QsIHJlc29sdmVkUHJvdG9jb2wpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLndlYlNvY2tldFJlcXVlc3QgPSB3ZWJTb2NrZXRSZXF1ZXN0O1xuICAgIGlmIChyZXNvbHZlZFByb3RvY29sID09PSAnX19fX25vX3Byb3RvY29sX19fXycpIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcmVzb2x2ZWRQcm90b2NvbDtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW4gPSB3ZWJTb2NrZXRSZXF1ZXN0Lm9yaWdpbjtcbiAgICB0aGlzLnJlc291cmNlID0gd2ViU29ja2V0UmVxdWVzdC5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc291cmNlVVJMID0gd2ViU29ja2V0UmVxdWVzdC5yZXNvdXJjZVVSTDtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gd2ViU29ja2V0UmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy53ZWJTb2NrZXRWZXJzaW9uID0gd2ViU29ja2V0UmVxdWVzdC53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IHdlYlNvY2tldFJlcXVlc3QucmVxdWVzdGVkRXh0ZW5zaW9ucztcbiAgICB0aGlzLmNvb2tpZXMgPSB3ZWJTb2NrZXRSZXF1ZXN0LmNvb2tpZXM7XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Um91dGVyUmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Um91dGVyUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24ob3JpZ2luLCBjb29raWVzKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLndlYlNvY2tldFJlcXVlc3QuYWNjZXB0KHRoaXMucHJvdG9jb2wsIG9yaWdpbiwgY29va2llcyk7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0QWNjZXB0ZWQnLCBjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbldlYlNvY2tldFJvdXRlclJlcXVlc3QucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHN0YXR1cywgcmVhc29uLCBleHRyYUhlYWRlcnMpIHtcbiAgICB0aGlzLndlYlNvY2tldFJlcXVlc3QucmVqZWN0KHN0YXR1cywgcmVhc29uLCBleHRyYUhlYWRlcnMpO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlamVjdGVkJywgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJvdXRlclJlcXVlc3Q7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0Iiwid2ViU29ja2V0UmVxdWVzdCIsInJlc29sdmVkUHJvdG9jb2wiLCJjYWxsIiwicHJvdG9jb2wiLCJvcmlnaW4iLCJyZXNvdXJjZSIsInJlc291cmNlVVJMIiwiaHR0cFJlcXVlc3QiLCJyZW1vdGVBZGRyZXNzIiwid2ViU29ja2V0VmVyc2lvbiIsInJlcXVlc3RlZEV4dGVuc2lvbnMiLCJjb29raWVzIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJhY2NlcHQiLCJjb25uZWN0aW9uIiwiZW1pdCIsInJlamVjdCIsInN0YXR1cyIsInJlYXNvbiIsImV4dHJhSGVhZGVycyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\").extend);\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/index.js\")(\"websocket:server\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"(action-browser)/./node_modules/websocket/lib/WebSocketRequest.js\");\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\nutil.inherits(WebSocketServer, EventEmitter);\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [\n                this.config.httpServer\n            ];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on(\"upgrade\", upgradeHandler);\n        });\n    } else {\n        throw new Error(\"You must specify an httpServer on which to mount the WebSocket server.\");\n    }\n};\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener(\"upgrade\", upgradeHandler);\n    });\n};\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n            request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    } else if (typeof data.toString === \"function\") {\n        this.broadcastUTF(data);\n    }\n};\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    } catch (e) {\n        wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n        debug(\"Invalid handshake: %s\", e.message);\n        this.emit(\"upgradeError\", e);\n        return;\n    }\n    this.pendingRequests.push(wsRequest);\n    wsRequest.once(\"requestAccepted\", this._handlers.requestAccepted);\n    wsRequest.once(\"requestResolved\", this._handlers.requestResolved);\n    socket.once(\"close\", function() {\n        self._handlers.requestResolved(wsRequest);\n    });\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, \"request\") > 0) {\n        this.emit(\"request\", wsRequest);\n    } else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    } else {\n        wsRequest.reject(404, \"No handler is configured to accept the connection.\");\n    }\n};\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once(\"close\", function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit(\"connect\", connection);\n};\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit(\"close\", connection, closeReason, description);\n};\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) {\n        this.pendingRequests.splice(index, 1);\n    }\n};\nmodule.exports = WebSocketServer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLFNBQVNDLHFHQUF5QjtBQUN0QyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQywwRkFBUztBQUM3QixJQUFJSSxlQUFlSiwwREFBOEI7QUFDakQsSUFBSUssbUJBQW1CTCxtQkFBT0EsQ0FBQztBQUUvQixJQUFJTSxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxNQUFNO0lBQ2pELHlCQUF5QjtJQUN6QkgsYUFBYUksSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDYkMsU0FBUyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDckNDLGlCQUFpQixJQUFJLENBQUNDLHFCQUFxQixDQUFDRixJQUFJLENBQUMsSUFBSTtRQUNyREcsaUJBQWlCLElBQUksQ0FBQ0MscUJBQXFCLENBQUNKLElBQUksQ0FBQyxJQUFJO0lBQ3pEO0lBQ0EsSUFBSSxDQUFDSyxXQUFXLEdBQUcsRUFBRTtJQUNyQixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO0lBQ3pCLElBQUlYLFFBQVE7UUFDUixJQUFJLENBQUNZLEtBQUssQ0FBQ1o7SUFDZjtBQUNKO0FBRUFMLEtBQUtrQixRQUFRLENBQUNkLGlCQUFpQkY7QUFFL0JFLGdCQUFnQmUsU0FBUyxDQUFDRixLQUFLLEdBQUcsU0FBU1osTUFBTTtJQUM3QyxJQUFJLENBQUNBLE1BQU0sR0FBRztRQUNWLG9EQUFvRDtRQUNwRGUsWUFBWTtRQUVaLHdCQUF3QjtRQUN4QkMsc0JBQXNCO1FBRXRCLDRDQUE0QztRQUM1Qyw0QkFBNEI7UUFDNUJDLHdCQUF3QjtRQUV4QiwrREFBK0Q7UUFDL0Qs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QUFXLENBQUNxRSxNQUFNLENBQUNGLE9BQU87SUFDbkM7SUFDQSxJQUFJLENBQUNWLElBQUksQ0FBQyxTQUFTMUIsWUFBWWlDLGFBQWFDO0FBQ2hEO0FBRUE1RSxnQkFBZ0JlLFNBQVMsQ0FBQ0wscUJBQXFCLEdBQUcsU0FBU2tDLE9BQU87SUFDOUQsSUFBSWtDLFFBQVEsSUFBSSxDQUFDbEUsZUFBZSxDQUFDbUUsT0FBTyxDQUFDbkM7SUFDekMsSUFBSWtDLFVBQVUsQ0FBQyxHQUFHO1FBQUUsSUFBSSxDQUFDbEUsZUFBZSxDQUFDb0UsTUFBTSxDQUFDRixPQUFPO0lBQUk7QUFDL0Q7QUFFQUcsT0FBT0MsT0FBTyxHQUFHbEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanM/YWRiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzJykuZXh0ZW5kO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJzb2NrZXQ6c2VydmVyJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldFJlcXVlc3QgPSByZXF1aXJlKCcuL1dlYlNvY2tldFJlcXVlc3QnKTtcblxudmFyIFdlYlNvY2tldFNlcnZlciA9IGZ1bmN0aW9uIFdlYlNvY2tldFNlcnZlcihjb25maWcpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9oYW5kbGVycyA9IHtcbiAgICAgICAgdXBncmFkZTogdGhpcy5oYW5kbGVVcGdyYWRlLmJpbmQodGhpcyksXG4gICAgICAgIHJlcXVlc3RBY2NlcHRlZDogdGhpcy5oYW5kbGVSZXF1ZXN0QWNjZXB0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgcmVxdWVzdFJlc29sdmVkOiB0aGlzLmhhbmRsZVJlcXVlc3RSZXNvbHZlZC5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBbXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubW91bnQoY29uZmlnKTtcbiAgICB9XG59O1xuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFNlcnZlciwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyBUaGUgaHR0cCBzZXJ2ZXIgaW5zdGFuY2UgdG8gYXR0YWNoIHRvLiAgUmVxdWlyZWQuXG4gICAgICAgIGh0dHBTZXJ2ZXI6IG51bGwsXG5cbiAgICAgICAgLy8gNjRLaUIgbWF4IGZyYW1lIHNpemUuXG4gICAgICAgIG1heFJlY2VpdmVkRnJhbWVTaXplOiAweDEwMDAwLFxuXG4gICAgICAgIC8vIDFNaUIgbWF4IG1lc3NhZ2Ugc2l6ZSwgb25seSBhcHBsaWNhYmxlIGlmXG4gICAgICAgIC8vIGFzc2VtYmxlRnJhZ21lbnRzIGlzIHRydWVcbiAgICAgICAgbWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZTogMHgxMDAwMDAsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgbWVzc2FnZXMgbGFyZ2VyIHRoYW4gZnJhZ21lbnRhdGlvblRocmVzaG9sZCB3aWxsIGJlXG4gICAgICAgIC8vIHNwbGl0IGludG8gbXVsdGlwbGUgZnJhZ21lbnRzLlxuICAgICAgICBmcmFnbWVudE91dGdvaW5nTWVzc2FnZXM6IHRydWUsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgZnJhbWVzIGFyZSBmcmFnbWVudGVkIGlmIHRoZXkgZXhjZWVkIHRoaXMgdGhyZXNob2xkLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIDE2S2lCXG4gICAgICAgIGZyYWdtZW50YXRpb25UaHJlc2hvbGQ6IDB4NDAwMCxcblxuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSBzZW5kIGEgcGluZyB0byBhbGxcbiAgICAgICAgLy8gY2xpZW50cyBldmVyeSAna2VlcGFsaXZlSW50ZXJ2YWwnIG1pbGxpc2Vjb25kcy4gIFRoZSB0aW1lciBpc1xuICAgICAgICAvLyByZXNldCBvbiBhbnkgcmVjZWl2ZWQgZGF0YSBmcm9tIHRoZSBjbGllbnQuXG4gICAgICAgIGtlZXBhbGl2ZTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgaW50ZXJ2YWwgdG8gc2VuZCBrZWVwYWxpdmUgcGluZ3MgdG8gY29ubmVjdGVkIGNsaWVudHMgaWYgdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgaWRsZS4gIEFueSByZWNlaXZlZCBkYXRhIHdpbGwgcmVzZXQgdGhlIGNvdW50ZXIuXG4gICAgICAgIGtlZXBhbGl2ZUludGVydmFsOiAyMDAwMCxcblxuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgc2VydmVyIHdpbGwgY29uc2lkZXIgYW55IGNvbm5lY3Rpb24gdGhhdCBoYXMgbm90XG4gICAgICAgIC8vIHJlY2VpdmVkIGFueSBkYXRhIHdpdGhpbiB0aGUgYW1vdW50IG9mIHRpbWUgc3BlY2lmaWVkIGJ5XG4gICAgICAgIC8vICdrZWVwYWxpdmVHcmFjZVBlcmlvZCcgYWZ0ZXIgYSBrZWVwYWxpdmUgcGluZyBoYXMgYmVlbiBzZW50IHRvXG4gICAgICAgIC8vIGJlIGRlYWQsIGFuZCB3aWxsIGRyb3AgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIElnbm9yZWQgaWYga2VlcGFsaXZlIGlzIGZhbHNlLlxuICAgICAgICBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dDogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEga2VlcGFsaXZlIHBpbmcgYmVmb3JlXG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24gaWYgdGhlIGNvbm5lY3RlZCBwZWVyIGRvZXMgbm90IHJlc3BvbmQuXG4gICAgICAgIC8vIElnbm9yZWQgaWYga2VlcGFsaXZlIGlzIGZhbHNlLlxuICAgICAgICBrZWVwYWxpdmVHcmFjZVBlcmlvZDogMTAwMDAsXG5cbiAgICAgICAgLy8gV2hldGhlciB0byB1c2UgbmF0aXZlIFRDUCBrZWVwLWFsaXZlIGluc3RlYWQgb2YgV2ViU29ja2V0cyBwaW5nXG4gICAgICAgIC8vIGFuZCBwb25nIHBhY2tldHMuICBOYXRpdmUgVENQIGtlZXAtYWxpdmUgc2VuZHMgc21hbGxlciBwYWNrZXRzXG4gICAgICAgIC8vIG9uIHRoZSB3aXJlIGFuZCBzbyB1c2VzIGJhbmR3aWR0aCBtb3JlIGVmZmljaWVudGx5LiAgVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgbW9yZSBpbXBvcnRhbnQgd2hlbiB0YWxraW5nIHRvIG1vYmlsZSBkZXZpY2VzLlxuICAgICAgICAvLyBJZiB0aGlzIHZhbHVlIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZXNlIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQ6XG4gICAgICAgIC8vICAga2VlcGFsaXZlR3JhY2VQZXJpb2RcbiAgICAgICAgLy8gICBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dFxuICAgICAgICB1c2VOYXRpdmVLZWVwYWxpdmU6IGZhbHNlLFxuXG4gICAgICAgIC8vIElmIHRydWUsIGZyYWdtZW50ZWQgbWVzc2FnZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFzc2VtYmxlZFxuICAgICAgICAvLyBhbmQgdGhlIGZ1bGwgbWVzc2FnZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ21lc3NhZ2UnIGV2ZW50LlxuICAgICAgICAvLyBJZiBmYWxzZSwgZWFjaCBmcmFtZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ2ZyYW1lJyBldmVudCBhbmRcbiAgICAgICAgLy8gdGhlIGFwcGxpY2F0aW9uIHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIGFnZ3JlZ2F0aW5nIG11bHRpcGxlXG4gICAgICAgIC8vIGZyYWdtZW50ZWQgZnJhbWVzLiAgU2luZ2xlLWZyYW1lIG1lc3NhZ2VzIHdpbGwgZW1pdCBhICdtZXNzYWdlJ1xuICAgICAgICAvLyBldmVudCBpbiBhZGRpdGlvbiB0byB0aGUgJ2ZyYW1lJyBldmVudC5cbiAgICAgICAgLy8gTW9zdCB1c2VycyB3aWxsIHdhbnQgdG8gbGVhdmUgdGhpcyBzZXQgdG8gJ3RydWUnXG4gICAgICAgIGFzc2VtYmxlRnJhZ21lbnRzOiB0cnVlLFxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgd2Vic29ja2V0IGNvbm5lY3Rpb25zIHdpbGwgYmUgYWNjZXB0ZWRcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB0aGUgcGF0aCBhbmQgcHJvdG9jb2wgc3BlY2lmaWVkIGJ5IHRoZSBjbGllbnQuXG4gICAgICAgIC8vIFRoZSBwcm90b2NvbCBhY2NlcHRlZCB3aWxsIGJlIHRoZSBmaXJzdCB0aGF0IHdhcyByZXF1ZXN0ZWRcbiAgICAgICAgLy8gYnkgdGhlIGNsaWVudC4gIENsaWVudHMgZnJvbSBhbnkgb3JpZ2luIHdpbGwgYmUgYWNjZXB0ZWQuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0aGUgc2ltcGxlc3Qgb2YgY2FzZXMuICBZb3Ugc2hvdWxkXG4gICAgICAgIC8vIHByb2JhYmx5IGxlYXZlIHRoaXMgc2V0IHRvICdmYWxzZScgYW5kIGluc3BlY3QgdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gb2JqZWN0IHRvIG1ha2Ugc3VyZSBpdCdzIGFjY2VwdGFibGUgYmVmb3JlIGFjY2VwdGluZyBpdC5cbiAgICAgICAgYXV0b0FjY2VwdENvbm5lY3Rpb25zOiBmYWxzZSxcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0aGUgWC1Gb3J3YXJkZWQtRm9yIGhlYWRlciBzaG91bGQgYmUgcmVzcGVjdGVkLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBzZXQgdGhpcyB0byAndHJ1ZScgd2hlbiBhY2NlcHRpbmcgY29ubmVjdGlvbnNcbiAgICAgICAgLy8gZnJvbSB1bnRydXN0ZWQgY2xpZW50cywgYXMgYSBtYWxpY2lvdXMgY2xpZW50IGNvdWxkIHNwb29mIGl0c1xuICAgICAgICAvLyBJUCBhZGRyZXNzIGJ5IHNpbXBseSBzZXR0aW5nIHRoaXMgaGVhZGVyLiAgSXQncyBtZWFudCB0byBiZSBhZGRlZFxuICAgICAgICAvLyBieSBhIHRydXN0ZWQgcHJveHkgb3Igb3RoZXIgaW50ZXJtZWRpYXJ5IHdpdGhpbiB5b3VyIG93blxuICAgICAgICAvLyBpbmZyYXN0cnVjdHVyZS5cbiAgICAgICAgLy8gU2VlOiAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9YLUZvcndhcmRlZC1Gb3JcbiAgICAgICAgaWdub3JlWEZvcndhcmRlZEZvcjogZmFsc2UsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlLCAnY29va2llJyBoZWFkZXJzIGFyZSBwYXJzZWQgYW5kIGV4cG9zZWQgYXMgV2ViU29ja2V0UmVxdWVzdC5jb29raWVzXG4gICAgICAgIHBhcnNlQ29va2llczogdHJ1ZSxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUsICdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnIGhlYWRlcnMgYXJlIHBhcnNlZCBhbmQgZXhwb3NlZCBhcyBXZWJTb2NrZXRSZXF1ZXN0LnJlcXVlc3RlZEV4dGVuc2lvbnNcbiAgICAgICAgcGFyc2VFeHRlbnNpb25zOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBOYWdsZSBBbGdvcml0aG0gbWFrZXMgbW9yZSBlZmZpY2llbnQgdXNlIG9mIG5ldHdvcmsgcmVzb3VyY2VzXG4gICAgICAgIC8vIGJ5IGludHJvZHVjaW5nIGEgc21hbGwgZGVsYXkgYmVmb3JlIHNlbmRpbmcgc21hbGwgcGFja2V0cyBzbyB0aGF0XG4gICAgICAgIC8vIG11bHRpcGxlIG1lc3NhZ2VzIGNhbiBiZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZSBnb2luZyBvbnRvIHRoZVxuICAgICAgICAvLyB3aXJlLiAgVGhpcyBob3dldmVyIGNvbWVzIGF0IHRoZSBjb3N0IG9mIGxhdGVuY3ksIHNvIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGlzIHRvIGRpc2FibGUgaXQuICBJZiB5b3UgZG9uJ3QgbmVlZCBsb3cgbGF0ZW5jeSBhbmQgYXJlIHN0cmVhbWluZ1xuICAgICAgICAvLyBsb3RzIG9mIHNtYWxsIG1lc3NhZ2VzLCB5b3UgY2FuIGNoYW5nZSB0aGlzIHRvICdmYWxzZSdcbiAgICAgICAgZGlzYWJsZU5hZ2xlQWxnb3JpdGhtOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIGNsb3NlIGZyYW1lXG4gICAgICAgIC8vIGZvciBhbiBhY2tub3dsZWRnZW1lbnQgdG8gY29tZSBiYWNrIGJlZm9yZSBnaXZpbmcgdXAgYW5kIGp1c3RcbiAgICAgICAgLy8gY2xvc2luZyB0aGUgc29ja2V0LlxuICAgICAgICBjbG9zZVRpbWVvdXQ6IDUwMDBcbiAgICB9O1xuICAgIGV4dGVuZCh0aGlzLmNvbmZpZywgY29uZmlnKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5odHRwU2VydmVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5odHRwU2VydmVyKSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuaHR0cFNlcnZlciA9IFt0aGlzLmNvbmZpZy5odHRwU2VydmVyXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBncmFkZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVycy51cGdyYWRlO1xuICAgICAgICB0aGlzLmNvbmZpZy5odHRwU2VydmVyLmZvckVhY2goZnVuY3Rpb24oaHR0cFNlcnZlcikge1xuICAgICAgICAgICAgaHR0cFNlcnZlci5vbigndXBncmFkZScsIHVwZ3JhZGVIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYW4gaHR0cFNlcnZlciBvbiB3aGljaCB0byBtb3VudCB0aGUgV2ViU29ja2V0IHNlcnZlci4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXBncmFkZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVycy51cGdyYWRlO1xuICAgIHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIuZm9yRWFjaChmdW5jdGlvbihodHRwU2VydmVyKSB7XG4gICAgICAgIGh0dHBTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCB1cGdyYWRlSGFuZGxlcik7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmNsb3NlQWxsQ29ubmVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWplY3QoNTAzKTsgLy8gSFRUUCA1MDMgU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mKGRhdGEudG9TdHJpbmcpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0VVRGKGRhdGEpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0VVRGID0gZnVuY3Rpb24odXRmRGF0YSkge1xuICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZFVURih1dGZEYXRhKTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0Qnl0ZXMgPSBmdW5jdGlvbihiaW5hcnlEYXRhKSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kQnl0ZXMoYmluYXJ5RGF0YSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLnNodXREb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gICAgdGhpcy5jbG9zZUFsbENvbm5lY3Rpb25zKCk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZVVwZ3JhZGUgPSBmdW5jdGlvbihyZXF1ZXN0LCBzb2NrZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdzUmVxdWVzdCA9IG5ldyBXZWJTb2NrZXRSZXF1ZXN0KHNvY2tldCwgcmVxdWVzdCwgdGhpcy5jb25maWcpO1xuICAgIHRyeSB7XG4gICAgICAgIHdzUmVxdWVzdC5yZWFkSGFuZHNoYWtlKCk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgd3NSZXF1ZXN0LnJlamVjdChcbiAgICAgICAgICAgIGUuaHR0cENvZGUgPyBlLmh0dHBDb2RlIDogNDAwLFxuICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgZS5oZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnKCdJbnZhbGlkIGhhbmRzaGFrZTogJXMnLCBlLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMucHVzaCh3c1JlcXVlc3QpO1xuXG4gICAgd3NSZXF1ZXN0Lm9uY2UoJ3JlcXVlc3RBY2NlcHRlZCcsIHRoaXMuX2hhbmRsZXJzLnJlcXVlc3RBY2NlcHRlZCk7XG4gICAgd3NSZXF1ZXN0Lm9uY2UoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMuX2hhbmRsZXJzLnJlcXVlc3RSZXNvbHZlZCk7XG4gICAgc29ja2V0Lm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9oYW5kbGVycy5yZXF1ZXN0UmVzb2x2ZWQod3NSZXF1ZXN0KTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5jb25maWcuYXV0b0FjY2VwdENvbm5lY3Rpb25zICYmIHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQodGhpcywgJ3JlcXVlc3QnKSA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0Jywgd3NSZXF1ZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWcuYXV0b0FjY2VwdENvbm5lY3Rpb25zKSB7XG4gICAgICAgIHdzUmVxdWVzdC5hY2NlcHQod3NSZXF1ZXN0LnJlcXVlc3RlZFByb3RvY29sc1swXSwgd3NSZXF1ZXN0Lm9yaWdpbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1JlcXVlc3QucmVqZWN0KDQwNCwgJ05vIGhhbmRsZXIgaXMgY29uZmlndXJlZCB0byBhY2NlcHQgdGhlIGNvbm5lY3Rpb24uJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0QWNjZXB0ZWQgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgc2VsZi5oYW5kbGVDb25uZWN0aW9uQ2xvc2UoY29ubmVjdGlvbiwgY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY29ubmVjdGlvbik7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3Rpb25DbG9zZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbik7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3RSZXNvbHZlZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHsgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGluZGV4LCAxKTsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTZXJ2ZXI7XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwicmVxdWlyZSIsInV0aWxzIiwidXRpbCIsImRlYnVnIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0UmVxdWVzdCIsIldlYlNvY2tldFNlcnZlciIsImNvbmZpZyIsImNhbGwiLCJfaGFuZGxlcnMiLCJ1cGdyYWRlIiwiaGFuZGxlVXBncmFkZSIsImJpbmQiLCJyZXF1ZXN0QWNjZXB0ZWQiLCJoYW5kbGVSZXF1ZXN0QWNjZXB0ZWQiLCJyZXF1ZXN0UmVzb2x2ZWQiLCJoYW5kbGVSZXF1ZXN0UmVzb2x2ZWQiLCJjb25uZWN0aW9ucyIsInBlbmRpbmdSZXF1ZXN0cyIsIm1vdW50IiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJodHRwU2VydmVyIiwibWF4UmVjZWl2ZWRGcmFtZVNpemUiLCJtYXhSZWNlaXZlZE1lc3NhZ2VTaXplIiwiZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIiwiZnJhZ21lbnRhdGlvblRocmVzaG9sZCIsImtlZXBhbGl2ZSIsImtlZXBhbGl2ZUludGVydmFsIiwiZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQiLCJrZWVwYWxpdmVHcmFjZVBlcmlvZCIsInVzZU5hdGl2ZUtlZXBhbGl2ZSIsImFzc2VtYmxlRnJhZ21lbnRzIiwiYXV0b0FjY2VwdENvbm5lY3Rpb25zIiwiaWdub3JlWEZvcndhcmRlZEZvciIsInBhcnNlQ29va2llcyIsInBhcnNlRXh0ZW5zaW9ucyIsImRpc2FibGVOYWdsZUFsZ29yaXRobSIsImNsb3NlVGltZW91dCIsIkFycmF5IiwiaXNBcnJheSIsInVwZ3JhZGVIYW5kbGVyIiwiZm9yRWFjaCIsIm9uIiwiRXJyb3IiLCJ1bm1vdW50IiwicmVtb3ZlTGlzdGVuZXIiLCJjbG9zZUFsbENvbm5lY3Rpb25zIiwiY29ubmVjdGlvbiIsImNsb3NlIiwicmVxdWVzdCIsInByb2Nlc3MiLCJuZXh0VGljayIsInJlamVjdCIsImJyb2FkY2FzdCIsImRhdGEiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImJyb2FkY2FzdEJ5dGVzIiwidG9TdHJpbmciLCJicm9hZGNhc3RVVEYiLCJ1dGZEYXRhIiwic2VuZFVURiIsImJpbmFyeURhdGEiLCJzZW5kQnl0ZXMiLCJzaHV0RG93biIsInNvY2tldCIsInNlbGYiLCJ3c1JlcXVlc3QiLCJyZWFkSGFuZHNoYWtlIiwiZSIsImh0dHBDb2RlIiwibWVzc2FnZSIsImhlYWRlcnMiLCJlbWl0IiwicHVzaCIsIm9uY2UiLCJldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50IiwiYWNjZXB0IiwicmVxdWVzdGVkUHJvdG9jb2xzIiwib3JpZ2luIiwiY2xvc2VSZWFzb24iLCJkZXNjcmlwdGlvbiIsImhhbmRsZUNvbm5lY3Rpb25DbG9zZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").extend);\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/index.js\")(\"websocket:server\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\");\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\nutil.inherits(WebSocketServer, EventEmitter);\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [\n                this.config.httpServer\n            ];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on(\"upgrade\", upgradeHandler);\n        });\n    } else {\n        throw new Error(\"You must specify an httpServer on which to mount the WebSocket server.\");\n    }\n};\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener(\"upgrade\", upgradeHandler);\n    });\n};\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n            request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    } else if (typeof data.toString === \"function\") {\n        this.broadcastUTF(data);\n    }\n};\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    } catch (e) {\n        wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n        debug(\"Invalid handshake: %s\", e.message);\n        this.emit(\"upgradeError\", e);\n        return;\n    }\n    this.pendingRequests.push(wsRequest);\n    wsRequest.once(\"requestAccepted\", this._handlers.requestAccepted);\n    wsRequest.once(\"requestResolved\", this._handlers.requestResolved);\n    socket.once(\"close\", function() {\n        self._handlers.requestResolved(wsRequest);\n    });\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, \"request\") > 0) {\n        this.emit(\"request\", wsRequest);\n    } else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    } else {\n        wsRequest.reject(404, \"No handler is configured to accept the connection.\");\n    }\n};\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once(\"close\", function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit(\"connect\", connection);\n};\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit(\"close\", connection, closeReason, description);\n};\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) {\n        this.pendingRequests.splice(index, 1);\n    }\n};\nmodule.exports = WebSocketServer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUMsK0VBQVM7QUFDN0IsSUFBSUksZUFBZUosMERBQThCO0FBQ2pELElBQUlLLG1CQUFtQkwsbUJBQU9BLENBQUM7QUFFL0IsSUFBSU0sa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTTtJQUNqRCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2JDLFNBQVMsSUFBSSxDQUFDQyxhQUFhLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ3JDQyxpQkFBaUIsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDckRHLGlCQUFpQixJQUFJLENBQUNDLHFCQUFxQixDQUFDSixJQUFJLENBQUMsSUFBSTtJQUN6RDtJQUNBLElBQUksQ0FBQ0ssV0FBVyxHQUFHLEVBQUU7SUFDckIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtJQUN6QixJQUFJWCxRQUFRO1FBQ1IsSUFBSSxDQUFDWSxLQUFLLENBQUNaO0lBQ2Y7QUFDSjtBQUVBTCxLQUFLa0IsUUFBUSxDQUFDZCxpQkFBaUJGO0FBRS9CRSxnQkFBZ0JlLFNBQVMsQ0FBQ0YsS0FBSyxHQUFHLFNBQVNaLE1BQU07SUFDN0MsSUFBSSxDQUFDQSxNQUFNLEdBQUc7UUFDVixvREFBb0Q7UUFDcERlLFlBQVk7UUFFWix3QkFBd0I7UUFDeEJDLHNCQUFzQjtRQUV0Qiw0Q0FBNEM7UUFDNUMsNEJBQTRCO1FBQzVCQyx3QkFBd0I7UUFFeEIsK0RBQStEO1FBQy9ELGlDQUFpQztRQUNq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TUFBTSxDQUFDRixPQUFPO0lBQ25DO0lBQ0EsSUFBSSxDQUFDVixJQUFJLENBQUMsU0FBUzFCLFlBQVlpQyxhQUFhQztBQUNoRDtBQUVBNUUsZ0JBQWdCZSxTQUFTLENBQUNMLHFCQUFxQixHQUFHLFNBQVNrQyxPQUFPO0lBQzlELElBQUlrQyxRQUFRLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ21FLE9BQU8sQ0FBQ25DO0lBQ3pDLElBQUlrQyxVQUFVLENBQUMsR0FBRztRQUFFLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ29FLE1BQU0sQ0FBQ0YsT0FBTztJQUFJO0FBQy9EO0FBRUFHLE9BQU9DLE9BQU8sR0FBR2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0U2VydmVyLmpzP2FkYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscycpLmV4dGVuZDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2Vic29ja2V0OnNlcnZlcicpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRSZXF1ZXN0Jyk7XG5cbnZhciBXZWJTb2NrZXRTZXJ2ZXIgPSBmdW5jdGlvbiBXZWJTb2NrZXRTZXJ2ZXIoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgIHVwZ3JhZGU6IHRoaXMuaGFuZGxlVXBncmFkZS5iaW5kKHRoaXMpLFxuICAgICAgICByZXF1ZXN0QWNjZXB0ZWQ6IHRoaXMuaGFuZGxlUmVxdWVzdEFjY2VwdGVkLmJpbmQodGhpcyksXG4gICAgICAgIHJlcXVlc3RSZXNvbHZlZDogdGhpcy5oYW5kbGVSZXF1ZXN0UmVzb2x2ZWQuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gW107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICB0aGlzLm1vdW50KGNvbmZpZyk7XG4gICAgfVxufTtcblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRTZXJ2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLy8gVGhlIGh0dHAgc2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by4gIFJlcXVpcmVkLlxuICAgICAgICBodHRwU2VydmVyOiBudWxsLFxuXG4gICAgICAgIC8vIDY0S2lCIG1heCBmcmFtZSBzaXplLlxuICAgICAgICBtYXhSZWNlaXZlZEZyYW1lU2l6ZTogMHgxMDAwMCxcblxuICAgICAgICAvLyAxTWlCIG1heCBtZXNzYWdlIHNpemUsIG9ubHkgYXBwbGljYWJsZSBpZlxuICAgICAgICAvLyBhc3NlbWJsZUZyYWdtZW50cyBpcyB0cnVlXG4gICAgICAgIG1heFJlY2VpdmVkTWVzc2FnZVNpemU6IDB4MTAwMDAwLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIG1lc3NhZ2VzIGxhcmdlciB0aGFuIGZyYWdtZW50YXRpb25UaHJlc2hvbGQgd2lsbCBiZVxuICAgICAgICAvLyBzcGxpdCBpbnRvIG11bHRpcGxlIGZyYWdtZW50cy5cbiAgICAgICAgZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzOiB0cnVlLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIGZyYW1lcyBhcmUgZnJhZ21lbnRlZCBpZiB0aGV5IGV4Y2VlZCB0aGlzIHRocmVzaG9sZC5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyAxNktpQlxuICAgICAgICBmcmFnbWVudGF0aW9uVGhyZXNob2xkOiAweDQwMDAsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgdGhlIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBpbmcgdG8gYWxsXG4gICAgICAgIC8vIGNsaWVudHMgZXZlcnkgJ2tlZXBhbGl2ZUludGVydmFsJyBtaWxsaXNlY29uZHMuICBUaGUgdGltZXIgaXNcbiAgICAgICAgLy8gcmVzZXQgb24gYW55IHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgY2xpZW50LlxuICAgICAgICBrZWVwYWxpdmU6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIGludGVydmFsIHRvIHNlbmQga2VlcGFsaXZlIHBpbmdzIHRvIGNvbm5lY3RlZCBjbGllbnRzIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGlkbGUuICBBbnkgcmVjZWl2ZWQgZGF0YSB3aWxsIHJlc2V0IHRoZSBjb3VudGVyLlxuICAgICAgICBrZWVwYWxpdmVJbnRlcnZhbDogMjAwMDAsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgdGhlIHNlcnZlciB3aWxsIGNvbnNpZGVyIGFueSBjb25uZWN0aW9uIHRoYXQgaGFzIG5vdFxuICAgICAgICAvLyByZWNlaXZlZCBhbnkgZGF0YSB3aXRoaW4gdGhlIGFtb3VudCBvZiB0aW1lIHNwZWNpZmllZCBieVxuICAgICAgICAvLyAna2VlcGFsaXZlR3JhY2VQZXJpb2QnIGFmdGVyIGEga2VlcGFsaXZlIHBpbmcgaGFzIGJlZW4gc2VudCB0b1xuICAgICAgICAvLyBiZSBkZWFkLCBhbmQgd2lsbCBkcm9wIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAvLyBJZ25vcmVkIGlmIGtlZXBhbGl2ZSBpcyBmYWxzZS5cbiAgICAgICAgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQ6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIGtlZXBhbGl2ZSBwaW5nIGJlZm9yZVxuICAgICAgICAvLyBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGlmIHRoZSBjb25uZWN0ZWQgcGVlciBkb2VzIG5vdCByZXNwb25kLlxuICAgICAgICAvLyBJZ25vcmVkIGlmIGtlZXBhbGl2ZSBpcyBmYWxzZS5cbiAgICAgICAga2VlcGFsaXZlR3JhY2VQZXJpb2Q6IDEwMDAwLFxuXG4gICAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIG5hdGl2ZSBUQ1Aga2VlcC1hbGl2ZSBpbnN0ZWFkIG9mIFdlYlNvY2tldHMgcGluZ1xuICAgICAgICAvLyBhbmQgcG9uZyBwYWNrZXRzLiAgTmF0aXZlIFRDUCBrZWVwLWFsaXZlIHNlbmRzIHNtYWxsZXIgcGFja2V0c1xuICAgICAgICAvLyBvbiB0aGUgd2lyZSBhbmQgc28gdXNlcyBiYW5kd2lkdGggbW9yZSBlZmZpY2llbnRseS4gIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIG1vcmUgaW1wb3J0YW50IHdoZW4gdGFsa2luZyB0byBtb2JpbGUgZGV2aWNlcy5cbiAgICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGVzZSB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkOlxuICAgICAgICAvLyAgIGtlZXBhbGl2ZUdyYWNlUGVyaW9kXG4gICAgICAgIC8vICAgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXRcbiAgICAgICAgdXNlTmF0aXZlS2VlcGFsaXZlOiBmYWxzZSxcblxuICAgICAgICAvLyBJZiB0cnVlLCBmcmFnbWVudGVkIG1lc3NhZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhc3NlbWJsZWRcbiAgICAgICAgLy8gYW5kIHRoZSBmdWxsIG1lc3NhZ2Ugd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdtZXNzYWdlJyBldmVudC5cbiAgICAgICAgLy8gSWYgZmFsc2UsIGVhY2ggZnJhbWUgd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdmcmFtZScgZXZlbnQgYW5kXG4gICAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBhZ2dyZWdhdGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBmcmFnbWVudGVkIGZyYW1lcy4gIFNpbmdsZS1mcmFtZSBtZXNzYWdlcyB3aWxsIGVtaXQgYSAnbWVzc2FnZSdcbiAgICAgICAgLy8gZXZlbnQgaW4gYWRkaXRpb24gdG8gdGhlICdmcmFtZScgZXZlbnQuXG4gICAgICAgIC8vIE1vc3QgdXNlcnMgd2lsbCB3YW50IHRvIGxlYXZlIHRoaXMgc2V0IHRvICd0cnVlJ1xuICAgICAgICBhc3NlbWJsZUZyYWdtZW50czogdHJ1ZSxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUsIHdlYnNvY2tldCBjb25uZWN0aW9ucyB3aWxsIGJlIGFjY2VwdGVkXG4gICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIHBhdGggYW5kIHByb3RvY29sIHNwZWNpZmllZCBieSB0aGUgY2xpZW50LlxuICAgICAgICAvLyBUaGUgcHJvdG9jb2wgYWNjZXB0ZWQgd2lsbCBiZSB0aGUgZmlyc3QgdGhhdCB3YXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIGJ5IHRoZSBjbGllbnQuICBDbGllbnRzIGZyb20gYW55IG9yaWdpbiB3aWxsIGJlIGFjY2VwdGVkLlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlIHNpbXBsZXN0IG9mIGNhc2VzLiAgWW91IHNob3VsZFxuICAgICAgICAvLyBwcm9iYWJseSBsZWF2ZSB0aGlzIHNldCB0byAnZmFsc2UnIGFuZCBpbnNwZWN0IHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIG9iamVjdCB0byBtYWtlIHN1cmUgaXQncyBhY2NlcHRhYmxlIGJlZm9yZSBhY2NlcHRpbmcgaXQuXG4gICAgICAgIGF1dG9BY2NlcHRDb25uZWN0aW9uczogZmFsc2UsXG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdGhlIFgtRm9yd2FyZGVkLUZvciBoZWFkZXIgc2hvdWxkIGJlIHJlc3BlY3RlZC5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc2V0IHRoaXMgdG8gJ3RydWUnIHdoZW4gYWNjZXB0aW5nIGNvbm5lY3Rpb25zXG4gICAgICAgIC8vIGZyb20gdW50cnVzdGVkIGNsaWVudHMsIGFzIGEgbWFsaWNpb3VzIGNsaWVudCBjb3VsZCBzcG9vZiBpdHNcbiAgICAgICAgLy8gSVAgYWRkcmVzcyBieSBzaW1wbHkgc2V0dGluZyB0aGlzIGhlYWRlci4gIEl0J3MgbWVhbnQgdG8gYmUgYWRkZWRcbiAgICAgICAgLy8gYnkgYSB0cnVzdGVkIHByb3h5IG9yIG90aGVyIGludGVybWVkaWFyeSB3aXRoaW4geW91ciBvd25cbiAgICAgICAgLy8gaW5mcmFzdHJ1Y3R1cmUuXG4gICAgICAgIC8vIFNlZTogIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWC1Gb3J3YXJkZWQtRm9yXG4gICAgICAgIGlnbm9yZVhGb3J3YXJkZWRGb3I6IGZhbHNlLFxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgJ2Nvb2tpZScgaGVhZGVycyBhcmUgcGFyc2VkIGFuZCBleHBvc2VkIGFzIFdlYlNvY2tldFJlcXVlc3QuY29va2llc1xuICAgICAgICBwYXJzZUNvb2tpZXM6IHRydWUsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlLCAnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJyBoZWFkZXJzIGFyZSBwYXJzZWQgYW5kIGV4cG9zZWQgYXMgV2ViU29ja2V0UmVxdWVzdC5yZXF1ZXN0ZWRFeHRlbnNpb25zXG4gICAgICAgIHBhcnNlRXh0ZW5zaW9uczogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgTmFnbGUgQWxnb3JpdGhtIG1ha2VzIG1vcmUgZWZmaWNpZW50IHVzZSBvZiBuZXR3b3JrIHJlc291cmNlc1xuICAgICAgICAvLyBieSBpbnRyb2R1Y2luZyBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHNtYWxsIHBhY2tldHMgc28gdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtZXNzYWdlcyBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgZ29pbmcgb250byB0aGVcbiAgICAgICAgLy8gd2lyZS4gIFRoaXMgaG93ZXZlciBjb21lcyBhdCB0aGUgY29zdCBvZiBsYXRlbmN5LCBzbyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpcyB0byBkaXNhYmxlIGl0LiAgSWYgeW91IGRvbid0IG5lZWQgbG93IGxhdGVuY3kgYW5kIGFyZSBzdHJlYW1pbmdcbiAgICAgICAgLy8gbG90cyBvZiBzbWFsbCBtZXNzYWdlcywgeW91IGNhbiBjaGFuZ2UgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIGRpc2FibGVOYWdsZUFsZ29yaXRobTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBjbG9zZSBmcmFtZVxuICAgICAgICAvLyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IHRvIGNvbWUgYmFjayBiZWZvcmUgZ2l2aW5nIHVwIGFuZCBqdXN0XG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIHNvY2tldC5cbiAgICAgICAgY2xvc2VUaW1lb3V0OiA1MDAwXG4gICAgfTtcbiAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHR0cFNlcnZlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb25maWcuaHR0cFNlcnZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIgPSBbdGhpcy5jb25maWcuaHR0cFNlcnZlcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZ3JhZGVIYW5kbGVyID0gdGhpcy5faGFuZGxlcnMudXBncmFkZTtcbiAgICAgICAgdGhpcy5jb25maWcuaHR0cFNlcnZlci5mb3JFYWNoKGZ1bmN0aW9uKGh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgIGh0dHBTZXJ2ZXIub24oJ3VwZ3JhZGUnLCB1cGdyYWRlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGFuIGh0dHBTZXJ2ZXIgb24gd2hpY2ggdG8gbW91bnQgdGhlIFdlYlNvY2tldCBzZXJ2ZXIuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwZ3JhZGVIYW5kbGVyID0gdGhpcy5faGFuZGxlcnMudXBncmFkZTtcbiAgICB0aGlzLmNvbmZpZy5odHRwU2VydmVyLmZvckVhY2goZnVuY3Rpb24oaHR0cFNlcnZlcikge1xuICAgICAgICBodHRwU2VydmVyLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgdXBncmFkZUhhbmRsZXIpO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5jbG9zZUFsbENvbm5lY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlcXVlc3QucmVqZWN0KDUwMyk7IC8vIEhUVFAgNTAzIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Qnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihkYXRhLnRvU3RyaW5nKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFVURihkYXRhKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdFVURiA9IGZ1bmN0aW9uKHV0ZkRhdGEpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmRVVEYodXRmRGF0YSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdEJ5dGVzID0gZnVuY3Rpb24oYmluYXJ5RGF0YSkge1xuICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZEJ5dGVzKGJpbmFyeURhdGEpO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5zaHV0RG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMuY2xvc2VBbGxDb25uZWN0aW9ucygpO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVVcGdyYWRlID0gZnVuY3Rpb24ocmVxdWVzdCwgc29ja2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3c1JlcXVlc3QgPSBuZXcgV2ViU29ja2V0UmVxdWVzdChzb2NrZXQsIHJlcXVlc3QsIHRoaXMuY29uZmlnKTtcbiAgICB0cnkge1xuICAgICAgICB3c1JlcXVlc3QucmVhZEhhbmRzaGFrZSgpO1xuICAgIH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIHdzUmVxdWVzdC5yZWplY3QoXG4gICAgICAgICAgICBlLmh0dHBDb2RlID8gZS5odHRwQ29kZSA6IDQwMCxcbiAgICAgICAgICAgIGUubWVzc2FnZSxcbiAgICAgICAgICAgIGUuaGVhZGVyc1xuICAgICAgICApO1xuICAgICAgICBkZWJ1ZygnSW52YWxpZCBoYW5kc2hha2U6ICVzJywgZS5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGdyYWRlRXJyb3InLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnB1c2god3NSZXF1ZXN0KTtcblxuICAgIHdzUmVxdWVzdC5vbmNlKCdyZXF1ZXN0QWNjZXB0ZWQnLCB0aGlzLl9oYW5kbGVycy5yZXF1ZXN0QWNjZXB0ZWQpO1xuICAgIHdzUmVxdWVzdC5vbmNlKCdyZXF1ZXN0UmVzb2x2ZWQnLCB0aGlzLl9oYW5kbGVycy5yZXF1ZXN0UmVzb2x2ZWQpO1xuICAgIHNvY2tldC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlcnMucmVxdWVzdFJlc29sdmVkKHdzUmVxdWVzdCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9BY2NlcHRDb25uZWN0aW9ucyAmJiB1dGlscy5ldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50KHRoaXMsICdyZXF1ZXN0JykgPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHdzUmVxdWVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmF1dG9BY2NlcHRDb25uZWN0aW9ucykge1xuICAgICAgICB3c1JlcXVlc3QuYWNjZXB0KHdzUmVxdWVzdC5yZXF1ZXN0ZWRQcm90b2NvbHNbMF0sIHdzUmVxdWVzdC5vcmlnaW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3NSZXF1ZXN0LnJlamVjdCg0MDQsICdObyBoYW5kbGVyIGlzIGNvbmZpZ3VyZWQgdG8gYWNjZXB0IHRoZSBjb25uZWN0aW9uLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdEFjY2VwdGVkID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb25uZWN0aW9uLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlQ29ubmVjdGlvbkNsb3NlKGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIGNvbm5lY3Rpb24pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0aW9uQ2xvc2UgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjb25uZWN0aW9uLCBjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0UmVzb2x2ZWQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7IHRoaXMucGVuZGluZ1JlcXVlc3RzLnNwbGljZShpbmRleCwgMSk7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsInJlcXVpcmUiLCJ1dGlscyIsInV0aWwiLCJkZWJ1ZyIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldFJlcXVlc3QiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJjb25maWciLCJjYWxsIiwiX2hhbmRsZXJzIiwidXBncmFkZSIsImhhbmRsZVVwZ3JhZGUiLCJiaW5kIiwicmVxdWVzdEFjY2VwdGVkIiwiaGFuZGxlUmVxdWVzdEFjY2VwdGVkIiwicmVxdWVzdFJlc29sdmVkIiwiaGFuZGxlUmVxdWVzdFJlc29sdmVkIiwiY29ubmVjdGlvbnMiLCJwZW5kaW5nUmVxdWVzdHMiLCJtb3VudCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiaHR0cFNlcnZlciIsIm1heFJlY2VpdmVkRnJhbWVTaXplIiwibWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSIsImZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyIsImZyYWdtZW50YXRpb25UaHJlc2hvbGQiLCJrZWVwYWxpdmUiLCJrZWVwYWxpdmVJbnRlcnZhbCIsImRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0Iiwia2VlcGFsaXZlR3JhY2VQZXJpb2QiLCJ1c2VOYXRpdmVLZWVwYWxpdmUiLCJhc3NlbWJsZUZyYWdtZW50cyIsImF1dG9BY2NlcHRDb25uZWN0aW9ucyIsImlnbm9yZVhGb3J3YXJkZWRGb3IiLCJwYXJzZUNvb2tpZXMiLCJwYXJzZUV4dGVuc2lvbnMiLCJkaXNhYmxlTmFnbGVBbGdvcml0aG0iLCJjbG9zZVRpbWVvdXQiLCJBcnJheSIsImlzQXJyYXkiLCJ1cGdyYWRlSGFuZGxlciIsImZvckVhY2giLCJvbiIsIkVycm9yIiwidW5tb3VudCIsInJlbW92ZUxpc3RlbmVyIiwiY2xvc2VBbGxDb25uZWN0aW9ucyIsImNvbm5lY3Rpb24iLCJjbG9zZSIsInJlcXVlc3QiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJyZWplY3QiLCJicm9hZGNhc3QiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJicm9hZGNhc3RCeXRlcyIsInRvU3RyaW5nIiwiYnJvYWRjYXN0VVRGIiwidXRmRGF0YSIsInNlbmRVVEYiLCJiaW5hcnlEYXRhIiwic2VuZEJ5dGVzIiwic2h1dERvd24iLCJzb2NrZXQiLCJzZWxmIiwid3NSZXF1ZXN0IiwicmVhZEhhbmRzaGFrZSIsImUiLCJodHRwQ29kZSIsIm1lc3NhZ2UiLCJoZWFkZXJzIiwiZW1pdCIsInB1c2giLCJvbmNlIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsImFjY2VwdCIsInJlcXVlc3RlZFByb3RvY29scyIsIm9yaWdpbiIsImNsb3NlUmVhc29uIiwiZGVzY3JpcHRpb24iLCJoYW5kbGVDb25uZWN0aW9uQ2xvc2UiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var noop = exports.noop = function() {};\nexports.extend = function extend(dest, source) {\n    for(var prop in source){\n        dest[prop] = source[prop];\n    }\n};\nexports.eventEmitterListenerCount = (__webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount) || function(emitter, type) {\n    return emitter.listeners(type).length;\n};\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {\n    return new Buffer(size);\n};\nexports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {\n    return new Buffer(string, encoding);\n};\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\nBufferingLogger.prototype.log = function() {\n    this.buffer.push([\n        new Date(),\n        Array.prototype.slice.call(arguments)\n    ]);\n    return this;\n};\nBufferingLogger.prototype.clear = function() {\n    this.buffer = [];\n    return this;\n};\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) {\n        logFunction = this.logFunction;\n    }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== void 0 && formatString !== null) {\n            formatString = \"%s - %s - \" + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLE9BQU9DLFlBQVksR0FBRyxZQUFXO0FBRXJDQSxjQUFjLEdBQUcsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxNQUFNO0lBQ3pDLElBQUssSUFBSUMsUUFBUUQsT0FBUTtRQUNyQkQsSUFBSSxDQUFDRSxLQUFLLEdBQUdELE1BQU0sQ0FBQ0MsS0FBSztJQUM3QjtBQUNKO0FBRUFKLGlDQUFpQyxHQUM3Qk0sd0VBQTRDLElBQzVDLFNBQVNHLE9BQU8sRUFBRUMsSUFBSTtJQUFJLE9BQU9ELFFBQVFFLFNBQVMsQ0FBQ0QsTUFBTUUsTUFBTTtBQUFFO0FBRXJFWix5QkFBeUIsR0FBR2MsT0FBT0MsV0FBVyxHQUMxQ0QsT0FBT0MsV0FBVyxHQUNsQixTQUFTQyxxQkFBcUJDLElBQUk7SUFBSSxPQUFPLElBQUlILE9BQU9HO0FBQU87QUFFbkVqQix3QkFBd0IsR0FBR2MsT0FBT0ssSUFBSSxHQUNsQ0wsT0FBT0ssSUFBSSxHQUNYLFNBQVNDLG9CQUFvQkMsTUFBTSxFQUFFQyxRQUFRO0lBQzNDLE9BQU8sSUFBSVIsT0FBT08sUUFBUUM7QUFDNUI7QUFFSnRCLHVCQUF1QixHQUFHLFNBQVN3QixzQkFBc0JDLFVBQVUsRUFBRUMsUUFBUTtJQUN6RSxJQUFJQyxjQUFjckIsbUJBQU9BLENBQUMsMEZBQVNtQjtJQUNuQyxJQUFJRSxZQUFZQyxPQUFPLEVBQUU7UUFDckIsSUFBSUMsU0FBUyxJQUFJTixnQkFBZ0JFLFlBQVlDLFVBQVVDO1FBQ3ZELElBQUlHLFFBQVFELE9BQU9FLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDSDtRQUM1QkMsTUFBTUcsV0FBVyxHQUFHSixPQUFPSSxXQUFXLENBQUNELElBQUksQ0FBQ0g7UUFDNUNDLE1BQU1GLE9BQU8sR0FBR0QsWUFBWUMsT0FBTztRQUNuQyxPQUFPRTtJQUNYO0lBQ0FILFlBQVlNLFdBQVcsR0FBR2xDO0lBQzFCLE9BQU80QjtBQUNYO0FBRUEsU0FBU0osZ0JBQWdCRSxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsV0FBVztJQUN0RCxJQUFJLENBQUNBLFdBQVcsR0FBR0E7SUFDbkIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO0lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNoQixJQUFJLENBQUNRLE1BQU0sR0FBRyxFQUFFO0FBQ3BCO0FBRUFYLGdCQUFnQlksU0FBUyxDQUFDSixHQUFHLEdBQUc7SUFDOUIsSUFBSSxDQUFDRyxNQUFNLENBQUNFLElBQUksQ0FBQztRQUFFLElBQUlDO1FBQVFDLE1BQU1ILFNBQVMsQ0FBQ0ksS0FBSyxDQUFDQyxJQUFJLENBQUNDO0tBQVk7SUFDdEUsT0FBTyxJQUFJO0FBQ2I7QUFFQWxCLGdCQUFnQlksU0FBUyxDQUFDTyxLQUFLLEdBQUc7SUFDaEMsSUFBSSxDQUFDUixNQUFNLEdBQUcsRUFBRTtJQUNoQixPQUFPLElBQUk7QUFDYjtBQUVBWCxnQkFBZ0JZLFNBQVMsQ0FBQ0YsV0FBVyxHQUFHLFNBQVNOLFdBQVc7SUFDeEQsSUFBSSxDQUFDQSxhQUFhO1FBQUVBLGNBQWMsSUFBSSxDQUFDQSxXQUFXO0lBQUU7SUFDcEQsSUFBSUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7SUFDNUIsSUFBSSxDQUFDUSxNQUFNLENBQUNTLE9BQU8sQ0FBQyxTQUFTQyxLQUFLO1FBQzlCLElBQUlDLE9BQU9ELEtBQUssQ0FBQyxFQUFFLENBQUNFLGNBQWM7UUFDbEMsSUFBSUMsT0FBT0gsS0FBSyxDQUFDLEVBQUUsQ0FBQ0wsS0FBSztRQUN6QixJQUFJUyxlQUFlRCxJQUFJLENBQUMsRUFBRTtRQUMxQixJQUFJQyxpQkFBa0IsS0FBSyxLQUFNQSxpQkFBaUIsTUFBTTtZQUNwREEsZUFBZSxlQUFlQSxhQUFhQyxRQUFRO1lBQ25ERixLQUFLRyxNQUFNLENBQUMsR0FBRyxHQUFHRixjQUFjSCxNQUFNbkI7WUFDdENDLFlBQVl3QixLQUFLLENBQUNDLFFBQVFMO1FBQzlCO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3V0aWxzLmpzPzFlNmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG5vb3AgPSBleHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxufTtcblxuZXhwb3J0cy5ldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50ID1cbiAgICByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCB8fFxuICAgIGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDsgfTtcblxuZXhwb3J0cy5idWZmZXJBbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSA/XG4gICAgQnVmZmVyLmFsbG9jVW5zYWZlIDpcbiAgICBmdW5jdGlvbiBvbGRCdWZmZXJBbGxvY1Vuc2FmZShzaXplKSB7IHJldHVybiBuZXcgQnVmZmVyKHNpemUpOyB9O1xuXG5leHBvcnRzLmJ1ZmZlckZyb21TdHJpbmcgPSBCdWZmZXIuZnJvbSA/XG4gICAgQnVmZmVyLmZyb20gOlxuICAgIGZ1bmN0aW9uIG9sZEJ1ZmZlckZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyaW5nLCBlbmNvZGluZyk7XG4gICAgfTtcblxuZXhwb3J0cy5CdWZmZXJpbmdMb2dnZXIgPSBmdW5jdGlvbiBjcmVhdGVCdWZmZXJpbmdMb2dnZXIoaWRlbnRpZmllciwgdW5pcXVlSUQpIHtcbiAgICB2YXIgbG9nRnVuY3Rpb24gPSByZXF1aXJlKCdkZWJ1ZycpKGlkZW50aWZpZXIpO1xuICAgIGlmIChsb2dGdW5jdGlvbi5lbmFibGVkKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBuZXcgQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlELCBsb2dGdW5jdGlvbik7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIpO1xuICAgICAgICBkZWJ1Zy5wcmludE91dHB1dCA9IGxvZ2dlci5wcmludE91dHB1dC5iaW5kKGxvZ2dlcik7XG4gICAgICAgIGRlYnVnLmVuYWJsZWQgPSBsb2dGdW5jdGlvbi5lbmFibGVkO1xuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIGxvZ0Z1bmN0aW9uLnByaW50T3V0cHV0ID0gbm9vcDtcbiAgICByZXR1cm4gbG9nRnVuY3Rpb247XG59O1xuXG5mdW5jdGlvbiBCdWZmZXJpbmdMb2dnZXIoaWRlbnRpZmllciwgdW5pcXVlSUQsIGxvZ0Z1bmN0aW9uKSB7XG4gICAgdGhpcy5sb2dGdW5jdGlvbiA9IGxvZ0Z1bmN0aW9uO1xuICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgdGhpcy51bmlxdWVJRCA9IHVuaXF1ZUlEO1xuICAgIHRoaXMuYnVmZmVyID0gW107XG59XG5cbkJ1ZmZlcmluZ0xvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnVmZmVyLnB1c2goWyBuZXcgRGF0ZSgpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpIF0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcmluZ0xvZ2dlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLnByaW50T3V0cHV0ID0gZnVuY3Rpb24obG9nRnVuY3Rpb24pIHtcbiAgICBpZiAoIWxvZ0Z1bmN0aW9uKSB7IGxvZ0Z1bmN0aW9uID0gdGhpcy5sb2dGdW5jdGlvbjsgfVxuICAgIHZhciB1bmlxdWVJRCA9IHRoaXMudW5pcXVlSUQ7XG4gICAgdGhpcy5idWZmZXIuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IGVudHJ5WzBdLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHZhciBhcmdzID0gZW50cnlbMV0uc2xpY2UoKTtcbiAgICAgICAgdmFyIGZvcm1hdFN0cmluZyA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChmb3JtYXRTdHJpbmcgIT09ICh2b2lkIDApICYmIGZvcm1hdFN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0U3RyaW5nID0gJyVzIC0gJXMgLSAnICsgZm9ybWF0U3RyaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCBmb3JtYXRTdHJpbmcsIGRhdGUsIHVuaXF1ZUlEKTtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmFwcGx5KGdsb2JhbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iXSwibmFtZXMiOlsibm9vcCIsImV4cG9ydHMiLCJleHRlbmQiLCJkZXN0Iiwic291cmNlIiwicHJvcCIsImV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwibGlzdGVuZXJDb3VudCIsImVtaXR0ZXIiLCJ0eXBlIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIm9sZEJ1ZmZlckFsbG9jVW5zYWZlIiwic2l6ZSIsImJ1ZmZlckZyb21TdHJpbmciLCJmcm9tIiwib2xkQnVmZmVyRnJvbVN0cmluZyIsInN0cmluZyIsImVuY29kaW5nIiwiQnVmZmVyaW5nTG9nZ2VyIiwiY3JlYXRlQnVmZmVyaW5nTG9nZ2VyIiwiaWRlbnRpZmllciIsInVuaXF1ZUlEIiwibG9nRnVuY3Rpb24iLCJlbmFibGVkIiwibG9nZ2VyIiwiZGVidWciLCJsb2ciLCJiaW5kIiwicHJpbnRPdXRwdXQiLCJidWZmZXIiLCJwcm90b3R5cGUiLCJwdXNoIiwiRGF0ZSIsIkFycmF5Iiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwiY2xlYXIiLCJmb3JFYWNoIiwiZW50cnkiLCJkYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJhcmdzIiwiZm9ybWF0U3RyaW5nIiwidG9TdHJpbmciLCJzcGxpY2UiLCJhcHBseSIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var noop = exports.noop = function() {};\nexports.extend = function extend(dest, source) {\n    for(var prop in source){\n        dest[prop] = source[prop];\n    }\n};\nexports.eventEmitterListenerCount = (__webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount) || function(emitter, type) {\n    return emitter.listeners(type).length;\n};\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {\n    return new Buffer(size);\n};\nexports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {\n    return new Buffer(string, encoding);\n};\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\nBufferingLogger.prototype.log = function() {\n    this.buffer.push([\n        new Date(),\n        Array.prototype.slice.call(arguments)\n    ]);\n    return this;\n};\nBufferingLogger.prototype.clear = function() {\n    this.buffer = [];\n    return this;\n};\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) {\n        logFunction = this.logFunction;\n    }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== void 0 && formatString !== null) {\n            formatString = \"%s - %s - \" + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxPQUFPQyxZQUFZLEdBQUcsWUFBVztBQUVyQ0EsY0FBYyxHQUFHLFNBQVNDLE9BQU9DLElBQUksRUFBRUMsTUFBTTtJQUN6QyxJQUFLLElBQUlDLFFBQVFELE9BQVE7UUFDckJELElBQUksQ0FBQ0UsS0FBSyxHQUFHRCxNQUFNLENBQUNDLEtBQUs7SUFDN0I7QUFDSjtBQUVBSixpQ0FBaUMsR0FDN0JNLHdFQUE0QyxJQUM1QyxTQUFTRyxPQUFPLEVBQUVDLElBQUk7SUFBSSxPQUFPRCxRQUFRRSxTQUFTLENBQUNELE1BQU1FLE1BQU07QUFBRTtBQUVyRVoseUJBQXlCLEdBQUdjLE9BQU9DLFdBQVcsR0FDMUNELE9BQU9DLFdBQVcsR0FDbEIsU0FBU0MscUJBQXFCQyxJQUFJO0lBQUksT0FBTyxJQUFJSCxPQUFPRztBQUFPO0FBRW5FakIsd0JBQXdCLEdBQUdjLE9BQU9LLElBQUksR0FDbENMLE9BQU9LLElBQUksR0FDWCxTQUFTQyxvQkFBb0JDLE1BQU0sRUFBRUMsUUFBUTtJQUMzQyxPQUFPLElBQUlSLE9BQU9PLFFBQVFDO0FBQzVCO0FBRUp0Qix1QkFBdUIsR0FBRyxTQUFTd0Isc0JBQXNCQyxVQUFVLEVBQUVDLFFBQVE7SUFDekUsSUFBSUMsY0FBY3JCLG1CQUFPQSxDQUFDLCtFQUFTbUI7SUFDbkMsSUFBSUUsWUFBWUMsT0FBTyxFQUFFO1FBQ3JCLElBQUlDLFNBQVMsSUFBSU4sZ0JBQWdCRSxZQUFZQyxVQUFVQztRQUN2RCxJQUFJRyxRQUFRRCxPQUFPRSxHQUFHLENBQUNDLElBQUksQ0FBQ0g7UUFDNUJDLE1BQU1HLFdBQVcsR0FBR0osT0FBT0ksV0FBVyxDQUFDRCxJQUFJLENBQUNIO1FBQzVDQyxNQUFNRixPQUFPLEdBQUdELFlBQVlDLE9BQU87UUFDbkMsT0FBT0U7SUFDWDtJQUNBSCxZQUFZTSxXQUFXLEdBQUdsQztJQUMxQixPQUFPNEI7QUFDWDtBQUVBLFNBQVNKLGdCQUFnQkUsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLFdBQVc7SUFDdEQsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0YsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDUSxNQUFNLEdBQUcsRUFBRTtBQUNwQjtBQUVBWCxnQkFBZ0JZLFNBQVMsQ0FBQ0osR0FBRyxHQUFHO0lBQzlCLElBQUksQ0FBQ0csTUFBTSxDQUFDRSxJQUFJLENBQUM7UUFBRSxJQUFJQztRQUFRQyxNQUFNSCxTQUFTLENBQUNJLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQztLQUFZO0lBQ3RFLE9BQU8sSUFBSTtBQUNiO0FBRUFsQixnQkFBZ0JZLFNBQVMsQ0FBQ08sS0FBSyxHQUFHO0lBQ2hDLElBQUksQ0FBQ1IsTUFBTSxHQUFHLEVBQUU7SUFDaEIsT0FBTyxJQUFJO0FBQ2I7QUFFQVgsZ0JBQWdCWSxTQUFTLENBQUNGLFdBQVcsR0FBRyxTQUFTTixXQUFXO0lBQ3hELElBQUksQ0FBQ0EsYUFBYTtRQUFFQSxjQUFjLElBQUksQ0FBQ0EsV0FBVztJQUFFO0lBQ3BELElBQUlELFdBQVcsSUFBSSxDQUFDQSxRQUFRO0lBQzVCLElBQUksQ0FBQ1EsTUFBTSxDQUFDUyxPQUFPLENBQUMsU0FBU0MsS0FBSztRQUM5QixJQUFJQyxPQUFPRCxLQUFLLENBQUMsRUFBRSxDQUFDRSxjQUFjO1FBQ2xDLElBQUlDLE9BQU9ILEtBQUssQ0FBQyxFQUFFLENBQUNMLEtBQUs7UUFDekIsSUFBSVMsZUFBZUQsSUFBSSxDQUFDLEVBQUU7UUFDMUIsSUFBSUMsaUJBQWtCLEtBQUssS0FBTUEsaUJBQWlCLE1BQU07WUFDcERBLGVBQWUsZUFBZUEsYUFBYUMsUUFBUTtZQUNuREYsS0FBS0csTUFBTSxDQUFDLEdBQUcsR0FBR0YsY0FBY0gsTUFBTW5CO1lBQ3RDQyxZQUFZd0IsS0FBSyxDQUFDQyxRQUFRTDtRQUM5QjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcz8xZTZiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBub29wID0gZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCA9XG4gICAgcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgfHxcbiAgICBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7IHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7IH07XG5cbmV4cG9ydHMuYnVmZmVyQWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgP1xuICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZSA6XG4gICAgZnVuY3Rpb24gb2xkQnVmZmVyQWxsb2NVbnNhZmUoc2l6ZSkgeyByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTsgfTtcblxuZXhwb3J0cy5idWZmZXJGcm9tU3RyaW5nID0gQnVmZmVyLmZyb20gP1xuICAgIEJ1ZmZlci5mcm9tIDpcbiAgICBmdW5jdGlvbiBvbGRCdWZmZXJGcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZywgZW5jb2RpbmcpO1xuICAgIH07XG5cbmV4cG9ydHMuQnVmZmVyaW5nTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlEKSB7XG4gICAgdmFyIGxvZ0Z1bmN0aW9uID0gcmVxdWlyZSgnZGVidWcnKShpZGVudGlmaWVyKTtcbiAgICBpZiAobG9nRnVuY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICB2YXIgbG9nZ2VyID0gbmV3IEJ1ZmZlcmluZ0xvZ2dlcihpZGVudGlmaWVyLCB1bmlxdWVJRCwgbG9nRnVuY3Rpb24pO1xuICAgICAgICB2YXIgZGVidWcgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyKTtcbiAgICAgICAgZGVidWcucHJpbnRPdXRwdXQgPSBsb2dnZXIucHJpbnRPdXRwdXQuYmluZChsb2dnZXIpO1xuICAgICAgICBkZWJ1Zy5lbmFibGVkID0gbG9nRnVuY3Rpb24uZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICBsb2dGdW5jdGlvbi5wcmludE91dHB1dCA9IG5vb3A7XG4gICAgcmV0dXJuIGxvZ0Z1bmN0aW9uO1xufTtcblxuZnVuY3Rpb24gQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlELCBsb2dGdW5jdGlvbikge1xuICAgIHRoaXMubG9nRnVuY3Rpb24gPSBsb2dGdW5jdGlvbjtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIHRoaXMudW5pcXVlSUQgPSB1bmlxdWVJRDtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlci5wdXNoKFsgbmV3IERhdGUoKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyaW5nTG9nZ2VyLnByb3RvdHlwZS5wcmludE91dHB1dCA9IGZ1bmN0aW9uKGxvZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKCFsb2dGdW5jdGlvbikgeyBsb2dGdW5jdGlvbiA9IHRoaXMubG9nRnVuY3Rpb247IH1cbiAgICB2YXIgdW5pcXVlSUQgPSB0aGlzLnVuaXF1ZUlEO1xuICAgIHRoaXMuYnVmZmVyLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBlbnRyeVswXS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgYXJncyA9IGVudHJ5WzFdLnNsaWNlKCk7XG4gICAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoZm9ybWF0U3RyaW5nICE9PSAodm9pZCAwKSAmJiBmb3JtYXRTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9ICclcyAtICVzIC0gJyArIGZvcm1hdFN0cmluZy50b1N0cmluZygpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwgZm9ybWF0U3RyaW5nLCBkYXRlLCB1bmlxdWVJRCk7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5hcHBseShnbG9iYWwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIm5vb3AiLCJleHBvcnRzIiwiZXh0ZW5kIiwiZGVzdCIsInNvdXJjZSIsInByb3AiLCJldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50IiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsImxpc3RlbmVyQ291bnQiLCJlbWl0dGVyIiwidHlwZSIsImxpc3RlbmVycyIsImxlbmd0aCIsImJ1ZmZlckFsbG9jVW5zYWZlIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJvbGRCdWZmZXJBbGxvY1Vuc2FmZSIsInNpemUiLCJidWZmZXJGcm9tU3RyaW5nIiwiZnJvbSIsIm9sZEJ1ZmZlckZyb21TdHJpbmciLCJzdHJpbmciLCJlbmNvZGluZyIsIkJ1ZmZlcmluZ0xvZ2dlciIsImNyZWF0ZUJ1ZmZlcmluZ0xvZ2dlciIsImlkZW50aWZpZXIiLCJ1bmlxdWVJRCIsImxvZ0Z1bmN0aW9uIiwiZW5hYmxlZCIsImxvZ2dlciIsImRlYnVnIiwibG9nIiwiYmluZCIsInByaW50T3V0cHV0IiwiYnVmZmVyIiwicHJvdG90eXBlIiwicHVzaCIsIkRhdGUiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImNsZWFyIiwiZm9yRWFjaCIsImVudHJ5IiwiZGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiYXJncyIsImZvcm1hdFN0cmluZyIsInRvU3RyaW5nIiwic3BsaWNlIiwiYXBwbHkiLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../package.json */ \"(action-browser)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFBQSw2SEFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzPzE0MjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsa0hBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvdmVyc2lvbi5qcz8xNDIzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = {\n    \"server\": __webpack_require__(/*! ./WebSocketServer */ \"(action-browser)/./node_modules/websocket/lib/WebSocketServer.js\"),\n    \"client\": __webpack_require__(/*! ./WebSocketClient */ \"(action-browser)/./node_modules/websocket/lib/WebSocketClient.js\"),\n    \"router\": __webpack_require__(/*! ./WebSocketRouter */ \"(action-browser)/./node_modules/websocket/lib/WebSocketRouter.js\"),\n    \"frame\": __webpack_require__(/*! ./WebSocketFrame */ \"(action-browser)/./node_modules/websocket/lib/WebSocketFrame.js\"),\n    \"request\": __webpack_require__(/*! ./WebSocketRequest */ \"(action-browser)/./node_modules/websocket/lib/WebSocketRequest.js\"),\n    \"connection\": __webpack_require__(/*! ./WebSocketConnection */ \"(action-browser)/./node_modules/websocket/lib/WebSocketConnection.js\"),\n    \"w3cwebsocket\": __webpack_require__(/*! ./W3CWebSocket */ \"(action-browser)/./node_modules/websocket/lib/W3CWebSocket.js\"),\n    \"deprecation\": __webpack_require__(/*! ./Deprecation */ \"(action-browser)/./node_modules/websocket/lib/Deprecation.js\"),\n    \"version\": __webpack_require__(/*! ./version */ \"(action-browser)/./node_modules/websocket/lib/version.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNiLFVBQWlCQyxtQkFBT0EsQ0FBQztJQUN6QixVQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsVUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFNBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixXQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsY0FBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGdCQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsZUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFdBQWlCQSxtQkFBT0EsQ0FBQztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3dlYnNvY2tldC5qcz9lOTcyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdzZXJ2ZXInICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRTZXJ2ZXInKSxcbiAgICAnY2xpZW50JyAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0Q2xpZW50JyksXG4gICAgJ3JvdXRlcicgICAgICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldFJvdXRlcicpLFxuICAgICdmcmFtZScgICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRGcmFtZScpLFxuICAgICdyZXF1ZXN0JyAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRSZXF1ZXN0JyksXG4gICAgJ2Nvbm5lY3Rpb24nICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldENvbm5lY3Rpb24nKSxcbiAgICAndzNjd2Vic29ja2V0JyA6IHJlcXVpcmUoJy4vVzNDV2ViU29ja2V0JyksXG4gICAgJ2RlcHJlY2F0aW9uJyAgOiByZXF1aXJlKCcuL0RlcHJlY2F0aW9uJyksXG4gICAgJ3ZlcnNpb24nICAgICAgOiByZXF1aXJlKCcuL3ZlcnNpb24nKVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = {\n    \"server\": __webpack_require__(/*! ./WebSocketServer */ \"(rsc)/./node_modules/websocket/lib/WebSocketServer.js\"),\n    \"client\": __webpack_require__(/*! ./WebSocketClient */ \"(rsc)/./node_modules/websocket/lib/WebSocketClient.js\"),\n    \"router\": __webpack_require__(/*! ./WebSocketRouter */ \"(rsc)/./node_modules/websocket/lib/WebSocketRouter.js\"),\n    \"frame\": __webpack_require__(/*! ./WebSocketFrame */ \"(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\"),\n    \"request\": __webpack_require__(/*! ./WebSocketRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\"),\n    \"connection\": __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\"),\n    \"w3cwebsocket\": __webpack_require__(/*! ./W3CWebSocket */ \"(rsc)/./node_modules/websocket/lib/W3CWebSocket.js\"),\n    \"deprecation\": __webpack_require__(/*! ./Deprecation */ \"(rsc)/./node_modules/websocket/lib/Deprecation.js\"),\n    \"version\": __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/websocket/lib/version.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUc7SUFDYixVQUFpQkMsbUJBQU9BLENBQUM7SUFDekIsVUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFVBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixTQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsV0FBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGNBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixnQkFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGVBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixXQUFpQkEsbUJBQU9BLENBQUM7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanM/ZTk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnc2VydmVyJyAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0U2VydmVyJyksXG4gICAgJ2NsaWVudCcgICAgICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpLFxuICAgICdyb3V0ZXInICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRSb3V0ZXInKSxcbiAgICAnZnJhbWUnICAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0RnJhbWUnKSxcbiAgICAncmVxdWVzdCcgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0UmVxdWVzdCcpLFxuICAgICdjb25uZWN0aW9uJyAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyksXG4gICAgJ3czY3dlYnNvY2tldCcgOiByZXF1aXJlKCcuL1czQ1dlYlNvY2tldCcpLFxuICAgICdkZXByZWNhdGlvbicgIDogcmVxdWlyZSgnLi9EZXByZWNhdGlvbicpLFxuICAgICd2ZXJzaW9uJyAgICAgIDogcmVxdWlyZSgnLi92ZXJzaW9uJylcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/websocket.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ \nexports = module.exports = __webpack_require__(/*! ./debug */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = \"undefined\" != typeof chrome && \"undefined\" != typeof chrome.storage ? chrome.storage.local : localstorage();\n/**\n * Colors.\n */ exports.colors = [\n    \"lightseagreen\",\n    \"forestgreen\",\n    \"goldenrod\",\n    \"dodgerblue\",\n    \"darkorchid\",\n    \"crimson\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ function useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ exports.formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (err) {\n        return \"[UnexpectedJSONParseError]: \" + err.message;\n    }\n};\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var useColors = this.useColors;\n    args[0] = (useColors ? \"%c\" : \"\") + this.namespace + (useColors ? \" %c\" : \" \") + args[0] + (useColors ? \"%c \" : \" \") + \"+\" + exports.humanize(this.diff);\n    if (!useColors) return;\n    var c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // the final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    var index = 0;\n    var lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, function(match) {\n        if (\"%%\" === match) return;\n        index++;\n        if (\"%c\" === match) {\n            // we only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */ function log() {\n    // this hackery is required for IE8/9, where\n    // the `console.log` function doesn't have 'apply'\n    return \"object\" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (null == namespaces) {\n            exports.storage.removeItem(\"debug\");\n        } else {\n            exports.storage.debug = namespaces;\n        }\n    } catch (e) {}\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    var r;\n    try {\n        r = exports.storage.debug;\n    } catch (e) {}\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */ exports.enable(load());\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        return window.localStorage;\n    } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFFREEsVUFBVUMsZ0lBQXlCO0FBQ25DRCxXQUFXLEdBQUdHO0FBQ2RILGtCQUFrQixHQUFHSTtBQUNyQkosWUFBWSxHQUFHSztBQUNmTCxZQUFZLEdBQUdNO0FBQ2ZOLGlCQUFpQixHQUFHTztBQUNwQlAsZUFBZSxHQUFHLGVBQWUsT0FBT1MsVUFDdEIsZUFBZSxPQUFPQSxPQUFPRCxPQUFPLEdBQ2xDQyxPQUFPRCxPQUFPLENBQUNFLEtBQUssR0FDcEJDO0FBRXBCOztDQUVDLEdBRURYLGNBQWMsR0FBRztJQUNmO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7Ozs7OztDQU1DLEdBRUQsU0FBU087SUFDUCw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLGFBQWE7SUFDYixJQUFJLEtBQTJFLEVBQVksRUFFMUY7SUFFRCx3REFBd0Q7SUFDeEQsNEZBQTRGO0lBQzVGLE9BQU8sT0FBUVMsYUFBYSxlQUFlQSxTQUFTQyxlQUFlLElBQUlELFNBQVNDLGVBQWUsQ0FBQ0MsS0FBSyxJQUFJRixTQUFTQyxlQUFlLENBQUNDLEtBQUssQ0FBQ0MsZ0JBQWdCLElBQ3RKLHVEQUF1RDtJQUN0RCxNQUErQyxJQUFLTixDQUFBQSxDQUEyRSxLQUNoSSxxQkFBcUI7SUFDckIsOEVBQThFO0lBQzdFLE9BQU9XLGNBQWMsZUFBZUEsVUFBVUMsU0FBUyxJQUFJRCxVQUFVQyxTQUFTLENBQUNDLFdBQVcsR0FBR0MsS0FBSyxDQUFDLHFCQUFxQkMsU0FBU0MsT0FBT0MsRUFBRSxFQUFFLE9BQU8sTUFDcEosbUVBQW1FO0lBQ2xFLE9BQU9OLGNBQWMsZUFBZUEsVUFBVUMsU0FBUyxJQUFJRCxVQUFVQyxTQUFTLENBQUNDLFdBQVcsR0FBR0MsS0FBSyxDQUFDO0FBQ3hHO0FBRUE7O0NBRUMsR0FFRDNCLG9CQUFvQixHQUFHLFNBQVNpQyxDQUFDO0lBQy9CLElBQUk7UUFDRixPQUFPQyxLQUFLQyxTQUFTLENBQUNGO0lBQ3hCLEVBQUUsT0FBT0csS0FBSztRQUNaLE9BQU8saUNBQWlDQSxJQUFJQyxPQUFPO0lBQ3JEO0FBQ0Y7QUFHQTs7OztDQUlDLEdBRUQsU0FBU2pDLFdBQVdrQyxJQUFJO0lBQ3RCLElBQUkvQixZQUFZLElBQUksQ0FBQ0EsU0FBUztJQUU5QitCLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQy9CLFlBQVksT0FBTyxFQUFDLElBQzNCLElBQUksQ0FBQ2dDLFNBQVMsR0FDYmhDLENBQUFBLFlBQVksUUFBUSxHQUFFLElBQ3ZCK0IsSUFBSSxDQUFDLEVBQUUsR0FDTi9CLENBQUFBLFlBQVksUUFBUSxHQUFFLElBQ3ZCLE1BQU1QLFFBQVF3QyxRQUFRLENBQUMsSUFBSSxDQUFDQyxJQUFJO0lBRXBDLElBQUksQ0FBQ2xDLFdBQVc7SUFFaEIsSUFBSW1DLElBQUksWUFBWSxJQUFJLENBQUNDLEtBQUs7SUFDOUJMLEtBQUtNLE1BQU0sQ0FBQyxHQUFHLEdBQUdGLEdBQUc7SUFFckIsa0VBQWtFO0lBQ2xFLGdFQUFnRTtJQUNoRSxzREFBc0Q7SUFDdEQsSUFBSUcsUUFBUTtJQUNaLElBQUlDLFFBQVE7SUFDWlIsSUFBSSxDQUFDLEVBQUUsQ0FBQ1MsT0FBTyxDQUFDLGVBQWUsU0FBU3BCLEtBQUs7UUFDM0MsSUFBSSxTQUFTQSxPQUFPO1FBQ3BCa0I7UUFDQSxJQUFJLFNBQVNsQixPQUFPO1lBQ2xCLDBDQUEwQztZQUMxQyx5Q0FBeUM7WUFDekNtQixRQUFRRDtRQUNWO0lBQ0Y7SUFFQVAsS0FBS00sTUFBTSxDQUFDRSxPQUFPLEdBQUdKO0FBQ3hCO0FBRUE7Ozs7O0NBS0MsR0FFRCxTQUFTdkM7SUFDUCw0Q0FBNEM7SUFDNUMsa0RBQWtEO0lBQ2xELE9BQU8sYUFBYSxPQUFPaUIsV0FDdEJBLFFBQVFqQixHQUFHLElBQ1g2QyxTQUFTQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDL0IsUUFBUWpCLEdBQUcsRUFBRWlCLFNBQVNnQztBQUMzRDtBQUVBOzs7OztDQUtDLEdBRUQsU0FBUy9DLEtBQUtnRCxVQUFVO0lBQ3RCLElBQUk7UUFDRixJQUFJLFFBQVFBLFlBQVk7WUFDdEJyRCxRQUFRUSxPQUFPLENBQUM4QyxVQUFVLENBQUM7UUFDN0IsT0FBTztZQUNMdEQscUJBQXFCLEdBQUdxRDtRQUMxQjtJQUNGLEVBQUUsT0FBTUcsR0FBRyxDQUFDO0FBQ2Q7QUFFQTs7Ozs7Q0FLQyxHQUVELFNBQVNsRDtJQUNQLElBQUltRDtJQUNKLElBQUk7UUFDRkEsSUFBSXpELFFBQVFRLE9BQU8sQ0FBQytDLEtBQUs7SUFDM0IsRUFBRSxPQUFNQyxHQUFHLENBQUM7SUFFWixzRUFBc0U7SUFDdEUsSUFBSSxDQUFDQyxLQUFLLE9BQU8zQyxZQUFZLGVBQWUsU0FBU0EsU0FBUztRQUM1RDJDLElBQUkzQyxRQUFRNEMsR0FBRyxDQUFDQyxLQUFLO0lBQ3ZCO0lBRUEsT0FBT0Y7QUFDVDtBQUVBOztDQUVDLEdBRUR6RCxRQUFRNEQsTUFBTSxDQUFDdEQ7QUFFZjs7Ozs7Ozs7O0NBU0MsR0FFRCxTQUFTSztJQUNQLElBQUk7UUFDRixPQUFPRSxPQUFPZ0QsWUFBWTtJQUM1QixFQUFFLE9BQU9MLEdBQUcsQ0FBQztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MmM1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwiY2hyb21lIiwibG9jYWwiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJ3aW5kb3ciLCJwcm9jZXNzIiwidHlwZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiY29uc29sZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJwYXJzZUludCIsIlJlZ0V4cCIsIiQxIiwiZm9ybWF0dGVycyIsImoiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIm1lc3NhZ2UiLCJhcmdzIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImFyZ3VtZW50cyIsIm5hbWVzcGFjZXMiLCJyZW1vdmVJdGVtIiwiZGVidWciLCJlIiwiciIsImVudiIsIkRFQlVHIiwiZW5hYmxlIiwibG9jYWxTdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ \nexports = module.exports = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = \"undefined\" != typeof chrome && \"undefined\" != typeof chrome.storage ? chrome.storage.local : localstorage();\n/**\n * Colors.\n */ exports.colors = [\n    \"lightseagreen\",\n    \"forestgreen\",\n    \"goldenrod\",\n    \"dodgerblue\",\n    \"darkorchid\",\n    \"crimson\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ function useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ exports.formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (err) {\n        return \"[UnexpectedJSONParseError]: \" + err.message;\n    }\n};\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var useColors = this.useColors;\n    args[0] = (useColors ? \"%c\" : \"\") + this.namespace + (useColors ? \" %c\" : \" \") + args[0] + (useColors ? \"%c \" : \" \") + \"+\" + exports.humanize(this.diff);\n    if (!useColors) return;\n    var c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // the final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    var index = 0;\n    var lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, function(match) {\n        if (\"%%\" === match) return;\n        index++;\n        if (\"%c\" === match) {\n            // we only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */ function log() {\n    // this hackery is required for IE8/9, where\n    // the `console.log` function doesn't have 'apply'\n    return \"object\" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (null == namespaces) {\n            exports.storage.removeItem(\"debug\");\n        } else {\n            exports.storage.debug = namespaces;\n        }\n    } catch (e) {}\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    var r;\n    try {\n        r = exports.storage.debug;\n    } catch (e) {}\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */ exports.enable(load());\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        return window.localStorage;\n    } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDO0FBRURBLFVBQVVDLHFIQUF5QjtBQUNuQ0QsV0FBVyxHQUFHRztBQUNkSCxrQkFBa0IsR0FBR0k7QUFDckJKLFlBQVksR0FBR0s7QUFDZkwsWUFBWSxHQUFHTTtBQUNmTixpQkFBaUIsR0FBR087QUFDcEJQLGVBQWUsR0FBRyxlQUFlLE9BQU9TLFVBQ3RCLGVBQWUsT0FBT0EsT0FBT0QsT0FBTyxHQUNsQ0MsT0FBT0QsT0FBTyxDQUFDRSxLQUFLLEdBQ3BCQztBQUVwQjs7Q0FFQyxHQUVEWCxjQUFjLEdBQUc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVEOzs7Ozs7Q0FNQyxHQUVELFNBQVNPO0lBQ1AsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUEyRSxFQUFZLEVBRTFGO0lBRUQsd0RBQXdEO0lBQ3hELDRGQUE0RjtJQUM1RixPQUFPLE9BQVFTLGFBQWEsZUFBZUEsU0FBU0MsZUFBZSxJQUFJRCxTQUFTQyxlQUFlLENBQUNDLEtBQUssSUFBSUYsU0FBU0MsZUFBZSxDQUFDQyxLQUFLLENBQUNDLGdCQUFnQixJQUN0Six1REFBdUQ7SUFDdEQsTUFBK0MsSUFBS04sQ0FBQUEsQ0FBMkUsS0FDaEkscUJBQXFCO0lBQ3JCLDhFQUE4RTtJQUM3RSxPQUFPVyxjQUFjLGVBQWVBLFVBQVVDLFNBQVMsSUFBSUQsVUFBVUMsU0FBUyxDQUFDQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxxQkFBcUJDLFNBQVNDLE9BQU9DLEVBQUUsRUFBRSxPQUFPLE1BQ3BKLG1FQUFtRTtJQUNsRSxPQUFPTixjQUFjLGVBQWVBLFVBQVVDLFNBQVMsSUFBSUQsVUFBVUMsU0FBUyxDQUFDQyxXQUFXLEdBQUdDLEtBQUssQ0FBQztBQUN4RztBQUVBOztDQUVDLEdBRUQzQixvQkFBb0IsR0FBRyxTQUFTaUMsQ0FBQztJQUMvQixJQUFJO1FBQ0YsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN4QixFQUFFLE9BQU9HLEtBQUs7UUFDWixPQUFPLGlDQUFpQ0EsSUFBSUMsT0FBTztJQUNyRDtBQUNGO0FBR0E7Ozs7Q0FJQyxHQUVELFNBQVNqQyxXQUFXa0MsSUFBSTtJQUN0QixJQUFJL0IsWUFBWSxJQUFJLENBQUNBLFNBQVM7SUFFOUIrQixJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMvQixZQUFZLE9BQU8sRUFBQyxJQUMzQixJQUFJLENBQUNnQyxTQUFTLEdBQ2JoQyxDQUFBQSxZQUFZLFFBQVEsR0FBRSxJQUN2QitCLElBQUksQ0FBQyxFQUFFLEdBQ04vQixDQUFBQSxZQUFZLFFBQVEsR0FBRSxJQUN2QixNQUFNUCxRQUFRd0MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsSUFBSTtJQUVwQyxJQUFJLENBQUNsQyxXQUFXO0lBRWhCLElBQUltQyxJQUFJLFlBQVksSUFBSSxDQUFDQyxLQUFLO0lBQzlCTCxLQUFLTSxNQUFNLENBQUMsR0FBRyxHQUFHRixHQUFHO0lBRXJCLGtFQUFrRTtJQUNsRSxnRUFBZ0U7SUFDaEUsc0RBQXNEO0lBQ3RELElBQUlHLFFBQVE7SUFDWixJQUFJQyxRQUFRO0lBQ1pSLElBQUksQ0FBQyxFQUFFLENBQUNTLE9BQU8sQ0FBQyxlQUFlLFNBQVNwQixLQUFLO1FBQzNDLElBQUksU0FBU0EsT0FBTztRQUNwQmtCO1FBQ0EsSUFBSSxTQUFTbEIsT0FBTztZQUNsQiwwQ0FBMEM7WUFDMUMseUNBQXlDO1lBQ3pDbUIsUUFBUUQ7UUFDVjtJQUNGO0lBRUFQLEtBQUtNLE1BQU0sQ0FBQ0UsT0FBTyxHQUFHSjtBQUN4QjtBQUVBOzs7OztDQUtDLEdBRUQsU0FBU3ZDO0lBQ1AsNENBQTRDO0lBQzVDLGtEQUFrRDtJQUNsRCxPQUFPLGFBQWEsT0FBT2lCLFdBQ3RCQSxRQUFRakIsR0FBRyxJQUNYNkMsU0FBU0MsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQy9CLFFBQVFqQixHQUFHLEVBQUVpQixTQUFTZ0M7QUFDM0Q7QUFFQTs7Ozs7Q0FLQyxHQUVELFNBQVMvQyxLQUFLZ0QsVUFBVTtJQUN0QixJQUFJO1FBQ0YsSUFBSSxRQUFRQSxZQUFZO1lBQ3RCckQsUUFBUVEsT0FBTyxDQUFDOEMsVUFBVSxDQUFDO1FBQzdCLE9BQU87WUFDTHRELHFCQUFxQixHQUFHcUQ7UUFDMUI7SUFDRixFQUFFLE9BQU1HLEdBQUcsQ0FBQztBQUNkO0FBRUE7Ozs7O0NBS0MsR0FFRCxTQUFTbEQ7SUFDUCxJQUFJbUQ7SUFDSixJQUFJO1FBQ0ZBLElBQUl6RCxRQUFRUSxPQUFPLENBQUMrQyxLQUFLO0lBQzNCLEVBQUUsT0FBTUMsR0FBRyxDQUFDO0lBRVosc0VBQXNFO0lBQ3RFLElBQUksQ0FBQ0MsS0FBSyxPQUFPM0MsWUFBWSxlQUFlLFNBQVNBLFNBQVM7UUFDNUQyQyxJQUFJM0MsUUFBUTRDLEdBQUcsQ0FBQ0MsS0FBSztJQUN2QjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVEekQsUUFBUTRELE1BQU0sQ0FBQ3REO0FBRWY7Ozs7Ozs7OztDQVNDLEdBRUQsU0FBU0s7SUFDUCxJQUFJO1FBQ0YsT0FBT0UsT0FBT2dELFlBQVk7SUFDNUIsRUFBRSxPQUFPTCxHQUFHLENBQUM7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzJjNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImNocm9tZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImNvbnNvbGUiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwicGFyc2VJbnQiLCJSZWdFeHAiLCIkMSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnIiLCJtZXNzYWdlIiwiYXJncyIsIm5hbWVzcGFjZSIsImh1bWFuaXplIiwiZGlmZiIsImMiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJyZXBsYWNlIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJhcmd1bWVudHMiLCJuYW1lc3BhY2VzIiwicmVtb3ZlSXRlbSIsImRlYnVnIiwiZSIsInIiLCJlbnYiLCJERUJVRyIsImVuYWJsZSIsImxvY2FsU3RvcmFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/node_modules/debug/src/debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/debug.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */ \nexports = module.exports = createDebug.debug = createDebug[\"default\"] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"(action-browser)/./node_modules/websocket/node_modules/ms/index.js\");\n/**\n * The currently active debug mode names, and names to skip.\n */ exports.names = [];\nexports.skips = [];\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */ exports.formatters = {};\n/**\n * Previous log timestamp.\n */ var prevTime;\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */ function selectColor(namespace) {\n    var hash = 0, i;\n    for(i in namespace){\n        hash = (hash << 5) - hash + namespace.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */ function createDebug(namespace) {\n    function debug() {\n        // disabled?\n        if (!debug.enabled) return;\n        var self = debug;\n        // set `diff` timestamp\n        var curr = +new Date();\n        var ms = curr - (prevTime || curr);\n        self.diff = ms;\n        self.prev = prevTime;\n        self.curr = curr;\n        prevTime = curr;\n        // turn the `arguments` into a proper Array\n        var args = new Array(arguments.length);\n        for(var i = 0; i < args.length; i++){\n            args[i] = arguments[i];\n        }\n        args[0] = exports.coerce(args[0]);\n        if (\"string\" !== typeof args[0]) {\n            // anything else let's inspect with %O\n            args.unshift(\"%O\");\n        }\n        // apply any `formatters` transformations\n        var index = 0;\n        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n            // if we encounter an escaped % then don't increase the array index\n            if (match === \"%%\") return match;\n            index++;\n            var formatter = exports.formatters[format];\n            if (\"function\" === typeof formatter) {\n                var val = args[index];\n                match = formatter.call(self, val);\n                // now we need to remove `args[index]` since it's inlined in the `format`\n                args.splice(index, 1);\n                index--;\n            }\n            return match;\n        });\n        // apply env-specific formatting (colors, etc.)\n        exports.formatArgs.call(self, args);\n        var logFn = debug.log || exports.log || console.log.bind(console);\n        logFn.apply(self, args);\n    }\n    debug.namespace = namespace;\n    debug.enabled = exports.enabled(namespace);\n    debug.useColors = exports.useColors();\n    debug.color = selectColor(namespace);\n    // env-specific initialization logic for debug instances\n    if (\"function\" === typeof exports.init) {\n        exports.init(debug);\n    }\n    return debug;\n}\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */ function enable(namespaces) {\n    exports.save(namespaces);\n    exports.names = [];\n    exports.skips = [];\n    var split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n    var len = split.length;\n    for(var i = 0; i < len; i++){\n        if (!split[i]) continue; // ignore empty strings\n        namespaces = split[i].replace(/\\*/g, \".*?\");\n        if (namespaces[0] === \"-\") {\n            exports.skips.push(new RegExp(\"^\" + namespaces.substr(1) + \"$\"));\n        } else {\n            exports.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n        }\n    }\n}\n/**\n * Disable debug output.\n *\n * @api public\n */ function disable() {\n    exports.enable(\"\");\n}\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */ function enabled(name) {\n    var i, len;\n    for(i = 0, len = exports.skips.length; i < len; i++){\n        if (exports.skips[i].test(name)) {\n            return false;\n        }\n    }\n    for(i = 0, len = exports.names.length; i < len; i++){\n        if (exports.names[i].test(name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */ function coerce(val) {\n    if (val instanceof Error) return val.stack || val.message;\n    return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFDQTs7Ozs7Q0FLQztBQUVEQSxVQUFVQyxPQUFPRCxPQUFPLEdBQUdFLFlBQVlDLEtBQUssR0FBR0QsV0FBVyxDQUFDLFVBQVUsR0FBR0E7QUFDeEVGLGNBQWMsR0FBR0k7QUFDakJKLGVBQWUsR0FBR0s7QUFDbEJMLGNBQWMsR0FBR007QUFDakJOLGVBQWUsR0FBR087QUFDbEJQLHNIQUEyQjtBQUUzQjs7Q0FFQyxHQUVEQSxhQUFhLEdBQUcsRUFBRTtBQUNsQkEsYUFBYSxHQUFHLEVBQUU7QUFFbEI7Ozs7Q0FJQyxHQUVEQSxrQkFBa0IsR0FBRyxDQUFDO0FBRXRCOztDQUVDLEdBRUQsSUFBSWE7QUFFSjs7Ozs7Q0FLQyxHQUVELFNBQVNDLFlBQVlDLFNBQVM7SUFDNUIsSUFBSUMsT0FBTyxHQUFHQztJQUVkLElBQUtBLEtBQUtGLFVBQVc7UUFDbkJDLE9BQVEsQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVRyxVQUFVLENBQUNEO1FBQ3BERCxRQUFRLEdBQUcsMkJBQTJCO0lBQ3hDO0lBRUEsT0FBT2hCLFFBQVFtQixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ0wsUUFBUWhCLFFBQVFtQixNQUFNLENBQUNHLE1BQU0sQ0FBQztBQUMvRDtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNwQixZQUFZYSxTQUFTO0lBRTVCLFNBQVNaO1FBQ1AsWUFBWTtRQUNaLElBQUksQ0FBQ0EsTUFBTUksT0FBTyxFQUFFO1FBRXBCLElBQUlnQixPQUFPcEI7UUFFWCx1QkFBdUI7UUFDdkIsSUFBSXFCLE9BQU8sQ0FBQyxJQUFJQztRQUNoQixJQUFJQyxLQUFLRixPQUFRWCxDQUFBQSxZQUFZVyxJQUFHO1FBQ2hDRCxLQUFLSSxJQUFJLEdBQUdEO1FBQ1pILEtBQUtLLElBQUksR0FBR2Y7UUFDWlUsS0FBS0MsSUFBSSxH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QU1yRCxRQUFRVyxLQUFLLENBQUNXLE1BQU0sRUFBRUwsSUFBSW9DLEtBQUtwQyxJQUFLO1FBQ3BELElBQUlqQixRQUFRVyxLQUFLLENBQUNNLEVBQUUsQ0FBQ3lDLElBQUksQ0FBQ0QsT0FBTztZQUMvQixPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUt4QyxJQUFJLEdBQUdvQyxNQUFNckQsUUFBUVUsS0FBSyxDQUFDWSxNQUFNLEVBQUVMLElBQUlvQyxLQUFLcEMsSUFBSztRQUNwRCxJQUFJakIsUUFBUVUsS0FBSyxDQUFDTyxFQUFFLENBQUN5QyxJQUFJLENBQUNELE9BQU87WUFDL0IsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTckQsT0FBT2tDLEdBQUc7SUFDakIsSUFBSUEsZUFBZXFCLE9BQU8sT0FBT3JCLElBQUlzQixLQUFLLElBQUl0QixJQUFJdUIsT0FBTztJQUN6RCxPQUFPdkI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcz9kMjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIm1vZHVsZSIsImNyZWF0ZURlYnVnIiwiZGVidWciLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwicHJldlRpbWUiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJpIiwiY2hhckNvZGVBdCIsImNvbG9ycyIsIk1hdGgiLCJhYnMiLCJsZW5ndGgiLCJzZWxmIiwiY3VyciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImNvbnNvbGUiLCJiaW5kIiwiYXBwbHkiLCJ1c2VDb2xvcnMiLCJjb2xvciIsImluaXQiLCJuYW1lc3BhY2VzIiwic2F2ZSIsInNwbGl0IiwibGVuIiwicHVzaCIsIlJlZ0V4cCIsInN1YnN0ciIsIm5hbWUiLCJ0ZXN0IiwiRXJyb3IiLCJzdGFjayIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/node_modules/debug/src/debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/debug.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */ \nexports = module.exports = createDebug.debug = createDebug[\"default\"] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/websocket/node_modules/ms/index.js\");\n/**\n * The currently active debug mode names, and names to skip.\n */ exports.names = [];\nexports.skips = [];\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */ exports.formatters = {};\n/**\n * Previous log timestamp.\n */ var prevTime;\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */ function selectColor(namespace) {\n    var hash = 0, i;\n    for(i in namespace){\n        hash = (hash << 5) - hash + namespace.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */ function createDebug(namespace) {\n    function debug() {\n        // disabled?\n        if (!debug.enabled) return;\n        var self = debug;\n        // set `diff` timestamp\n        var curr = +new Date();\n        var ms = curr - (prevTime || curr);\n        self.diff = ms;\n        self.prev = prevTime;\n        self.curr = curr;\n        prevTime = curr;\n        // turn the `arguments` into a proper Array\n        var args = new Array(arguments.length);\n        for(var i = 0; i < args.length; i++){\n            args[i] = arguments[i];\n        }\n        args[0] = exports.coerce(args[0]);\n        if (\"string\" !== typeof args[0]) {\n            // anything else let's inspect with %O\n            args.unshift(\"%O\");\n        }\n        // apply any `formatters` transformations\n        var index = 0;\n        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n            // if we encounter an escaped % then don't increase the array index\n            if (match === \"%%\") return match;\n            index++;\n            var formatter = exports.formatters[format];\n            if (\"function\" === typeof formatter) {\n                var val = args[index];\n                match = formatter.call(self, val);\n                // now we need to remove `args[index]` since it's inlined in the `format`\n                args.splice(index, 1);\n                index--;\n            }\n            return match;\n        });\n        // apply env-specific formatting (colors, etc.)\n        exports.formatArgs.call(self, args);\n        var logFn = debug.log || exports.log || console.log.bind(console);\n        logFn.apply(self, args);\n    }\n    debug.namespace = namespace;\n    debug.enabled = exports.enabled(namespace);\n    debug.useColors = exports.useColors();\n    debug.color = selectColor(namespace);\n    // env-specific initialization logic for debug instances\n    if (\"function\" === typeof exports.init) {\n        exports.init(debug);\n    }\n    return debug;\n}\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */ function enable(namespaces) {\n    exports.save(namespaces);\n    exports.names = [];\n    exports.skips = [];\n    var split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n    var len = split.length;\n    for(var i = 0; i < len; i++){\n        if (!split[i]) continue; // ignore empty strings\n        namespaces = split[i].replace(/\\*/g, \".*?\");\n        if (namespaces[0] === \"-\") {\n            exports.skips.push(new RegExp(\"^\" + namespaces.substr(1) + \"$\"));\n        } else {\n            exports.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n        }\n    }\n}\n/**\n * Disable debug output.\n *\n * @api public\n */ function disable() {\n    exports.enable(\"\");\n}\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */ function enabled(name) {\n    var i, len;\n    for(i = 0, len = exports.skips.length; i < len; i++){\n        if (exports.skips[i].test(name)) {\n            return false;\n        }\n    }\n    for(i = 0, len = exports.names.length; i < len; i++){\n        if (exports.names[i].test(name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */ function coerce(val) {\n    if (val instanceof Error) return val.stack || val.message;\n    return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJtYXBwaW5ncyI6IkFBQ0E7Ozs7O0NBS0M7QUFFREEsVUFBVUMsT0FBT0QsT0FBTyxHQUFHRSxZQUFZQyxLQUFLLEdBQUdELFdBQVcsQ0FBQyxVQUFVLEdBQUdBO0FBQ3hFRixjQUFjLEdBQUdJO0FBQ2pCSixlQUFlLEdBQUdLO0FBQ2xCTCxjQUFjLEdBQUdNO0FBQ2pCTixlQUFlLEdBQUdPO0FBQ2xCUCwyR0FBMkI7QUFFM0I7O0NBRUMsR0FFREEsYUFBYSxHQUFHLEVBQUU7QUFDbEJBLGFBQWEsR0FBRyxFQUFFO0FBRWxCOzs7O0NBSUMsR0FFREEsa0JBQWtCLEdBQUcsQ0FBQztBQUV0Qjs7Q0FFQyxHQUVELElBQUlhO0FBRUo7Ozs7O0NBS0MsR0FFRCxTQUFTQyxZQUFZQyxTQUFTO0lBQzVCLElBQUlDLE9BQU8sR0FBR0M7SUFFZCxJQUFLQSxLQUFLRixVQUFXO1FBQ25CQyxPQUFRLENBQUVBLFFBQVEsS0FBS0EsT0FBUUQsVUFBVUcsVUFBVSxDQUFDRDtRQUNwREQsUUFBUSxHQUFHLDJCQUEyQjtJQUN4QztJQUVBLE9BQU9oQixRQUFRbUIsTUFBTSxDQUFDQyxLQUFLQyxHQUFHLENBQUNMLFFBQVFoQixRQUFRbUIsTUFBTSxDQUFDRyxNQUFNLENBQUM7QUFDL0Q7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTcEIsWUFBWWEsU0FBUztJQUU1QixTQUFTWjtRQUNQLFlBQVk7UUFDWixJQUFJLENBQUNBLE1BQU1JLE9BQU8sRUFBRTtRQUVwQixJQUFJZ0IsT0FBT3BCO1FBRVgsdUJBQXVCO1FBQ3ZCLElBQUlxQixPQUFPLENBQUMsSUFBSUM7UUFDaEIsSUFBSUMsS0FBS0YsT0FBUVgsQ0FBQUEsWUFBWVcsSUFBRztRQUNoQ0QsS0FBS0ksSUFBSSxHQUFHRDtRQUNaSCxLQUFLSyxJQUFJLEdBQUdmO1FBQ1pVLEtBQUtDLElBQUksR0FBR0E7UUFDWlgs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S0FBSyxDQUFDVyxNQUFNLEVBQUVMLElBQUlvQyxLQUFLcEMsSUFBSztRQUNwRCxJQUFJakIsUUFBUVcsS0FBSyxDQUFDTSxFQUFFLENBQUN5QyxJQUFJLENBQUNELE9BQU87WUFDL0IsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFLeEMsSUFBSSxHQUFHb0MsTUFBTXJELFFBQVFVLEtBQUssQ0FBQ1ksTUFBTSxFQUFFTCxJQUFJb0MsS0FBS3BDLElBQUs7UUFDcEQsSUFBSWpCLFFBQVFVLEtBQUssQ0FBQ08sRUFBRSxDQUFDeUMsSUFBSSxDQUFDRCxPQUFPO1lBQy9CLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU3JELE9BQU9rQyxHQUFHO0lBQ2pCLElBQUlBLGVBQWVxQixPQUFPLE9BQU9yQixJQUFJc0IsS0FBSyxJQUFJdEIsSUFBSXVCLE9BQU87SUFDekQsT0FBT3ZCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanM/ZDIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJtb2R1bGUiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJodW1hbml6ZSIsInJlcXVpcmUiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwibGVuZ3RoIiwic2VsZiIsImN1cnIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsInVuc2hpZnQiLCJpbmRleCIsInJlcGxhY2UiLCJtYXRjaCIsImZvcm1hdCIsImZvcm1hdHRlciIsInZhbCIsImNhbGwiLCJzcGxpY2UiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJsb2ciLCJjb25zb2xlIiwiYmluZCIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJpbml0IiwibmFtZXNwYWNlcyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzdWJzdHIiLCJuYW1lIiwidGVzdCIsIkVycm9yIiwic3RhY2siLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process !== \"undefined\" && process.type === \"renderer\") {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7QUFFRCxJQUFJLE9BQU9BLFlBQVksZUFBZUEsUUFBUUMsSUFBSSxLQUFLLFlBQVk7SUFDakVDLHVJQUF5QjtBQUMzQixPQUFPO0lBQ0xBLGlJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz9hNmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwidHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process !== \"undefined\" && process.type === \"renderer\") {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxZQUFZO0lBQ2pFQyw0SEFBeUI7QUFDM0IsT0FBTztJQUNMQSxzSEFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanM/YTZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInR5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Module dependencies.\n */ \nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ exports = module.exports = __webpack_require__(/*! ./debug */ \"(action-browser)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter(function(key) {\n    return /^debug_/i.test(key);\n}).reduce(function(obj, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {\n        return k.toUpperCase();\n    });\n    // coerce string value into JS value\n    var val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n    else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n    else if (val === \"null\") val = null;\n    else val = Number(val);\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */ var fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nif (1 !== fd && 2 !== fd) {\n    util.deprecate(function() {}, \"except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)\")();\n}\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ exports.formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map(function(str) {\n        return str.trim();\n    }).join(\" \");\n};\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */ exports.formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var name = this.namespace;\n    var useColors = this.useColors;\n    if (useColors) {\n        var c = this.color;\n        var prefix = \"  \\x1b[3\" + c + \";1m\" + name + \" \" + \"\\x1b[0m\";\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(\"\\x1b[3\" + c + \"m+\" + exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = new Date().toUTCString() + \" \" + name + \" \" + args[0];\n    }\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */ function log() {\n    return stream.write(util.format.apply(util, arguments) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (null == namespaces) {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    } else {\n        process.env.DEBUG = namespaces;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */ function createWritableStdioStream(fd) {\n    var stream;\n    var tty_wrap = process.binding(\"tty_wrap\");\n    // Note stream._type is used for test-module-load-list.js\n    switch(tty_wrap.guessHandleType(fd)){\n        case \"TTY\":\n            stream = new tty.WriteStream(fd);\n            stream._type = \"tty\";\n            // Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        case \"FILE\":\n            var fs = __webpack_require__(/*! fs */ \"fs\");\n            stream = new fs.SyncWriteStream(fd, {\n                autoClose: false\n            });\n            stream._type = \"fs\";\n            break;\n        case \"PIPE\":\n        case \"TCP\":\n            var net = __webpack_require__(/*! net */ \"net\");\n            stream = new net.Socket({\n                fd: fd,\n                readable: false,\n                writable: true\n            });\n            // FIXME Should probably have an option in net.Socket to create a\n            // stream from an existing fd which is writable only. But for now\n            // we'll just add this hack and set the `readable` member to false.\n            // Test: ./node test/fixtures/echo.js < /etc/passwd\n            stream.readable = false;\n            stream.read = null;\n            stream._type = \"pipe\";\n            // FIXME Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        default:\n            // Probably an error on in uv_guess_handle()\n            throw new Error(\"Implement me. Unknown stream file type!\");\n    }\n    // For supporting legacy API we put the FD here.\n    stream.fd = fd;\n    stream._isStdio = true;\n    return stream;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    var keys = Object.keys(exports.inspectOpts);\n    for(var i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */ exports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDO0FBRUQsSUFBSUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDbEIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFbkI7Ozs7Q0FJQyxHQUVERSxVQUFVQyxnSUFBeUI7QUFDbkNELFlBQVksR0FBR0U7QUFDZkYsV0FBVyxHQUFHRztBQUNkSCxrQkFBa0IsR0FBR0k7QUFDckJKLFlBQVksR0FBR0s7QUFDZkwsWUFBWSxHQUFHTTtBQUNmTixpQkFBaUIsR0FBR087QUFFcEI7O0NBRUMsR0FFRFAsY0FBYyxHQUFHO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUU7QUFFbkM7Ozs7Q0FJQyxHQUVEQSxtQkFBbUIsR0FBR1UsT0FBT0MsSUFBSSxDQUFDQyxRQUFRQyxHQUFHLEVBQUVDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sV0FBV0MsSUFBSSxDQUFDRDtBQUN6QixHQUFHRSxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFSCxHQUFHO0lBQzFCLGFBQWE7SUFDYixJQUFJSSxPQUFPSixJQUNSSyxTQUFTLENBQUMsR0FDVkMsV0FBVyxHQUNYQyxPQUFPLENBQUMsYUFBYSxTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFBSSxPQUFPQSxFQUFFQyxXQUFXO0lBQUc7SUFFakUsb0NBQW9DO0lBQ3BDLElBQUlDLE1BQU1kLFFBQVFDLEdBQUcsQ0FBQ0UsSUFBSTtJQUMxQixJQUFJLDJCQUEyQkMsSUFBSSxDQUFDVSxNQUFNQSxNQUFNO1NBQzNDLElBQUksNkJBQTZCVixJQUFJLENBQUNVLE1BQU1BLE1BQU07U0FDbEQsSUFBSUEsUUFBUSxRQUFRQSxNQUFNO1NBQzFCQSxNQUFNQyxPQUFPRDtJQUVsQlIsR0FBRyxDQUFDQyxLQUFLLEdBQUdPO0lBQ1osT0FBT1I7QUFDVCxHQUFHLENB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RCxJQUFLO1FBQ3BDRCxNQUFNekUsV0FBVyxDQUFDRSxJQUFJLENBQUN3RSxFQUFFLENBQUMsR0FBR25GLFFBQVFTLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDd0UsRUFBRSxDQUFDO0lBQzNEO0FBQ0Y7QUFFQTs7Q0FFQyxHQUVEbkYsUUFBUXFGLE1BQU0sQ0FBQy9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/OTliNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIC8vIGNhbWVsLWNhc2VcbiAgdmFyIHByb3AgPSBrZXlcbiAgICAuc3Vic3RyaW5nKDYpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGspIHsgcmV0dXJuIGsudG9VcHBlckNhc2UoKSB9KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcbiAgdmFyIHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IHRydWU7XG4gIGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSBmYWxzZTtcbiAgZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHZhbCA9IG51bGw7XG4gIGVsc2UgdmFsID0gTnVtYmVyKHZhbCk7XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFRoZSBmaWxlIGRlc2NyaXB0b3IgdG8gd3JpdGUgdGhlIGBkZWJ1ZygpYCBjYWxscyB0by5cbiAqIFNldCB0aGUgYERFQlVHX0ZEYCBlbnYgdmFyaWFibGUgdG8gb3ZlcnJpZGUgd2l0aCBhbm90aGVyIHZhbHVlLiBpLmUuOlxuICpcbiAqICAgJCBERUJVR19GRD0zIG5vZGUgc2NyaXB0LmpzIDM+ZGVidWcubG9nXG4gKi9cblxudmFyIGZkID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuREVCVUdfRkQsIDEwKSB8fCAyO1xuXG5pZiAoMSAhPT0gZmQgJiYgMiAhPT0gZmQpIHtcbiAgdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24oKXt9LCAnZXhjZXB0IGZvciBzdGRlcnIoMikgYW5kIHN0ZG91dCgxKSwgYW55IG90aGVyIHVzYWdlIG9mIERFQlVHX0ZEIGlzIGRlcHJlY2F0ZWQuIE92ZXJyaWRlIGRlYnVnLmxvZyBpZiB5b3Ugd2FudCB0byB1c2UgYSBkaWZmZXJlbnQgbG9nIGZ1bmN0aW9uIChodHRwczovL2dpdC5pby9kZWJ1Z19mZCknKSgpXG59XG5cbnZhciBzdHJlYW0gPSAxID09PSBmZCA/IHByb2Nlc3Muc3Rkb3V0IDpcbiAgICAgICAgICAgICAyID09PSBmZCA/IHByb2Nlc3Muc3RkZXJyIDpcbiAgICAgICAgICAgICBjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtKGZkKTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0c1xuICAgID8gQm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycylcbiAgICA6IHR0eS5pc2F0dHkoZmQpO1xufVxuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuICAgIC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKClcbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgaWYgKHVzZUNvbG9ycykge1xuICAgIHZhciBjID0gdGhpcy5jb2xvcjtcbiAgICB2YXIgcHJlZml4ID0gJyAgXFx1MDAxYlszJyArIGMgKyAnOzFtJyArIG5hbWUgKyAnICcgKyAnXFx1MDAxYlswbSc7XG5cbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKCdcXHUwMDFiWzMnICsgYyArICdtKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxYlswbScpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbMF0gPSBuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKClcbiAgICAgICsgJyAnICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gYHN0cmVhbWAuXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIENvcGllZCBmcm9tIGBub2RlL3NyYy9ub2RlLmpzYC5cbiAqXG4gKiBYWFg6IEl0J3MgbGFtZSB0aGF0IG5vZGUgZG9lc24ndCBleHBvc2UgdGhpcyBBUEkgb3V0LW9mLXRoZS1ib3guIEl0IGFsc29cbiAqIHJlbGllcyBvbiB0aGUgdW5kb2N1bWVudGVkIGB0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoKWAgd2hpY2ggaXMgYWxzbyBsYW1lLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0gKGZkKSB7XG4gIHZhciBzdHJlYW07XG4gIHZhciB0dHlfd3JhcCA9IHByb2Nlc3MuYmluZGluZygndHR5X3dyYXAnKTtcblxuICAvLyBOb3RlIHN0cmVhbS5fdHlwZSBpcyB1c2VkIGZvciB0ZXN0LW1vZHVsZS1sb2FkLWxpc3QuanNcblxuICBzd2l0Y2ggKHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZShmZCkpIHtcbiAgICBjYXNlICdUVFknOlxuICAgICAgc3RyZWFtID0gbmV3IHR0eS5Xcml0ZVN0cmVhbShmZCk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAndHR5JztcblxuICAgICAgLy8gSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdGSUxFJzpcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICBzdHJlYW0gPSBuZXcgZnMuU3luY1dyaXRlU3RyZWFtKGZkLCB7IGF1dG9DbG9zZTogZmFsc2UgfSk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAnZnMnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQSVBFJzpcbiAgICBjYXNlICdUQ1AnOlxuICAgICAgdmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuICAgICAgc3RyZWFtID0gbmV3IG5ldC5Tb2NrZXQoe1xuICAgICAgICBmZDogZmQsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGSVhNRSBTaG91bGQgcHJvYmFibHkgaGF2ZSBhbiBvcHRpb24gaW4gbmV0LlNvY2tldCB0byBjcmVhdGUgYVxuICAgICAgLy8gc3RyZWFtIGZyb20gYW4gZXhpc3RpbmcgZmQgd2hpY2ggaXMgd3JpdGFibGUgb25seS4gQnV0IGZvciBub3dcbiAgICAgIC8vIHdlJ2xsIGp1c3QgYWRkIHRoaXMgaGFjayBhbmQgc2V0IHRoZSBgcmVhZGFibGVgIG1lbWJlciB0byBmYWxzZS5cbiAgICAgIC8vIFRlc3Q6IC4vbm9kZSB0ZXN0L2ZpeHR1cmVzL2VjaG8uanMgPCAvZXRjL3Bhc3N3ZFxuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVhZCA9IG51bGw7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAncGlwZSc7XG5cbiAgICAgIC8vIEZJWE1FIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFByb2JhYmx5IGFuIGVycm9yIG9uIGluIHV2X2d1ZXNzX2hhbmRsZSgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcGxlbWVudCBtZS4gVW5rbm93biBzdHJlYW0gZmlsZSB0eXBlIScpO1xuICB9XG5cbiAgLy8gRm9yIHN1cHBvcnRpbmcgbGVnYWN5IEFQSSB3ZSBwdXQgdGhlIEZEIGhlcmUuXG4gIHN0cmVhbS5mZCA9IGZkO1xuXG4gIHN0cmVhbS5faXNTdGRpbyA9IHRydWU7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0IChkZWJ1Zykge1xuICBkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgcHJvY2Vzcy5lbnYuREVCVUdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuIl0sIm5hbWVzIjpbInR0eSIsInJlcXVpcmUiLCJ1dGlsIiwiZXhwb3J0cyIsIm1vZHVsZSIsImluaXQiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJjb2xvcnMiLCJpbnNwZWN0T3B0cyIsIk9iamVjdCIsImtleXMiLCJwcm9jZXNzIiwiZW52IiwiZmlsdGVyIiwia2V5IiwidGVzdCIsInJlZHVjZSIsIm9iaiIsInByb3AiLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJfIiwiayIsInRvVXBwZXJDYXNlIiwidmFsIiwiTnVtYmVyIiwiZmQiLCJwYXJzZUludCIsIkRFQlVHX0ZEIiwiZGVwcmVjYXRlIiwic3RyZWFtIiwic3Rkb3V0Iiwic3RkZXJyIiwiY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbSIsIkJvb2xlYW4iLCJpc2F0dHkiLCJmb3JtYXR0ZXJzIiwibyIsInYiLCJpbnNwZWN0Iiwic3BsaXQiLCJtYXAiLCJzdHIiLCJ0cmltIiwiam9pbiIsIk8iLCJhcmdzIiwibmFtZSIsIm5hbWVzcGFjZSIsImMiLCJjb2xvciIsInByZWZpeCIsInB1c2giLCJodW1hbml6ZSIsImRpZmYiLCJEYXRlIiwidG9VVENTdHJpbmciLCJ3cml0ZSIsImZvcm1hdCIsImFwcGx5IiwiYXJndW1lbnRzIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwidHR5X3dyYXAiLCJiaW5kaW5nIiwiZ3Vlc3NIYW5kbGVUeXBlIiwiV3JpdGVTdHJlYW0iLCJfdHlwZSIsIl9oYW5kbGUiLCJ1bnJlZiIsImZzIiwiU3luY1dyaXRlU3RyZWFtIiwiYXV0b0Nsb3NlIiwibmV0IiwiU29ja2V0IiwicmVhZGFibGUiLCJ3cml0YWJsZSIsInJlYWQiLCJFcnJvciIsIl9pc1N0ZGlvIiwiZGVidWciLCJpIiwibGVuZ3RoIiwiZW5hYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Module dependencies.\n */ \nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ exports = module.exports = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter(function(key) {\n    return /^debug_/i.test(key);\n}).reduce(function(obj, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {\n        return k.toUpperCase();\n    });\n    // coerce string value into JS value\n    var val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n    else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n    else if (val === \"null\") val = null;\n    else val = Number(val);\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */ var fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nif (1 !== fd && 2 !== fd) {\n    util.deprecate(function() {}, \"except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)\")();\n}\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ exports.formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map(function(str) {\n        return str.trim();\n    }).join(\" \");\n};\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */ exports.formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var name = this.namespace;\n    var useColors = this.useColors;\n    if (useColors) {\n        var c = this.color;\n        var prefix = \"  \\x1b[3\" + c + \";1m\" + name + \" \" + \"\\x1b[0m\";\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(\"\\x1b[3\" + c + \"m+\" + exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = new Date().toUTCString() + \" \" + name + \" \" + args[0];\n    }\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */ function log() {\n    return stream.write(util.format.apply(util, arguments) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (null == namespaces) {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    } else {\n        process.env.DEBUG = namespaces;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */ function createWritableStdioStream(fd) {\n    var stream;\n    var tty_wrap = process.binding(\"tty_wrap\");\n    // Note stream._type is used for test-module-load-list.js\n    switch(tty_wrap.guessHandleType(fd)){\n        case \"TTY\":\n            stream = new tty.WriteStream(fd);\n            stream._type = \"tty\";\n            // Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        case \"FILE\":\n            var fs = __webpack_require__(/*! fs */ \"fs\");\n            stream = new fs.SyncWriteStream(fd, {\n                autoClose: false\n            });\n            stream._type = \"fs\";\n            break;\n        case \"PIPE\":\n        case \"TCP\":\n            var net = __webpack_require__(/*! net */ \"net\");\n            stream = new net.Socket({\n                fd: fd,\n                readable: false,\n                writable: true\n            });\n            // FIXME Should probably have an option in net.Socket to create a\n            // stream from an existing fd which is writable only. But for now\n            // we'll just add this hack and set the `readable` member to false.\n            // Test: ./node test/fixtures/echo.js < /etc/passwd\n            stream.readable = false;\n            stream.read = null;\n            stream._type = \"pipe\";\n            // FIXME Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        default:\n            // Probably an error on in uv_guess_handle()\n            throw new Error(\"Implement me. Unknown stream file type!\");\n    }\n    // For supporting legacy API we put the FD here.\n    stream.fd = fd;\n    stream._isStdio = true;\n    return stream;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    var keys = Object.keys(exports.inspectOpts);\n    for(var i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */ exports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELElBQUlBLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBRW5COzs7O0NBSUMsR0FFREUsVUFBVUMscUhBQXlCO0FBQ25DRCxZQUFZLEdBQUdFO0FBQ2ZGLFdBQVcsR0FBR0c7QUFDZEgsa0JBQWtCLEdBQUdJO0FBQ3JCSixZQUFZLEdBQUdLO0FBQ2ZMLFlBQVksR0FBR007QUFDZk4saUJBQWlCLEdBQUdPO0FBRXBCOztDQUVDLEdBRURQLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DOzs7O0NBSUMsR0FFREEsbUJBQW1CLEdBQUdVLE9BQU9DLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxFQUFFQyxNQUFNLENBQUMsU0FBVUMsR0FBRztJQUNqRSxPQUFPLFdBQVdDLElBQUksQ0FBQ0Q7QUFDekIsR0FBR0UsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUgsR0FBRztJQUMxQixhQUFhO0lBQ2IsSUFBSUksT0FBT0osSUFDUkssU0FBUyxDQUFDLEdBQ1ZDLFdBQVcsR0FDWEMsT0FBTyxDQUFDLGFBQWEsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQUksT0FBT0EsRUFBRUMsV0FBVztJQUFHO0lBRWpFLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNZCxRQUFRQyxHQUFHLENBQUNFLElBQUk7SUFDMUIsSUFBSSwyQkFBMkJDLElBQUksQ0FBQ1UsTUFBTUEsTUFBTTtTQUMzQyxJQUFJLDZCQUE2QlYsSUFBSSxDQUFDVSxNQUFNQSxNQUFNO1NBQ2xELElBQUlBLFFBQVEsUUFBUUEsTUFBTTtTQUMxQkEsTUFBTUMsT0FBT0Q7SUFFbEJSLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHTztJQUNaLE9BQU9SO0FBQ1QsR0FBRyxDQUFDO0FBRUo7Ozs7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Q0QsTUFBTXpFLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDd0UsRUFBRSxDQUFDLEdBQUduRixRQUFRUyxXQUFXLENBQUNFLElBQUksQ0FBQ3dFLEVBQUUsQ0FBQztJQUMzRDtBQUNGO0FBRUE7O0NBRUMsR0FFRG5GLFFBQVFxRixNQUFNLENBQUMvRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzk5YjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBjYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5XG4gICAgLnN1YnN0cmluZyg2KVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7IHJldHVybiBrLnRvVXBwZXJDYXNlKCkgfSk7XG5cbiAgLy8gY29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSB0cnVlO1xuICBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gZmFsc2U7XG4gIGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB2YWwgPSBudWxsO1xuICBlbHNlIHZhbCA9IE51bWJlcih2YWwpO1xuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBUaGUgZmlsZSBkZXNjcmlwdG9yIHRvIHdyaXRlIHRoZSBgZGVidWcoKWAgY2FsbHMgdG8uXG4gKiBTZXQgdGhlIGBERUJVR19GRGAgZW52IHZhcmlhYmxlIHRvIG92ZXJyaWRlIHdpdGggYW5vdGhlciB2YWx1ZS4gaS5lLjpcbiAqXG4gKiAgICQgREVCVUdfRkQ9MyBub2RlIHNjcmlwdC5qcyAzPmRlYnVnLmxvZ1xuICovXG5cbnZhciBmZCA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkRFQlVHX0ZELCAxMCkgfHwgMjtcblxuaWYgKDEgIT09IGZkICYmIDIgIT09IGZkKSB7XG4gIHV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uKCl7fSwgJ2V4Y2VwdCBmb3Igc3RkZXJyKDIpIGFuZCBzdGRvdXQoMSksIGFueSBvdGhlciB1c2FnZSBvZiBERUJVR19GRCBpcyBkZXByZWNhdGVkLiBPdmVycmlkZSBkZWJ1Zy5sb2cgaWYgeW91IHdhbnQgdG8gdXNlIGEgZGlmZmVyZW50IGxvZyBmdW5jdGlvbiAoaHR0cHM6Ly9naXQuaW8vZGVidWdfZmQpJykoKVxufVxuXG52YXIgc3RyZWFtID0gMSA9PT0gZmQgPyBwcm9jZXNzLnN0ZG91dCA6XG4gICAgICAgICAgICAgMiA9PT0gZmQgPyBwcm9jZXNzLnN0ZGVyciA6XG4gICAgICAgICAgICAgY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbShmZCk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgcmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHNcbiAgICA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpXG4gICAgOiB0dHkuaXNhdHR5KGZkKTtcbn1cblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcbiAgICAuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpXG4gICAgfSkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWVzcGFjZTtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGlmICh1c2VDb2xvcnMpIHtcbiAgICB2YXIgYyA9IHRoaXMuY29sb3I7XG4gICAgdmFyIHByZWZpeCA9ICcgIFxcdTAwMWJbMycgKyBjICsgJzsxbScgKyBuYW1lICsgJyAnICsgJ1xcdTAwMWJbMG0nO1xuXG4gICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuICAgIGFyZ3MucHVzaCgnXFx1MDAxYlszJyArIGMgKyAnbSsnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMWJbMG0nKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gbmV3IERhdGUoKS50b1VUQ1N0cmluZygpXG4gICAgICArICcgJyArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIGBzdHJlYW1gLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBgbm9kZS9zcmMvbm9kZS5qc2AuXG4gKlxuICogWFhYOiBJdCdzIGxhbWUgdGhhdCBub2RlIGRvZXNuJ3QgZXhwb3NlIHRoaXMgQVBJIG91dC1vZi10aGUtYm94LiBJdCBhbHNvXG4gKiByZWxpZXMgb24gdGhlIHVuZG9jdW1lbnRlZCBgdHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKClgIHdoaWNoIGlzIGFsc28gbGFtZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtIChmZCkge1xuICB2YXIgc3RyZWFtO1xuICB2YXIgdHR5X3dyYXAgPSBwcm9jZXNzLmJpbmRpbmcoJ3R0eV93cmFwJyk7XG5cbiAgLy8gTm90ZSBzdHJlYW0uX3R5cGUgaXMgdXNlZCBmb3IgdGVzdC1tb2R1bGUtbG9hZC1saXN0LmpzXG5cbiAgc3dpdGNoICh0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoZmQpKSB7XG4gICAgY2FzZSAnVFRZJzpcbiAgICAgIHN0cmVhbSA9IG5ldyB0dHkuV3JpdGVTdHJlYW0oZmQpO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3R0eSc7XG5cbiAgICAgIC8vIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRklMRSc6XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgc3RyZWFtID0gbmV3IGZzLlN5bmNXcml0ZVN0cmVhbShmZCwgeyBhdXRvQ2xvc2U6IGZhbHNlIH0pO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ2ZzJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUElQRSc6XG4gICAgY2FzZSAnVENQJzpcbiAgICAgIHZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBuZXQuU29ja2V0KHtcbiAgICAgICAgZmQ6IGZkLFxuICAgICAgICByZWFkYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gRklYTUUgU2hvdWxkIHByb2JhYmx5IGhhdmUgYW4gb3B0aW9uIGluIG5ldC5Tb2NrZXQgdG8gY3JlYXRlIGFcbiAgICAgIC8vIHN0cmVhbSBmcm9tIGFuIGV4aXN0aW5nIGZkIHdoaWNoIGlzIHdyaXRhYmxlIG9ubHkuIEJ1dCBmb3Igbm93XG4gICAgICAvLyB3ZSdsbCBqdXN0IGFkZCB0aGlzIGhhY2sgYW5kIHNldCB0aGUgYHJlYWRhYmxlYCBtZW1iZXIgdG8gZmFsc2UuXG4gICAgICAvLyBUZXN0OiAuL25vZGUgdGVzdC9maXh0dXJlcy9lY2hvLmpzIDwgL2V0Yy9wYXNzd2RcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlYWQgPSBudWxsO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3BpcGUnO1xuXG4gICAgICAvLyBGSVhNRSBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBQcm9iYWJseSBhbiBlcnJvciBvbiBpbiB1dl9ndWVzc19oYW5kbGUoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBsZW1lbnQgbWUuIFVua25vd24gc3RyZWFtIGZpbGUgdHlwZSEnKTtcbiAgfVxuXG4gIC8vIEZvciBzdXBwb3J0aW5nIGxlZ2FjeSBBUEkgd2UgcHV0IHRoZSBGRCBoZXJlLlxuICBzdHJlYW0uZmQgPSBmZDtcblxuICBzdHJlYW0uX2lzU3RkaW8gPSB0cnVlO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdCAoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYHByb2Nlc3MuZW52LkRFQlVHYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcbiJdLCJuYW1lcyI6WyJ0dHkiLCJyZXF1aXJlIiwidXRpbCIsImV4cG9ydHMiLCJtb2R1bGUiLCJpbml0IiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwiY29sb3JzIiwiaW5zcGVjdE9wdHMiLCJPYmplY3QiLCJrZXlzIiwicHJvY2VzcyIsImVudiIsImZpbHRlciIsImtleSIsInRlc3QiLCJyZWR1Y2UiLCJvYmoiLCJwcm9wIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiXyIsImsiLCJ0b1VwcGVyQ2FzZSIsInZhbCIsIk51bWJlciIsImZkIiwicGFyc2VJbnQiLCJERUJVR19GRCIsImRlcHJlY2F0ZSIsInN0cmVhbSIsInN0ZG91dCIsInN0ZGVyciIsImNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0iLCJCb29sZWFuIiwiaXNhdHR5IiwiZm9ybWF0dGVycyIsIm8iLCJ2IiwiaW5zcGVjdCIsInNwbGl0IiwibWFwIiwic3RyIiwidHJpbSIsImpvaW4iLCJPIiwiYXJncyIsIm5hbWUiLCJuYW1lc3BhY2UiLCJjIiwiY29sb3IiLCJwcmVmaXgiLCJwdXNoIiwiaHVtYW5pemUiLCJkaWZmIiwiRGF0ZSIsInRvVVRDU3RyaW5nIiwid3JpdGUiLCJmb3JtYXQiLCJhcHBseSIsImFyZ3VtZW50cyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsInR0eV93cmFwIiwiYmluZGluZyIsImd1ZXNzSGFuZGxlVHlwZSIsIldyaXRlU3RyZWFtIiwiX3R5cGUiLCJfaGFuZGxlIiwidW5yZWYiLCJmcyIsIlN5bmNXcml0ZVN0cmVhbSIsImF1dG9DbG9zZSIsIm5ldCIsIlNvY2tldCIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJyZWFkIiwiRXJyb3IiLCJfaXNTdGRpbyIsImRlYnVnIiwiaSIsImxlbmd0aCIsImVuYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Helpers.\n */ \nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ module.exports = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isNaN(val) === false) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    if (ms >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (ms >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (ms >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (ms >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    return plural(ms, d, \"day\") || plural(ms, h, \"hour\") || plural(ms, m, \"minute\") || plural(ms, s, \"second\") || ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, n, name) {\n    if (ms < n) {\n        return;\n    }\n    if (ms < n * 1.5) {\n        return Math.floor(ms / n) + \" \" + name;\n    }\n    return Math.ceil(ms / n) + \" \" + name + \"s\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDO0FBRUQsSUFBSUEsSUFBSTtBQUNSLElBQUlDLElBQUlELElBQUk7QUFDWixJQUFJRSxJQUFJRCxJQUFJO0FBQ1osSUFBSUUsSUFBSUQsSUFBSTtBQUNaLElBQUlFLElBQUlELElBQUk7QUFFWjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFREUsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLEdBQUcsRUFBRUMsT0FBTztJQUNwQ0EsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUlDLE9BQU8sT0FBT0Y7SUFDbEIsSUFBSUUsU0FBUyxZQUFZRixJQUFJRyxNQUFNLEdBQUcsR0FBRztRQUN2QyxPQUFPQyxNQUFNSjtJQUNmLE9BQU8sSUFBSUUsU0FBUyxZQUFZRyxNQUFNTCxTQUFTLE9BQU87UUFDcEQsT0FBT0MsUUFBUUssSUFBSSxHQUFHQyxRQUFRUCxPQUFPUSxTQUFTUjtJQUNoRDtJQUNBLE1BQU0sSUFBSVMsTUFDUiwwREFDRUMsS0FBS0MsU0FBUyxDQUFDWDtBQUVyQjtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNJLE1BQU1RLEdBQUc7SUFDaEJBLE1BQU1DLE9BQU9EO0lBQ2IsSUFBSUEsSUFBSVQsTUFBTSxHQUFHLEtBQUs7UUFDcEI7SUFDRjtJQUNBLElBQUlXLFFBQVEsd0hBQXdIQyxJQUFJLENBQ3RJSDtJQUVGLElBQUksQ0FBQ0UsT0FBTztRQUNWO0lBQ0Y7SUFDQSxJQUFJRSxJQUFJQyxXQUFXSCxLQUFLLENBQUMsRUFBRTtJQUMzQixJQUFJWixPQUFPLENBQUNZLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBRyxFQUFHSSxXQUFXO0lBQ3pDLE9BQVFoQjtRQUNOLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT2MsSUFBSW5CO1FBQ2IsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT21CLElBQUlwQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT29CLElBQUlyQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3FCLElBQUl0QjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3NCLElBQUl2QjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3VCO1FBQ1Q7WUFDRSxPQUFPRztJQUNYO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTWCxTQUFTWSxFQUFFO0lBQ2xCLElBQUlBLE1BQU14QixHQUFHO1FBQ1gsT0FBT3lCLEtBQUtDLEtBQUssQ0FBQ0YsS0FBS3hCLEtBQUs7SUFDOUI7SUFDQSxJQUFJd0IsTUFBTXpCLEdBQUc7UUFDWCxPQUFPMEIsS0FBS0MsS0FBSyxDQUFDRixLQUFLekIsS0FBSztJQUM5QjtJQUNBLElBQUl5QixNQUFNMUIsR0FBRztRQUNYLE9BQU8yQixLQUFLQyxLQUFLLENBQUNGLEtBQUsxQixLQUFLO0lBQzlCO0lBQ0EsSUFBSTBCLE1BQU0zQixHQUFHO1FBQ1gsT0FBTzRCLEtBQUtDLEtBQUssQ0FBQ0YsS0FBSzNCLEtBQUs7SUFDOUI7SUFDQSxPQUFPMkIsS0FBSztBQUNkO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU2IsUUFBUWEsRUFBRTtJQUNqQixPQUFPRyxPQUFPSCxJQUFJeEIsR0FBRyxVQUNuQjJCLE9BQU9ILElBQUl6QixHQUFHLFdBQ2Q0QixPQUFPSCxJQUFJMUIsR0FBRyxhQUNkNkIsT0FBT0gsSUFBSTNCLEdBQUcsYUFDZDJCLEtBQUs7QUFDVDtBQUVBOztDQUVDLEdBRUQsU0FBU0csT0FBT0gsRUFBRSxFQUFFSixDQUFDLEVBQUVRLElBQUk7SUFDekIsSUFBSUosS0FBS0osR0FBRztRQUNWO0lBQ0Y7SUFDQSxJQUFJSSxLQUFLSixJQUFJLEtBQUs7UUFDaEIsT0FBT0ssS0FBS0ksS0FBSyxDQUFDTCxLQUFLSixLQUFLLE1BQU1RO0lBQ3BDO0lBQ0EsT0FBT0gsS0FBS0ssSUFBSSxDQUFDTixLQUFLSixLQUFLLE1BQU1RLE9BQU87QUFDMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcz8zOGFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiJdLCJuYW1lcyI6WyJzIiwibSIsImgiLCJkIiwieSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2YWwiLCJvcHRpb25zIiwidHlwZSIsImxlbmd0aCIsInBhcnNlIiwiaXNOYU4iLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyIiwiU3RyaW5nIiwibWF0Y2giLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsIm1zIiwiTWF0aCIsInJvdW5kIiwicGx1cmFsIiwibmFtZSIsImZsb29yIiwiY2VpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/node_modules/ms/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Helpers.\n */ \nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ module.exports = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isNaN(val) === false) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    if (ms >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (ms >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (ms >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (ms >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    return plural(ms, d, \"day\") || plural(ms, h, \"hour\") || plural(ms, m, \"minute\") || plural(ms, s, \"second\") || ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, n, name) {\n    if (ms < n) {\n        return;\n    }\n    if (ms < n * 1.5) {\n        return Math.floor(ms / n) + \" \" + name;\n    }\n    return Math.ceil(ms / n) + \" \" + name + \"s\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELElBQUlBLElBQUk7QUFDUixJQUFJQyxJQUFJRCxJQUFJO0FBQ1osSUFBSUUsSUFBSUQsSUFBSTtBQUNaLElBQUlFLElBQUlELElBQUk7QUFDWixJQUFJRSxJQUFJRCxJQUFJO0FBRVo7Ozs7Ozs7Ozs7OztDQVlDLEdBRURFLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxHQUFHLEVBQUVDLE9BQU87SUFDcENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJQyxPQUFPLE9BQU9GO0lBQ2xCLElBQUlFLFNBQVMsWUFBWUYsSUFBSUcsTUFBTSxHQUFHLEdBQUc7UUFDdkMsT0FBT0MsTUFBTUo7SUFDZixPQUFPLElBQUlFLFNBQVMsWUFBWUcsTUFBTUwsU0FBUyxPQUFPO1FBQ3BELE9BQU9DLFFBQVFLLElBQUksR0FBR0MsUUFBUVAsT0FBT1EsU0FBU1I7SUFDaEQ7SUFDQSxNQUFNLElBQUlTLE1BQ1IsMERBQ0VDLEtBQUtDLFNBQVMsQ0FBQ1g7QUFFckI7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTSSxNQUFNUSxHQUFHO0lBQ2hCQSxNQUFNQyxPQUFPRDtJQUNiLElBQUlBLElBQUlULE1BQU0sR0FBRyxLQUFLO1FBQ3BCO0lBQ0Y7SUFDQSxJQUFJVyxRQUFRLHdIQUF3SEMsSUFBSSxDQUN0SUg7SUFFRixJQUFJLENBQUNFLE9BQU87UUFDVjtJQUNGO0lBQ0EsSUFBSUUsSUFBSUMsV0FBV0gsS0FBSyxDQUFDLEVBQUU7SUFDM0IsSUFBSVosT0FBTyxDQUFDWSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQUcsRUFBR0ksV0FBVztJQUN6QyxPQUFRaEI7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9jLElBQUluQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9tQixJQUFJcEI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9vQixJQUFJckI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9xQixJQUFJdEI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9zQixJQUFJdkI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU91QjtRQUNUO1lBQ0UsT0FBT0c7SUFDWDtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU1gsU0FBU1ksRUFBRTtJQUNsQixJQUFJQSxNQUFNeEIsR0FBRztRQUNYLE9BQU95QixLQUFLQyxLQUFLLENBQUNGLEtBQUt4QixLQUFLO0lBQzlCO0lBQ0EsSUFBSXdCLE1BQU16QixHQUFHO1FBQ1gsT0FBTzBCLEtBQUtDLEtBQUssQ0FBQ0YsS0FBS3pCLEtBQUs7SUFDOUI7SUFDQSxJQUFJeUIsTUFBTTFCLEdBQUc7UUFDWCxPQUFPMkIsS0FBS0MsS0FBSyxDQUFDRixLQUFLMUIsS0FBSztJQUM5QjtJQUNBLElBQUkwQixNQUFNM0IsR0FBRztRQUNYLE9BQU80QixLQUFLQyxLQUFLLENBQUNGLEtBQUszQixLQUFLO0lBQzlCO0lBQ0EsT0FBTzJCLEtBQUs7QUFDZDtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNiLFFBQVFhLEVBQUU7SUFDakIsT0FBT0csT0FBT0gsSUFBSXhCLEdBQUcsVUFDbkIyQixPQUFPSCxJQUFJekIsR0FBRyxXQUNkNEIsT0FBT0gsSUFBSTFCLEdBQUcsYUFDZDZCLE9BQU9ILElBQUkzQixHQUFHLGFBQ2QyQixLQUFLO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELFNBQVNHLE9BQU9ILEVBQUUsRUFBRUosQ0FBQyxFQUFFUSxJQUFJO0lBQ3pCLElBQUlKLEtBQUtKLEdBQUc7UUFDVjtJQUNGO0lBQ0EsSUFBSUksS0FBS0osSUFBSSxLQUFLO1FBQ2hCLE9BQU9LLEtBQUtJLEtBQUssQ0FBQ0wsS0FBS0osS0FBSyxNQUFNUTtJQUNwQztJQUNBLE9BQU9ILEtBQUtLLElBQUksQ0FBQ04sS0FBS0osS0FBSyxNQUFNUSxPQUFPO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MzhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibmFtZXMiOlsicyIsIm0iLCJoIiwiZCIsInkiLCJtb2R1bGUiLCJleHBvcnRzIiwidmFsIiwib3B0aW9ucyIsInR5cGUiLCJsZW5ndGgiLCJwYXJzZSIsImlzTmFOIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0ciIsIlN0cmluZyIsIm1hdGNoIiwiZXhlYyIsIm4iLCJwYXJzZUZsb2F0IiwidG9Mb3dlckNhc2UiLCJ1bmRlZmluZWQiLCJtcyIsIk1hdGgiLCJyb3VuZCIsInBsdXJhbCIsIm5hbWUiLCJmbG9vciIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/node_modules/ms/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ \"(action-browser)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    if (typeof opts == \"undefined\") opts = {};\n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    var head = {\n        next: null,\n        buffer: null\n    };\n    var last = {\n        next: null,\n        buffer: null\n    };\n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__(\"length\", function() {\n        return length;\n    });\n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function(buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        } else {\n            last.next = {\n                next: null,\n                buffer: buf\n            };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit(\"write\", buf);\n        return true;\n    };\n    self.end = function(buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function() {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function(fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        var b = {\n            buffer: firstBuf,\n            next: head.next\n        };\n        while(b && b.buffer){\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        return self;\n    };\n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function(start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (start < ix + buffer.length && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        return big;\n    };\n    self.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        return big;\n    };\n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function(n) {\n        offset += n;\n        length -= n;\n        while(head.buffer && offset >= head.buffer.length){\n            offset -= head.buffer.length;\n            head = head.next ? head.next : {\n                buffer: null,\n                next: null\n            };\n        }\n        if (head.buffer === null) last = {\n            next: null,\n            buffer: null\n        };\n        self.emit(\"advance\", n);\n        return self;\n    };\n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function(n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== \"number\") {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = \"\";\n            self.forEach(function(buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    // The entire concatenated buffer as a string.\n    self.toString = function() {\n        return self.take(\"binary\");\n    };\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(BufferList, EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvdmVuZG9yL0Zhc3RCdWZmZXJMaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHdFQUF3RTtBQUN4RSwwRUFBMEU7QUFDMUUsNEVBQTRFO0FBRTVFLGdCQUFnQjtBQUNoQixtRUFBbUU7O0FBQ25FLElBQUlBLFNBQVNDLG9EQUF3QjtBQUNyQyxJQUFJQyxlQUFlRCwwREFBOEI7QUFDakQsSUFBSUUsb0JBQW9CRixxSEFBeUM7QUFFakVHLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJGLHlCQUF5QixHQUFHRSxZQUFZLDBCQUEwQjtBQUVsRSxTQUFTQSxXQUFXQyxJQUFJO0lBQ3BCLElBQUksQ0FBRSxLQUFJLFlBQVlELFVBQVMsR0FBSSxPQUFPLElBQUlBLFdBQVdDO0lBQ3pETCxhQUFhTSxJQUFJLENBQUMsSUFBSTtJQUN0QixJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLE9BQU9GLFFBQVMsYUFBYUEsT0FBTyxDQUFDO0lBRXpDLDZEQUE2RDtJQUM3RCx3Q0FBd0M7SUFDeENFLEtBQUtDLFFBQVEsR0FBR0gsS0FBS0csUUFBUTtJQUU3QixJQUFJQyxPQUFPO1FBQUVDLE1BQU87UUFBTUMsUUFBUztJQUFLO0lBQ3hDLElBQUlDLE9BQU87UUFBRUYsTUFBTztRQUFNQyxRQUFTO0lBQUs7SUFFeEMscURBQXFEO0lBQ3JELG1DQUFtQztJQUNuQyxJQUFJRSxTQUFTO0lBQ2JOLEtBQUtPLGdCQUFnQixDQUFDLFVBQVU7UUFDNUIsT0FBT0Q7SUFDWDtJQUVBLGdFQUFnRTtJQUNoRSxJQUFJRSxTQUFTO0lBRWIsK0RBQStEO0lBQy9EUixLQUFLUyxLQUFLLEdBQUcsU0FBVUMsR0FBRztRQUN0QixJQUFJLENBQUNSLEtBQUtFLE1BQU0sRUFBRTtZQUNkRixLQUFLRSxNQUFNLEdBQUdNO1lBQ2RMLE9BQU9IO1FBQ1gsT0FDSztZQUNERyxLQUFLRixJQUFJLEdBQUc7Z0JBQUVBLE1BQU87Z0JBQU1DLFFBQVNN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UTtRQUN2QyxJQUFJQSxVQUFVO1lBQ1YsSUFBSTBDLE1BQU07WUFDVjNDLEtBQUttQixPQUFPLENBQUMsU0FBVWYsTUFBTTtnQkFDekIsSUFBSXFDLEtBQUssR0FBRyxPQUFPO2dCQUNuQkUsT0FBT3ZDLE9BQU93QyxRQUFRLENBQ2xCM0MsVUFBVSxHQUFHOEIsS0FBS0UsR0FBRyxDQUFDUSxHQUFFckMsT0FBT0UsTUFBTTtnQkFFekNtQyxLQUFLckMsT0FBT0UsTUFBTTtZQUN0QjtZQUNBLE9BQU9xQztRQUNYLE9BQU87WUFDSCx1REFBdUQ7WUFDdkQsT0FBTzNDLEtBQUt5QixJQUFJLENBQUMsR0FBR2dCO1FBQ3hCO0lBQ0o7SUFFQSw4Q0FBOEM7SUFDOUN6QyxLQUFLNEMsUUFBUSxHQUFHO1FBQ1osT0FBTzVDLEtBQUswQyxJQUFJLENBQUM7SUFDckI7QUFDSjtBQUNBbEQsa0RBQXdCLENBQUNLLFlBQVlKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC92ZW5kb3IvRmFzdEJ1ZmZlckxpc3QuanM/YTZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9ub2RlLWJ1ZmZlcmxpc3Rcbi8vIGFuZCBtb2RpZmllZCB0byBiZSBhYmxlIHRvIGNvcHkgYnl0ZXMgZnJvbSB0aGUgYnVmZmVybGlzdCBkaXJlY3RseSBpbnRvXG4vLyBhIHByZS1leGlzdGluZyBmaXhlZC1zaXplIGJ1ZmZlciB3aXRob3V0IGFuIGFkZGl0aW9uYWwgbWVtb3J5IGFsbG9jYXRpb24uXG5cbi8vIGJ1ZmZlcmxpc3QuanNcbi8vIFRyZWF0IGEgbGlua2VkIGxpc3Qgb2YgYnVmZmVycyBhcyBhIHNpbmdsZSB2YXJpYWJsZS1zaXplIGJ1ZmZlci5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGJ1ZmZlckFsbG9jVW5zYWZlID0gcmVxdWlyZSgnLi4vbGliL3V0aWxzJykuYnVmZmVyQWxsb2NVbnNhZmU7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdDtcbm1vZHVsZS5leHBvcnRzLkJ1ZmZlckxpc3QgPSBCdWZmZXJMaXN0OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KG9wdHMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkpIHJldHVybiBuZXcgQnVmZmVyTGlzdChvcHRzKTtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgaWYgKHR5cGVvZihvcHRzKSA9PSAndW5kZWZpbmVkJykgb3B0cyA9IHt9O1xuICAgIFxuICAgIC8vIGRlZmF1bHQgZW5jb2RpbmcgdG8gdXNlIGZvciB0YWtlKCkuIExlYXZpbmcgYXMgJ3VuZGVmaW5lZCdcbiAgICAvLyBtYWtlcyB0YWtlKCkgcmV0dXJuIGEgQnVmZmVyIGluc3RlYWQuXG4gICAgc2VsZi5lbmNvZGluZyA9IG9wdHMuZW5jb2Rpbmc7XG4gICAgXG4gICAgdmFyIGhlYWQgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgdmFyIGxhc3QgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgXG4gICAgLy8gbGVuZ3RoIGNhbiBnZXQgbmVnYXRpdmUgd2hlbiBhZHZhbmNlZCBwYXN0IHRoZSBlbmRcbiAgICAvLyBhbmQgdGhpcyBpcyB0aGUgZGVzaXJlZCBiZWhhdmlvclxuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHNlbGYuX19kZWZpbmVHZXR0ZXJfXygnbGVuZ3RoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIGtlZXAgYW4gb2Zmc2V0IG9mIHRoZSBoZWFkIHRvIGRlY2lkZSB3aGVuIHRvIGhlYWQgPSBoZWFkLm5leHRcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBcbiAgICAvLyBXcml0ZSB0byB0aGUgYnVmZmVybGlzdC4gRW1pdHMgJ3dyaXRlJy4gQWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAgICBzZWxmLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICBpZiAoIWhlYWQuYnVmZmVyKSB7XG4gICAgICAgICAgICBoZWFkLmJ1ZmZlciA9IGJ1ZjtcbiAgICAgICAgICAgIGxhc3QgPSBoZWFkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdC5uZXh0ID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogYnVmIH07XG4gICAgICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBzZWxmLmVtaXQoJ3dyaXRlJywgYnVmKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLmVuZCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSBzZWxmLndyaXRlKGJ1Zik7XG4gICAgfTtcbiAgICBcbiAgICAvLyBQdXNoIGJ1ZmZlcnMgdG8gdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QuIChkZXByZWNhdGVkKVxuICAgIC8vIFJldHVybiB0aGlzIChzZWxmKS5cbiAgICBzZWxmLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLmZvckVhY2goc2VsZi53cml0ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggYnVmZmVyLCBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuICAgIC8vIElmIGZuJ3MgcmVzdWx0IGlzIGEgdHJ1ZSB2YWx1ZSwgY3V0IG91dCBlYXJseS5cbiAgICAvLyBSZXR1cm5zIHRoaXMgKHNlbGYpLlxuICAgIHNlbGYuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAoIWhlYWQuYnVmZmVyKSByZXR1cm4gYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaGVhZC5idWZmZXIubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHJldHVybiBzZWxmO1xuICAgICAgICB2YXIgZmlyc3RCdWYgPSBoZWFkLmJ1ZmZlci5zbGljZShvZmZzZXQpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGIgPSB7IGJ1ZmZlciA6IGZpcnN0QnVmLCBuZXh0IDogaGVhZC5uZXh0IH07XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAoYiAmJiBiLmJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIHIgPSBmbihiLmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAocikgYnJlYWs7XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbmdsZSBCdWZmZXIgb3V0IG9mIGFsbCB0aGUgY2h1bmtzIG9yIHNvbWUgc3Vic2V0IHNwZWNpZmllZCBieVxuICAgIC8vIHN0YXJ0IGFuZCBvbmUtcGFzdCB0aGUgZW5kIChsaWtlIHNsaWNlKSBpbiBieXRlcy5cbiAgICBzZWxmLmpvaW4gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIWhlYWQuYnVmZmVyKSByZXR1cm4gYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIGlmIChzdGFydCA9PSB1bmRlZmluZWQpIHN0YXJ0ID0gMDtcbiAgICAgICAgaWYgKGVuZCA9PSB1bmRlZmluZWQpIGVuZCA9IHNlbGYubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgdmFyIGJpZyA9IGJ1ZmZlckFsbG9jVW5zYWZlKGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IChpeCArIGJ1ZmZlci5sZW5ndGgpICYmIGl4IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgcGFydGlhbGx5IGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShcbiAgICAgICAgICAgICAgICAgICAgYmlnLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBpeCAtIHN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc3RhcnQgLSBpeCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIGVuZCAtIGl4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpeCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGl4ID4gZW5kKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcCBwcm9jZXNzaW5nIHBhc3QgZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpZztcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuam9pbkludG8gPSBmdW5jdGlvbiAodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICAgICAgICBpZiAoIWhlYWQuYnVmZmVyKSByZXR1cm4gbmV3IGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAoc291cmNlU3RhcnQgPT0gdW5kZWZpbmVkKSBzb3VyY2VTdGFydCA9IDA7XG4gICAgICAgIGlmIChzb3VyY2VFbmQgPT0gdW5kZWZpbmVkKSBzb3VyY2VFbmQgPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWcgPSB0YXJnZXRCdWZmZXI7XG4gICAgICAgIGlmIChiaWcubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBzb3VyY2VFbmQgLSBzb3VyY2VTdGFydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdWZmaWNpZW50IHNwYWNlIGF2YWlsYWJsZSBpbiB0YXJnZXQgQnVmZmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXggPSAwO1xuICAgICAgICBzZWxmLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVN0YXJ0IDwgKGl4ICsgYnVmZmVyLmxlbmd0aCkgJiYgaXggPCBzb3VyY2VFbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBwYXJ0aWFsbHkgY29udGFpbmVkIGluIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5jb3B5KFxuICAgICAgICAgICAgICAgICAgICBiaWcsXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRhcmdldFN0YXJ0LCB0YXJnZXRTdGFydCArIGl4IC0gc291cmNlU3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBzb3VyY2VTdGFydCAtIGl4KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oYnVmZmVyLmxlbmd0aCwgc291cmNlRW5kIC0gaXgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl4ICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXggPiBzb3VyY2VFbmQpIHJldHVybiB0cnVlOyAvLyBzdG9wIHByb2Nlc3NpbmcgcGFzdCBlbmRcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYmlnO1xuICAgIH07XG4gICAgXG4gICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIHN0cmVhbSBieSBuIGJ5dGVzLlxuICAgIC8vIElmIG4gdGhlIGFnZ3JlZ2F0ZSBhZHZhbmNlIG9mZnNldCBwYXNzZXMgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGxpc3QsXG4gICAgLy8gb3BlcmF0aW9ucyBzdWNoIGFzIC50YWtlKCkgd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5ncyB1bnRpbCBlbm91Z2ggZGF0YSBpc1xuICAgIC8vIHB1c2hlZC5cbiAgICAvLyBSZXR1cm5zIHRoaXMgKHNlbGYpLlxuICAgIHNlbGYuYWR2YW5jZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICBsZW5ndGggLT0gbjtcbiAgICAgICAgd2hpbGUgKGhlYWQuYnVmZmVyICYmIG9mZnNldCA+PSBoZWFkLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBoZWFkLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0XG4gICAgICAgICAgICAgICAgPyBoZWFkLm5leHRcbiAgICAgICAgICAgICAgICA6IHsgYnVmZmVyIDogbnVsbCwgbmV4dCA6IG51bGwgfVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkLmJ1ZmZlciA9PT0gbnVsbCkgbGFzdCA9IHsgbmV4dCA6IG51bGwsIGJ1ZmZlciA6IG51bGwgfTtcbiAgICAgICAgc2VsZi5lbWl0KCdhZHZhbmNlJywgbik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgLy8gVGFrZSBuIGJ5dGVzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXJzLlxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGxlc3MgdGhhbiBuIGJ5dGVzIGluIGFsbCB0aGUgYnVmZmVycyBvciBuIGlzIHVuZGVmaW5lZCxcbiAgICAvLyByZXR1cm5zIHRoZSBlbnRpcmUgY29uY2F0ZW5hdGVkIGJ1ZmZlciBzdHJpbmcuXG4gICAgc2VsZi50YWtlID0gZnVuY3Rpb24gKG4sIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChuID09IHVuZGVmaW5lZCkgbiA9IHNlbGYubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gbjtcbiAgICAgICAgICAgIG4gPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGhlYWQ7XG4gICAgICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc2VsZi5lbmNvZGluZztcbiAgICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgICAgICB2YXIgYWNjID0gJyc7XG4gICAgICAgICAgICBzZWxmLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGlmIChuIDw9IDApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGFjYyArPSBidWZmZXIudG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLCAwLCBNYXRoLm1pbihuLGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuIC09IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyAnZW5jb2RpbmcnIGlzIHNwZWNpZmllZCwgdGhlbiByZXR1cm4gYSBCdWZmZXIuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5qb2luKDAsIG4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBUaGUgZW50aXJlIGNvbmNhdGVuYXRlZCBidWZmZXIgYXMgYSBzdHJpbmcuXG4gICAgc2VsZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudGFrZSgnYmluYXJ5Jyk7XG4gICAgfTtcbn1cbnJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cyhCdWZmZXJMaXN0LCBFdmVudEVtaXR0ZXIpO1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJidWZmZXJBbGxvY1Vuc2FmZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJCdWZmZXJMaXN0Iiwib3B0cyIsImNhbGwiLCJzZWxmIiwiZW5jb2RpbmciLCJoZWFkIiwibmV4dCIsImJ1ZmZlciIsImxhc3QiLCJsZW5ndGgiLCJfX2RlZmluZUdldHRlcl9fIiwib2Zmc2V0Iiwid3JpdGUiLCJidWYiLCJlbWl0IiwiZW5kIiwiaXNCdWZmZXIiLCJwdXNoIiwiYXJncyIsImNvbmNhdCIsImFwcGx5IiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsImZuIiwiZmlyc3RCdWYiLCJzbGljZSIsImIiLCJyIiwiam9pbiIsInN0YXJ0IiwidW5kZWZpbmVkIiwiYmlnIiwiaXgiLCJjb3B5IiwiTWF0aCIsIm1heCIsIm1pbiIsImpvaW5JbnRvIiwidGFyZ2V0QnVmZmVyIiwidGFyZ2V0U3RhcnQiLCJzb3VyY2VTdGFydCIsInNvdXJjZUVuZCIsIkVycm9yIiwiYWR2YW5jZSIsIm4iLCJ0YWtlIiwiYWNjIiwidG9TdHJpbmciLCJpbmhlcml0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/websocket/vendor/FastBufferList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    if (typeof opts == \"undefined\") opts = {};\n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    var head = {\n        next: null,\n        buffer: null\n    };\n    var last = {\n        next: null,\n        buffer: null\n    };\n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__(\"length\", function() {\n        return length;\n    });\n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function(buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        } else {\n            last.next = {\n                next: null,\n                buffer: buf\n            };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit(\"write\", buf);\n        return true;\n    };\n    self.end = function(buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function() {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function(fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        var b = {\n            buffer: firstBuf,\n            next: head.next\n        };\n        while(b && b.buffer){\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        return self;\n    };\n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function(start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (start < ix + buffer.length && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        return big;\n    };\n    self.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        return big;\n    };\n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function(n) {\n        offset += n;\n        length -= n;\n        while(head.buffer && offset >= head.buffer.length){\n            offset -= head.buffer.length;\n            head = head.next ? head.next : {\n                buffer: null,\n                next: null\n            };\n        }\n        if (head.buffer === null) last = {\n            next: null,\n            buffer: null\n        };\n        self.emit(\"advance\", n);\n        return self;\n    };\n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function(n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== \"number\") {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = \"\";\n            self.forEach(function(buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    // The entire concatenated buffer as a string.\n    self.toString = function() {\n        return self.take(\"binary\");\n    };\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(BufferList, EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L3ZlbmRvci9GYXN0QnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFLDRFQUE0RTtBQUU1RSxnQkFBZ0I7QUFDaEIsbUVBQW1FOztBQUNuRSxJQUFJQSxTQUFTQyxvREFBd0I7QUFDckMsSUFBSUMsZUFBZUQsMERBQThCO0FBQ2pELElBQUlFLG9CQUFvQkYsMEdBQXlDO0FBRWpFRyxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCRix5QkFBeUIsR0FBR0UsWUFBWSwwQkFBMEI7QUFFbEUsU0FBU0EsV0FBV0MsSUFBSTtJQUNwQixJQUFJLENBQUUsS0FBSSxZQUFZRCxVQUFTLEdBQUksT0FBTyxJQUFJQSxXQUFXQztJQUN6REwsYUFBYU0sSUFBSSxDQUFDLElBQUk7SUFDdEIsSUFBSUMsT0FBTyxJQUFJO0lBRWYsSUFBSSxPQUFPRixRQUFTLGFBQWFBLE9BQU8sQ0FBQztJQUV6Qyw2REFBNkQ7SUFDN0Qsd0NBQXdDO0lBQ3hDRSxLQUFLQyxRQUFRLEdBQUdILEtBQUtHLFFBQVE7SUFFN0IsSUFBSUMsT0FBTztRQUFFQyxNQUFPO1FBQU1DLFFBQVM7SUFBSztJQUN4QyxJQUFJQyxPQUFPO1FBQUVGLE1BQU87UUFBTUMsUUFBUztJQUFLO0lBRXhDLHFEQUFxRDtJQUNyRCxtQ0FBbUM7SUFDbkMsSUFBSUUsU0FBUztJQUNiTixLQUFLTyxnQkFBZ0IsQ0FBQyxVQUFVO1FBQzVCLE9BQU9EO0lBQ1g7SUFFQSxnRUFBZ0U7SUFDaEUsSUFBSUUsU0FBUztJQUViLCtEQUErRDtJQUMvRFIsS0FBS1MsS0FBSyxHQUFHLFNBQVVDLEdBQUc7UUFDdEIsSUFBSSxDQUFDUixLQUFLRSxNQUFNLEVBQUU7WUFDZEYsS0FBS0UsTUFBTSxHQUFHTTtZQUNkTCxPQUFPSDtRQUNYLE9BQ0s7WUFDREcsS0FBS0YsSUFBSSxHQUFHO2dCQUFFQSxNQUFPO2dCQUFNQyxRQUFTTTtZQUFJO1lBQ3hDTCxPQUFPQSxLQUFLRixJQUFJO1FBQ3BCO1FBQ0FHLFVBQVVJLElBQUlKLE1BQU07UUFDcEJOLEtBQUtXLElBQUksQ0FBQyxTQUFTRDtRQUNuQixPQUFPO0lBQ1g7SUFFQVYsS0FBS1ksR0FBRyxHQUFHLFNBQVVGLEdBQUc7UUFDcEIsSUFBSW5CLE9BQU9zQixRQUFRLENBQUNILE1BQU1WLEtBQUtTLEtBQUssQ0FBQ0M7SUFDekM7SUFFQSwyREFBMkQ7SUFDM0Qsc0JBQXNCO0lBQ3RCVixLQUFLYyxJQUFJLEdBQUc7UUFDUixJQUFJQyxPQUFPLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRSxFQUFFQztRQUMvQkgsS0FBS0ksT0FBTyxDQUFDbkIsS0FBS1MsS0FBSztRQUN2QixPQUFPVDtJQUNYO0lBRUEsd0NBQXdDO0lBQ3hDLGlEQUFpRDtJQUNqRCx1QkFBdUI7SUFDdkJBLEtBQUttQixPQUFPLEdBQUcsU0FBVUMsRUFBRTtRQUN2QixJQUFJLENBQUNsQixLQUFLRSxNQUFNLEVBQUUsT0FBT1Ysa0JBQWtCO1FBRTNDLElBQUlRLEtBQUtFLE1BQU0sQ0FBQ0UsTUFBTSxHQUFHRSxVQUFVLEdBQUcsT0FBT1I7UUFDN0MsSUFBSXFCLFdBQVduQixLQUFLRSxNQUFNLENBQUNrQixLQUFLLENBQUNkO1FBRWpDLElBQUllLElBQUk7WUFBRW5CLFFBQVNpQjtZQUFVbEIsTUFBT0QsS0FBS0MsSUFBSTtRQUFDO1FBRTlDLE1BQU9vQixLQUFLQSxFQUFFbkIsTUFBTSxDQUFFO1lBQ2xCLElBQUlvQixJQUFJSixHQUFHRyxFQUFFbkIsTUFBTTtZQUNuQixJQUFJb0IsR0FBRztZQUNQRCxJQUFJQSxFQUFFcEIsSUFBSTtRQUNkO1FBRUEsT0FBT0g7SUFDWDtJQUVBLDJFQUEyRTtJQUMzRSxvREFBb0Q7SUFDcERBLEtBQUt5QixJQUFJLEdBQUcsU0FBVUMsS0FBSyxFQUFFZCxHQUFHO1FBQzVCLElBQUksQ0FBQ1YsS0FBS0UsTUFBTSxFQUFFLE9BQU9WLGtCQUFrQjtRQUMzQyxJQUFJZ0MsU0FBU0MsV0FBV0QsUUFBUTtRQUNoQyxJQUFJZCxPQUFPZSxXQUFXZixNQUFNWixLQUFLTSxNQUFNO1FBRXZDLElBQUlzQixNQUFNbEMsa0JBQWtCa0IsTUFBTWM7UUFDbEMsSUFBSUcsS0FBSztRQUNUN0IsS0FBS21CLE9BQU8sQ0FBQyxTQUFVZixNQUFNO1lBQ3pCLElBQUlzQixRQUFTRyxLQUFLekIsT0FBT0UsTUFBTSxJQUFLdUIsS0FBS2pCLEtBQUs7Z0JBQzFDLDRDQUE0QztnQkFDNUNSLE9BQU8wQixJQUFJLENBQ1BGLEtBQ0FHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSCxLQUFLSCxRQUNqQkssS0FBS0MsR0FBRyxDQUFDLEdBQUdOLFFBQVFHLEtBQ3BCRSxLQUFLRSxHQUFHLENBQUM3QixPQUFPRSxNQUFNLEVBQUVNLE1BQU1pQjtZQUV0QztZQUNBQSxNQUFNekIsT0FBT0UsTUFBTTtZQUNuQixJQUFJdUIsS0FBS2pCLEtBQUssT0FBTyxNQUFNLDJCQUEyQjtRQUMxRDtRQUVBLE9BQU9nQjtJQUNYO0lBRUE1QixLQUFLa0MsUUFBUSxHQUFHLFNBQVVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFNBQVM7UUFDdkUsSUFBSSxDQUFDcEMsS0FBS0UsTUFBTSxFQUFFLE9BQU8sSUFBSVYsa0JBQWtCO1FBQy9DLElBQUkyQyxlQUFlVixXQUFXVSxjQUFjO1FBQzVDLElBQUlDLGFBQWFYLFdBQVdXLFlBQVl0QyxLQUFLTSxNQUFNO1FBRW5ELElBQUlzQixNQUFNTztRQUNWLElBQUlQLElBQUl0QixNQUFNLEdBQUc4QixjQUFjRSxZQUFZRCxhQUFhO1lBQ3BELE1BQU0sSUFBSUUsTUFBTTtRQUNwQjtRQUNBLElBQUlWLEtBQUs7UUFDVDdCLEtBQUttQixPQUFPLENBQUMsU0FBVWYsTUFBTTtZQUN6QixJQUFJaUMsY0FBZVIsS0FBS3pCLE9BQU9FLE1BQU0sSUFBS3VCLEtBQUtTLFdBQVc7Z0JBQ3RELDRDQUE0QztnQkFDNUNsQyxPQUFPMEIsSUFBSSxDQUNQRixLQUNBRyxLQUFLQyxHQUFHLENBQUNJLGFBQWFBLGNBQWNQLEtBQUtRLGNBQ3pDTixLQUFLQyxHQUFHLENBQUMsR0FBR0ssY0FBY1IsS0FDMUJFLEtBQUtFLEdBQUcsQ0FBQzdCLE9BQU9FLE1BQU0sRUFBRWdDLFlBQVlUO1lBRTVDO1lBQ0FBLE1BQU16QixPQUFPRSxNQUFNO1lBQ25CLElBQUl1QixLQUFLUyxXQUFXLE9BQU8sTUFBTSwyQkFBMkI7UUFDaEU7UUFFQSxPQUFPVjtJQUNYO0lBRUEsd0NBQXdDO0lBQ3hDLHVFQUF1RTtJQUN2RSw0RUFBNEU7SUFDNUUsVUFBVTtJQUNWLHVCQUF1QjtJQUN2QjVCLEtBQUt3QyxPQUFPLEdBQUcsU0FBVUMsQ0FBQztRQUN0QmpDLFVBQVVpQztRQUNWbkMsVUFBVW1DO1FBQ1YsTUFBT3ZDLEtBQUtFLE1BQU0sSUFBSUksVUFBVU4sS0FBS0UsTUFBTSxDQUFDRSxNQUFNLENBQUU7WUFDaERFLFVBQVVOLEtBQUtFLE1BQU0sQ0FBQ0UsTUFBTTtZQUM1QkosT0FBT0EsS0FBS0MsSUFBSSxHQUNWRCxLQUFLQyxJQUFJLEdBQ1Q7Z0JBQUVDLFFBQVM7Z0JBQU1ELE1BQU87WUFBSztRQUV2QztRQUNBLElBQUlELEtBQUtFLE1BQU0sS0FBSyxNQUFNQyxPQUFPO1lBQUVGLE1BQU87WUFBTUMsUUFBUztRQUFLO1FBQzlESixLQUFLVyxJQUFJLENBQUMsV0FBVzhCO1FBQ3JCLE9BQU96QztJQUNYO0lBRUEsOENBQThDO0lBQzlDLG9CQUFvQjtJQUNwQix1RUFBdUU7SUFDdkUsaURBQWlEO0lBQ2pEQSxLQUFLMEMsSUFBSSxHQUFHLFNBQVVELENBQUMsRUFBRXhDLFFBQVE7UUFDN0IsSUFBSXdDLEtBQUtkLFdBQVdjLElBQUl6QyxLQUFLTSxNQUFNO2FBQzlCLElBQUksT0FBT21DLE1BQU0sVUFBVTtZQUM1QnhDLFdBQVd3QztZQUNYQSxJQUFJekMsS0FBS00sTUFBTTtRQUNuQjtRQUNBLElBQUlpQixJQUFJckI7UUFDUixJQUFJLENBQUNELFVBQVVBLFdBQVdELEtBQUtDLFFBQVE7UUFDdkMsSUFBSUEsVUFBVTtZQUNWLElBQUkwQyxNQUFNO1lBQ1YzQyxLQUFLbUIsT0FBTyxDQUFDLFNBQVVmLE1BQU07Z0JBQ3pCLElBQUlxQyxLQUFLLEdBQUcsT0FBTztnQkFDbkJFLE9BQU92QyxPQUFPd0MsUUFBUSxDQUNsQjNDLFVBQVUsR0FBRzhCLEtBQUtFLEdBQUcsQ0FBQ1EsR0FBRXJDLE9BQU9FLE1BQU07Z0JBRXpDbUMsS0FBS3JDLE9BQU9FLE1BQU07WUFDdEI7WUFDQSxPQUFPcUM7UUFDWCxPQUFPO1lBQ0gsdURBQXVEO1lBQ3ZELE9BQU8zQyxLQUFLeUIsSUFBSSxDQUFDLEdBQUdnQjtRQUN4QjtJQUNKO0lBRUEsOENBQThDO0lBQzlDekMsS0FBSzRDLFFBQVEsR0FBRztRQUNaLE9BQU81QyxLQUFLMEMsSUFBSSxDQUFDO0lBQ3JCO0FBQ0o7QUFDQWxELGtEQUF3QixDQUFDSyxZQUFZSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvdmVuZG9yL0Zhc3RCdWZmZXJMaXN0LmpzP2E2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svbm9kZS1idWZmZXJsaXN0XG4vLyBhbmQgbW9kaWZpZWQgdG8gYmUgYWJsZSB0byBjb3B5IGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmxpc3QgZGlyZWN0bHkgaW50b1xuLy8gYSBwcmUtZXhpc3RpbmcgZml4ZWQtc2l6ZSBidWZmZXIgd2l0aG91dCBhbiBhZGRpdGlvbmFsIG1lbW9yeSBhbGxvY2F0aW9uLlxuXG4vLyBidWZmZXJsaXN0LmpzXG4vLyBUcmVhdCBhIGxpbmtlZCBsaXN0IG9mIGJ1ZmZlcnMgYXMgYSBzaW5nbGUgdmFyaWFibGUtc2l6ZSBidWZmZXIuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0ID0gQnVmZmVyTGlzdDsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZnVuY3Rpb24gQnVmZmVyTGlzdChvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSByZXR1cm4gbmV3IEJ1ZmZlckxpc3Qob3B0cyk7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2Yob3B0cykgPT0gJ3VuZGVmaW5lZCcpIG9wdHMgPSB7fTtcbiAgICBcbiAgICAvLyBkZWZhdWx0IGVuY29kaW5nIHRvIHVzZSBmb3IgdGFrZSgpLiBMZWF2aW5nIGFzICd1bmRlZmluZWQnXG4gICAgLy8gbWFrZXMgdGFrZSgpIHJldHVybiBhIEJ1ZmZlciBpbnN0ZWFkLlxuICAgIHNlbGYuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICAgIFxuICAgIHZhciBoZWFkID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIHZhciBsYXN0ID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIFxuICAgIC8vIGxlbmd0aCBjYW4gZ2V0IG5lZ2F0aXZlIHdoZW4gYWR2YW5jZWQgcGFzdCB0aGUgZW5kXG4gICAgLy8gYW5kIHRoaXMgaXMgdGhlIGRlc2lyZWQgYmVoYXZpb3JcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oJ2xlbmd0aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBrZWVwIGFuIG9mZnNldCBvZiB0aGUgaGVhZCB0byBkZWNpZGUgd2hlbiB0byBoZWFkID0gaGVhZC5uZXh0XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgXG4gICAgLy8gV3JpdGUgdG8gdGhlIGJ1ZmZlcmxpc3QuIEVtaXRzICd3cml0ZScuIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgc2VsZi53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikge1xuICAgICAgICAgICAgaGVhZC5idWZmZXIgPSBidWY7XG4gICAgICAgICAgICBsYXN0ID0gaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHsgbmV4dCA6IG51bGwsIGJ1ZmZlciA6IGJ1ZiB9O1xuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2VsZi5lbWl0KCd3cml0ZScsIGJ1Zik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5lbmQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkgc2VsZi53cml0ZShidWYpO1xuICAgIH07XG4gICAgXG4gICAgLy8gUHVzaCBidWZmZXJzIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LiAoZGVwcmVjYXRlZClcbiAgICAvLyBSZXR1cm4gdGhpcyAoc2VsZikuXG4gICAgc2VsZi5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5mb3JFYWNoKHNlbGYud3JpdGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGJ1ZmZlciwgcGVyZm9ybSBzb21lIGFjdGlvbi5cbiAgICAvLyBJZiBmbidzIHJlc3VsdCBpcyBhIHRydWUgdmFsdWUsIGN1dCBvdXQgZWFybHkuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGhlYWQuYnVmZmVyLmxlbmd0aCAtIG9mZnNldCA8PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgICAgdmFyIGZpcnN0QnVmID0gaGVhZC5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBiID0geyBidWZmZXIgOiBmaXJzdEJ1ZiwgbmV4dCA6IGhlYWQubmV4dCB9O1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKGIgJiYgYi5idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gZm4oYi5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHIpIGJyZWFrO1xuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW5nbGUgQnVmZmVyIG91dCBvZiBhbGwgdGhlIGNodW5rcyBvciBzb21lIHN1YnNldCBzcGVjaWZpZWQgYnlcbiAgICAvLyBzdGFydCBhbmQgb25lLXBhc3QgdGhlIGVuZCAobGlrZSBzbGljZSkgaW4gYnl0ZXMuXG4gICAgc2VsZi5qb2luID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAoc3RhcnQgPT0gdW5kZWZpbmVkKSBzdGFydCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT0gdW5kZWZpbmVkKSBlbmQgPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWcgPSBidWZmZXJBbGxvY1Vuc2FmZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHZhciBpeCA9IDA7XG4gICAgICAgIHNlbGYuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAoaXggKyBidWZmZXIubGVuZ3RoKSAmJiBpeCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkoXG4gICAgICAgICAgICAgICAgICAgIGJpZyxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgaXggLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHN0YXJ0IC0gaXgpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBlbmQgLSBpeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpeCA+IGVuZCkgcmV0dXJuIHRydWU7IC8vIHN0b3AgcHJvY2Vzc2luZyBwYXN0IGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiaWc7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLmpvaW5JbnRvID0gZnVuY3Rpb24gKHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIG5ldyBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ID09IHVuZGVmaW5lZCkgc291cmNlU3RhcnQgPSAwO1xuICAgICAgICBpZiAoc291cmNlRW5kID09IHVuZGVmaW5lZCkgc291cmNlRW5kID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgYmlnID0gdGFyZ2V0QnVmZmVyO1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgc291cmNlRW5kIC0gc291cmNlU3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBzcGFjZSBhdmFpbGFibGUgaW4gdGFyZ2V0IEJ1ZmZlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTdGFydCA8IChpeCArIGJ1ZmZlci5sZW5ndGgpICYmIGl4IDwgc291cmNlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgcGFydGlhbGx5IGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShcbiAgICAgICAgICAgICAgICAgICAgYmlnLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0YXJnZXRTdGFydCwgdGFyZ2V0U3RhcnQgKyBpeCAtIHNvdXJjZVN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc291cmNlU3RhcnQgLSBpeCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIHNvdXJjZUVuZCAtIGl4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpeCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGl4ID4gc291cmNlRW5kKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcCBwcm9jZXNzaW5nIHBhc3QgZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpZztcbiAgICB9O1xuICAgIFxuICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBzdHJlYW0gYnkgbiBieXRlcy5cbiAgICAvLyBJZiBuIHRoZSBhZ2dyZWdhdGUgYWR2YW5jZSBvZmZzZXQgcGFzc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBsaXN0LFxuICAgIC8vIG9wZXJhdGlvbnMgc3VjaCBhcyAudGFrZSgpIHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZ3MgdW50aWwgZW5vdWdoIGRhdGEgaXNcbiAgICAvLyBwdXNoZWQuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmFkdmFuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgbGVuZ3RoIC09IG47XG4gICAgICAgIHdoaWxlIChoZWFkLmJ1ZmZlciAmJiBvZmZzZXQgPj0gaGVhZC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gaGVhZC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dFxuICAgICAgICAgICAgICAgID8gaGVhZC5uZXh0XG4gICAgICAgICAgICAgICAgOiB7IGJ1ZmZlciA6IG51bGwsIG5leHQgOiBudWxsIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZC5idWZmZXIgPT09IG51bGwpIGxhc3QgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgICAgIHNlbGYuZW1pdCgnYWR2YW5jZScsIG4pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRha2UgbiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVycy5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nLlxuICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHRoYW4gbiBieXRlcyBpbiBhbGwgdGhlIGJ1ZmZlcnMgb3IgbiBpcyB1bmRlZmluZWQsXG4gICAgLy8gcmV0dXJucyB0aGUgZW50aXJlIGNvbmNhdGVuYXRlZCBidWZmZXIgc3RyaW5nLlxuICAgIHNlbGYudGFrZSA9IGZ1bmN0aW9uIChuLCBlbmNvZGluZykge1xuICAgICAgICBpZiAobiA9PSB1bmRlZmluZWQpIG4gPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IG47XG4gICAgICAgICAgICBuID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBoZWFkO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHNlbGYuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIGFjYyA9ICcnO1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYnVmZmVyLnRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZywgMCwgTWF0aC5taW4obixidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbiAtPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gJ2VuY29kaW5nJyBpcyBzcGVjaWZpZWQsIHRoZW4gcmV0dXJuIGEgQnVmZmVyLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuam9pbigwLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gVGhlIGVudGlyZSBjb25jYXRlbmF0ZWQgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICAgIHNlbGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRha2UoJ2JpbmFyeScpO1xuICAgIH07XG59XG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRXZlbnRFbWl0dGVyKTtcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyTGlzdCIsIm9wdHMiLCJjYWxsIiwic2VsZiIsImVuY29kaW5nIiwiaGVhZCIsIm5leHQiLCJidWZmZXIiLCJsYXN0IiwibGVuZ3RoIiwiX19kZWZpbmVHZXR0ZXJfXyIsIm9mZnNldCIsIndyaXRlIiwiYnVmIiwiZW1pdCIsImVuZCIsImlzQnVmZmVyIiwicHVzaCIsImFyZ3MiLCJjb25jYXQiLCJhcHBseSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJmbiIsImZpcnN0QnVmIiwic2xpY2UiLCJiIiwiciIsImpvaW4iLCJzdGFydCIsInVuZGVmaW5lZCIsImJpZyIsIml4IiwiY29weSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJqb2luSW50byIsInRhcmdldEJ1ZmZlciIsInRhcmdldFN0YXJ0Iiwic291cmNlU3RhcnQiLCJzb3VyY2VFbmQiLCJFcnJvciIsImFkdmFuY2UiLCJuIiwidGFrZSIsImFjYyIsInRvU3RyaW5nIiwiaW5oZXJpdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/vendor/FastBufferList.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ }),

/***/ "(rsc)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

};
;