/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-streams-polyfill";
exports.ids = ["vendor-chunks/web-streams-polyfill"];
exports.modules = {

/***/ "(action-browser)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * web-streams-polyfill v3.2.1\n */ (function(global1, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n    /// <reference lib=\"dom\" />\n    function noop() {\n        return undefined;\n    }\n    function getGlobals() {\n        if (typeof self !== \"undefined\") {\n            return self;\n        } else if (false) {} else if (typeof global !== \"undefined\") {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n    function typeIsObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    const rethrowAssertionErrorRejection = noop;\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    function promiseResolvedWith(value) {\n        return originalPromiseResolve(value);\n    }\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    const queueMicrotask = (()=>{\n        const globalQueueMicrotask = globals && globals.queueMicrotask;\n        if (typeof globalQueueMicrotask === \"function\") {\n            return globalQueueMicrotask;\n        }\n        const resolvedPromise = promiseResolvedWith(undefined);\n        return (fn)=>PerformPromiseThen(resolvedPromise, fn);\n    })();\n    function reflectCall(F, V, args) {\n        if (typeof F !== \"function\") {\n            throw new TypeError(\"Argument is not a function\");\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        } catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */ class SimpleQueue {\n        constructor(){\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() {\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while(i !== elements.length || node._next !== undefined){\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() {\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseInitialize(reader);\n        } else if (stream._state === \"closed\") {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        } else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        if (reader._ownerReadableStream._state === \"readable\") {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        } else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        reader._ownerReadableStream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject)=>{\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n    const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n    const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n    const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function(x) {\n        return typeof x === \"number\" && isFinite(x);\n    };\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function(v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === \"object\" || typeof x === \"function\";\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== \"function\") {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        } else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamDefaultReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: ()=>resolvePromise({\n                        value: undefined,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            readRequest._closeSteps();\n        } else if (stream._state === \"errored\") {\n            readRequest._errorSteps(stream._storedError);\n        } else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel){\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = ()=>this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = ()=>this._returnSteps(value);\n            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"iterate\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    queueMicrotask(()=>resolvePromise({\n                            value: chunk,\n                            done: false\n                        }));\n                },\n                _closeSteps: ()=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({\n                        value: undefined,\n                        done: true\n                    });\n                },\n                _errorSteps: (reason)=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value,\n                    done: true\n                });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"finish iterating\"));\n            }\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, ()=>({\n                        value,\n                        done: true\n                    }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({\n                value,\n                done: true\n            });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next () {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return (value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n        } catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function(x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    // Not implemented correctly\n    function TransferArrayBuffer(O) {\n        return O;\n    }\n    // Not implemented correctly\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function IsDetachedBuffer(O) {\n        return false;\n    }\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== \"number\") {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        }\n        container._queue.push({\n            value,\n            size\n        });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */ class ReadableStreamBYOBRequest {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */ get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"view\");\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respond\");\n            }\n            assertRequiredArgument(bytesWritten, 1, \"respond\");\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(this._view.buffer)) ;\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respondWithNewView\");\n            }\n            assertRequiredArgument(view, 1, \"respondWithNewView\");\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError(\"You can only respond with array buffer views\");\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: {\n            enumerable: true\n        },\n        respondWithNewView: {\n            enumerable: true\n        },\n        view: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBRequest\",\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableByteStreamController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */ get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"byobRequest\");\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"desiredSize\");\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"close\");\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"enqueue\");\n            }\n            assertRequiredArgument(chunk, 1, \"enqueue\");\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError(\"chunk must be an array buffer view\");\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError(\"chunk must have non-zero byteLength\");\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"stream is closed or draining\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"error\");\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                const entry = this._queue.shift();\n                this._queueTotalSize -= entry.byteLength;\n                ReadableByteStreamControllerHandleQueueDrain(this);\n                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                readRequest._chunkSteps(view);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: \"default\"\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        byobRequest: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableByteStreamController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n        }, (e)=>{\n            ReadableByteStreamControllerError(controller, e);\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === \"closed\") {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"default\") {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        } else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({\n            buffer,\n            byteOffset,\n            byteLength\n        });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const elementSize = pullIntoDescriptor.elementSize;\n        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        if (maxAlignedBytes > currentAlignedBytes) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while(totalBytesToCopyRemaining > 0){\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            } else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        } else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while(controller._pendingPullIntos.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        let elementSize = 1;\n        if (view.constructor !== DataView) {\n            elementSize = view.constructor.BYTES_PER_ELEMENT;\n        }\n        const ctor = view.constructor;\n        // try {\n        const buffer = TransferArrayBuffer(view.buffer);\n        // } catch (e) {\n        //   readIntoRequest._errorSteps(e);\n        //   return;\n        // }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset: view.byteOffset,\n            byteLength: view.byteLength,\n            bytesFilled: 0,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === \"closed\") {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            ReadableByteStreamControllerRespondInClosedState(controller);\n        } else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled > 0) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        const buffer = chunk.buffer;\n        const byteOffset = chunk.byteOffset;\n        const byteLength = chunk.byteLength;\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n        }\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        if (ReadableStreamHasDefaultReader(stream)) {\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            } else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        } else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        } else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (bytesWritten !== 0) {\n                throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n            }\n        } else {\n            if (bytesWritten === 0) {\n                throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError(\"bytesWritten out of range\");\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (view.byteLength !== 0) {\n                throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n            }\n        } else {\n            if (view.byteLength === 0) {\n                throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError(\"The region specified by view does not match byobRequest\");\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError(\"The region specified by view is larger than byobRequest\");\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }, (r)=>{\n            ReadableByteStreamControllerError(controller, r);\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingByteSource.start(controller);\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        } else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamBYOBReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read(view) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readIntoRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"errored\") {\n            readIntoRequest._errorSteps(stream._storedError);\n        } else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError(\"Invalid highWaterMark\");\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return ()=>1;\n        }\n        return size;\n    }\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n    }\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return ()=>promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n    function isAbortSignal(value) {\n        if (typeof value !== \"object\" || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === \"boolean\";\n        } catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === \"function\";\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */ function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */ class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            } else {\n                assertObject(rawUnderlyingSink, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError(\"Invalid type is specified\");\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */ get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"locked\");\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */ abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */ close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */ getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"getWriter\");\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        getWriter: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStream\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = \"writable\";\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === \"closed\" || stream._state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === \"erroring\") {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject)=>{\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject)=>{\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === \"writable\") {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject)=>{\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === \"writable\") {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = \"erroring\";\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = \"errored\";\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach((writeRequest)=>{\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, ()=>{\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        }, (reason)=>{\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === \"erroring\") {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = \"closed\";\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            } else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */ class WritableStreamDefaultWriter {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n            assertWritableStream(stream, \"First parameter\");\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === \"writable\") {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                } else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"erroring\") {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"closed\") {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            } else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writers lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writers lock is released.\n         */ get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"desiredSize\");\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException(\"desiredSize\");\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n         * rejected.\n         */ get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */ abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */ close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"close\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */ releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"releaseLock\");\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        write: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        },\n        ready: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultWriter\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === \"pending\") {\n            defaultWriterClosedPromiseReject(writer, error);\n        } else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === \"pending\") {\n            defaultWriterReadyPromiseReject(writer, error);\n        } else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === \"errored\" || state === \"erroring\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n        }\n        const state = stream._state;\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n        }\n        if (state === \"erroring\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */ class WritableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */ get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"abortReason\");\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */ get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"signal\");\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */ error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"error\");\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== \"writable\") {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: {\n            enumerable: true\n        },\n        signal: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, ()=>{\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (r)=>{\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let writeAlgorithm = ()=>promiseResolvedWith(undefined);\n        let closeAlgorithm = ()=>promiseResolvedWith(undefined);\n        let abortAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = ()=>underlyingSink.start(controller);\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = ()=>underlyingSink.close();\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        } catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        } catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === \"erroring\") {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        } else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === \"writable\") {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, ()=>{\n            WritableStreamFinishInFlightClose(stream);\n        }, (reason)=>{\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, ()=>{\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (reason)=>{\n            if (stream._state === \"writable\") {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject)=>{\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = \"pending\";\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"rejected\";\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"resolved\";\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject)=>{\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = \"pending\";\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"rejected\";\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"fulfilled\";\n    }\n    /// <reference lib=\"dom\" />\n    const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : undefined;\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        } catch (_a) {\n            return false;\n        }\n    }\n    function createDOMExceptionPolyfill() {\n        // eslint-disable-next-line no-shadow\n        const ctor = function DOMException1(message, name) {\n            this.message = message || \"\";\n            this.name = name || \"Error\";\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, \"constructor\", {\n            value: ctor,\n            writable: true,\n            configurable: true\n        });\n        return ctor;\n    }\n    // eslint-disable-next-line no-redeclare\n    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject)=>{\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = ()=>{\n                    const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(()=>{\n                            if (dest._state === \"writable\") {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(()=>{\n                            if (source._state === \"readable\") {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener(\"abort\", abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop)=>{\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        } else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, ()=>{\n                    return newPromise((resolveRead, rejectRead)=>{\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: (chunk)=>{\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: ()=>resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                if (!preventAbort) {\n                    shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                if (!preventClose) {\n                    shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                } else {\n                    shutdown();\n                }\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                } else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === \"errored\") {\n                    action(stream._storedError);\n                } else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === \"closed\") {\n                    action();\n                } else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                } else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                } else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener(\"abort\", abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                } else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"desiredSize\");\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"close\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits close\");\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"enqueue\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits enqueue\");\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"error\");\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                } else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            } else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n        }, (e)=>{\n            ReadableStreamDefaultControllerError(controller, e);\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        } else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            } catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            } catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === \"readable\") {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(controller, r);\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingSource.start(controller);\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingSource.pull(controller);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n        // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r)=>{\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, (r)=>{\n                if (thisReader !== reader) {\n                    return;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        } else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: (chunk)=>{\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== \"bytes\") {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== \"byob\") {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return {\n            preventCancel: Boolean(preventCancel)\n        };\n    }\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return {\n            readable,\n            writable\n        };\n    }\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */ class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            } else {\n                assertObject(rawUnderlyingSource, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n            InitializeReadableStream(this);\n            if (underlyingSource.type === \"bytes\") {\n                if (strategy.size !== undefined) {\n                    throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            } else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */ get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"locked\");\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"getReader\");\n            }\n            const options = convertReaderOptions(rawOptions, \"First parameter\");\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"pipeThrough\");\n            }\n            assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n            const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n            const options = convertPipeOptions(rawOptions, \"Second parameter\");\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, \"Second parameter\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */ tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"tee\");\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"values\");\n            }\n            const options = convertIteratorOptions(rawOptions, \"First parameter\");\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n    }\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        getReader: {\n            enumerable: true\n        },\n        pipeThrough: {\n            enumerable: true\n        },\n        pipeTo: {\n            enumerable: true\n        },\n        tee: {\n            enumerable: true\n        },\n        values: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStream\",\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = \"readable\";\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            reader._readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._closeSteps(undefined);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = \"closed\";\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach((readRequest)=>{\n                readRequest._closeSteps();\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = \"errored\";\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach((readRequest)=>{\n                readRequest._errorSteps(e);\n            });\n            reader._readRequests = new SimpleQueue();\n        } else {\n            reader._readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._errorSteps(e);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk)=>{\n        return chunk.byteLength;\n    };\n    try {\n        Object.defineProperty(byteLengthSizeFunction, \"name\", {\n            value: \"size\",\n            configurable: true\n        });\n    } catch (_a) {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */ class ByteLengthQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"highWaterMark\");\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */ get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"size\");\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ByteLengthQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = ()=>{\n        return 1;\n    };\n    try {\n        Object.defineProperty(countSizeFunction, \"name\", {\n            value: \"size\",\n            configurable: true\n        });\n    } catch (_a) {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */ class CountQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"highWaterMark\");\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */ get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"size\");\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"CountQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */ class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n            const transformer = convertTransformer(rawTransformer, \"First parameter\");\n            if (transformer.readableType !== undefined) {\n                throw new RangeError(\"Invalid readableType specified\");\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError(\"Invalid writableType specified\");\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise((resolve)=>{\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            } else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */ get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"readable\");\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */ get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"writable\");\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: {\n            enumerable: true\n        },\n        writable: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStream\",\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n            return promiseResolvedWith(undefined);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise((resolve)=>{\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */ class TransformStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n         */ get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"desiredSize\");\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"enqueue\");\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */ error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"error\");\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */ terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"terminate\");\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        terminate: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm = (chunk)=>{\n            try {\n                TransformStreamDefaultControllerEnqueue(controller, chunk);\n                return promiseResolvedWith(undefined);\n            } catch (transformResultE) {\n                return promiseRejectedWith(transformResultE);\n            }\n        };\n        let flushAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = ()=>transformer.flush(controller);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        } catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, (r)=>{\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError(\"TransformStream terminated\");\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, ()=>{\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === \"erroring\") {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n        // errored.\n        TransformStreamError(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        const controller = stream._transformStreamController;\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        // Return a promise that is fulfilled with undefined on success.\n        return transformPromiseWith(flushPromise, ()=>{\n            if (readable._state === \"errored\") {\n                throw readable._storedError;\n            }\n            ReadableStreamDefaultControllerClose(readable._readableStreamController);\n        }, (r)=>{\n            TransformStreamError(stream, r);\n            throw readable._storedError;\n        });\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n    exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports1.CountQueuingStrategy = CountQueuingStrategy;\n    exports1.ReadableByteStreamController = ReadableByteStreamController;\n    exports1.ReadableStream = ReadableStream;\n    exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports1.TransformStream = TransformStream;\n    exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports1.WritableStream = WritableStream;\n    exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=ponyfill.es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLmVzMjAxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUNBLFVBQVVBLE9BQU0sRUFBRUMsT0FBTztJQUN0QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUNrSDtBQUN0SCxHQUFFLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFMUIscUNBQXFDO0lBQ3JDLE1BQU1PLGlCQUFpQixPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsUUFBUSxLQUFLLFdBQzlFRCxTQUNBRSxDQUFBQSxjQUFlLENBQUMsT0FBTyxFQUFFQSxZQUFZLENBQUMsQ0FBQztJQUUzQywyQkFBMkI7SUFDM0IsU0FBU0M7UUFDTCxPQUFPQztJQUNYO0lBQ0EsU0FBU0M7UUFDTCxJQUFJLE9BQU9SLFNBQVMsYUFBYTtZQUM3QixPQUFPQTtRQUNYLE9BQ0ssSUFBSSxLQUFrQixFQUFhLEVBRXZDLE1BQ0ksSUFBSSxPQUFPUCxXQUFXLGFBQWE7WUFDcEMsT0FBT0E7UUFDWDtRQUNBLE9BQU9jO0lBQ1g7SUFDQSxNQUFNRyxVQUFVRjtJQUVoQixTQUFTRyxhQUFhQyxDQUFDO1FBQ25CLE9BQU8sT0FBUUEsTUFBTSxZQUFZQSxNQUFNLFFBQVMsT0FBT0EsTUFBTTtJQUNqRTtJQUNBLE1BQU1DLGlDQUFpQ1A7SUFFdkMsTUFBTVEsa0JBQWtCQztJQUN4QixNQUFNQyxzQkFBc0JELFFBQVFFLFNBQVMsQ0FBQ0MsSUFBSTtJQUNsRCxNQUFNQyx5QkFBeUJKLFFBQVFLLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDUDtJQUNwRCxNQUFNUSx3QkFBd0JQLFFBQVFRLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDUDtJQUNsRCxTQUFTVSxXQUFXQyxRQUFRO1FBQ3hCLE9BQU8sSUFBSVgsZ0JBQWdCVztJQUMvQjtJQUNBLFNBQVNDLG9CQUFvQkMsS0FBSztRQUM5QixPQUFPUix1QkFBdUJRO0lB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cG9ueWZpbGwuZXMyMDE4LmpzP2Y3M2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB3ZWItc3RyZWFtcy1wb2x5ZmlsbCB2My4yLjFcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5XZWJTdHJlYW1zUG9seWZpbGwgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LnN5bWJvbFwiIC8+XG4gICAgY29uc3QgU3ltYm9sUG9seWZpbGwgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cbiAgICAgICAgU3ltYm9sIDpcbiAgICAgICAgZGVzY3JpcHRpb24gPT4gYFN5bWJvbCgke2Rlc2NyaXB0aW9ufSlgO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBnbG9iYWxzID0gZ2V0R2xvYmFscygpO1xuXG4gICAgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiA9IG5vb3A7XG5cbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2UgPSBQcm9taXNlO1xuICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlamVjdCA9IFByb21pc2UucmVqZWN0LmJpbmQob3JpZ2luYWxQcm9taXNlKTtcbiAgICBmdW5jdGlvbiBuZXdQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgb3JpZ2luYWxQcm9taXNlKGV4ZWN1dG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2VSZWplY3RlZFdpdGgocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxuICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCksIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIG9uRnVsZmlsbGVkKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsIHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSkge1xuICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZU1pY3JvdGFzayA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdsb2JhbFF1ZXVlTWljcm90YXNrID0gZ2xvYmFscyAmJiBnbG9iYWxzLnF1ZXVlTWljcm90YXNrO1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsUXVldWVNaWNyb3Rhc2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gKGZuKSA9PiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBmbik7XG4gICAgfSkoKTtcbiAgICBmdW5jdGlvbiByZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoRiwgViwgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2VDYWxsKEYsIFYsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yaWdpbmFsIGZyb20gQ2hyb21pdW1cbiAgICAvLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMGFlZTQ0MzRhNGRiYTQyYTQyYWJhZWE5YmZiYzBjZDE5NmE2M2JjMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL3N0cmVhbXMvU2ltcGxlUXVldWUuanNcbiAgICBjb25zdCBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBBdm9pZHMgc2NhbGFiaWxpdHkgaXNzdWVzIHdpdGggdXNpbmcgYSBwYWNrZWQgYXJyYXkgZGlyZWN0bHkgYnkgdXNpbmdcbiAgICAgKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxuICAgICAqL1xuICAgIGNsYXNzIFNpbXBsZVF1ZXVlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgICAgICAvLyBfZnJvbnQgYW5kIF9iYWNrIGFyZSBhbHdheXMgZGVmaW5lZC5cbiAgICAgICAgICAgIHRoaXMuX2Zyb250ID0ge1xuICAgICAgICAgICAgICAgIF9lbGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2sgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXG4gICAgICAgICAgICAvLyBJdCBjb250YWlucyB0aGUgaW5kZXggb2YgdGhlIGZyb250IGVsZW1lbnQgb2YgdGhlIGFycmF5IGluc2lkZSB0aGVcbiAgICAgICAgICAgIC8vIGZyb250LW1vc3Qgbm9kZS4gSXQgaXMgYWx3YXlzIGluIHRoZSByYW5nZSBbMCwgUVVFVUVfTUFYX0FSUkFZX1NJWkUpLlxuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgbm9kZSwgc2l6ZSA9PT0gZWxlbWVudHMubGVuZ3RoIC0gY3Vyc29yLlxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBleGNlcHRpb24gc2FmZXR5LCB0aGlzIG1ldGhvZCBpcyBzdHJ1Y3R1cmVkIGluIG9yZGVyOlxuICAgICAgICAvLyAxLiBSZWFkIHN0YXRlXG4gICAgICAgIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcbiAgICAgICAgLy8gMy4gUGVyZm9ybSBzdGF0ZSBtdXRhdGlvbnNcbiAgICAgICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvbGRCYWNrID0gdGhpcy5fYmFjaztcbiAgICAgICAgICAgIGxldCBuZXdCYWNrID0gb2xkQmFjaztcbiAgICAgICAgICAgIGlmIChvbGRCYWNrLl9lbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0JhY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9lbGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHVzaCgpIGlzIHRoZSBtdXRhdGlvbiBtb3N0IGxpa2VseSB0byB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGl0XG4gICAgICAgICAgICAvLyBnb2VzIGZpcnN0LlxuICAgICAgICAgICAgb2xkQmFjay5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChuZXdCYWNrICE9PSBvbGRCYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XG4gICAgICAgICAgICAgICAgb2xkQmFjay5fbmV4dCA9IG5ld0JhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3RoaXMuX3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGlrZSBwdXNoKCksIHNoaWZ0KCkgZm9sbG93cyB0aGUgcmVhZCAtPiBjYWxjdWxhdGUgLT4gbXV0YXRlIHBhdHRlcm4gZm9yXG4gICAgICAgIC8vIGV4Y2VwdGlvbiBzYWZldHkuXG4gICAgICAgIHNoaWZ0KCkgeyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcbiAgICAgICAgICAgIGNvbnN0IG9sZEZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICBsZXQgbmV3RnJvbnQgPSBvbGRGcm9udDtcbiAgICAgICAgICAgIGNvbnN0IG9sZEN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgIGxldCBuZXdDdXJzb3IgPSBvbGRDdXJzb3IgKyAxO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbb2xkQ3Vyc29yXTtcbiAgICAgICAgICAgIGlmIChuZXdDdXJzb3IgPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dDtcbiAgICAgICAgICAgICAgICBuZXdDdXJzb3IgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbXV0YXRpb25zIGJlZm9yZSB0aGlzIHBvaW50LlxuICAgICAgICAgICAgLS10aGlzLl9zaXplO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gbmV3Q3Vyc29yO1xuICAgICAgICAgICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ID0gbmV3RnJvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJtaXQgc2hpZnRlZCBlbGVtZW50IHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAgICAgZWxlbWVudHNbb2xkQ3Vyc29yXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSB0cmlja3kgdGhpbmcgYWJvdXQgZm9yRWFjaCgpIGlzIHRoYXQgaXQgY2FuIGJlIGNhbGxlZFxuICAgICAgICAvLyByZS1lbnRyYW50bHkuIFRoZSBxdWV1ZSBtYXkgYmUgbXV0YXRlZCBpbnNpZGUgdGhlIGNhbGxiYWNrLiBJdCBpcyBlYXN5IHRvXG4gICAgICAgIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHF1ZXVlIGlzIGNoZWNrZWQgZm9yIG9uIGV2ZXJ5IGl0ZXJhdGlvbi4gSWYgc2hpZnQoKSBpcyBjYWxsZWRcbiAgICAgICAgLy8gcmVwZWF0ZWRseSB3aXRoaW4gdGhlIGNhbGxiYWNrIHRoZW4gdGhlIG5leHQgaXRlcmF0aW9uIG1heSByZXR1cm4gYW5cbiAgICAgICAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAgLy8gd2l0aCB1bmRlZmluZWQgdmFsdWVzIHVudGlsIHdlIGVpdGhlciBcImNhdGNoIHVwXCIgd2l0aCBlbGVtZW50cyB0aGF0IHN0aWxsXG4gICAgICAgIC8vIGV4aXN0IG9yIHJlYWNoIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgICAgICAgICB3aGlsZSAoaSAhPT0gZWxlbWVudHMubGVuZ3RoIHx8IG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgZWxlbWVudCB0aGF0IHdvdWxkIGJlIHJldHVybmVkIGlmIHNoaWZ0KCkgd2FzIGNhbGxlZCBub3csXG4gICAgICAgIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cbiAgICAgICAgcGVlaygpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgICAgICAgICAgcmV0dXJuIGZyb250Ll9lbGVtZW50c1tjdXJzb3JdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZShyZWFkZXIsIHN0cmVhbSkge1xuICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgYW5kIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGVcbiAgICAvLyBjaGVjay5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcikge1xuICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG4gICAgZnVuY3Rpb24gcmVhZGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyJyk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcikge1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKSB7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocmVhZGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpIHtcbiAgICAgICAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQWJvcnRTdGVwc11dJyk7XG4gICAgY29uc3QgRXJyb3JTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Vycm9yU3RlcHNdXScpO1xuICAgIGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQ2FuY2VsU3RlcHNdXScpO1xuICAgIGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW1B1bGxTdGVwc11dJyk7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlI1BvbHlmaWxsXG4gICAgY29uc3QgTnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh4KTtcbiAgICB9O1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmMjUG9seWZpbGxcbiAgICBjb25zdCBNYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2IDwgMCA/IE1hdGguY2VpbCh2KSA6IE1hdGguZmxvb3Iodik7XG4gICAgfTtcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1kaWN0aW9uYXJpZXNcbiAgICBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iaiwgY29udGV4dCkge1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgIWlzRGljdGlvbmFyeShvYmopKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWNhbGxiYWNrLWZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1vYmplY3RcbiAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh4LCBwb3NpdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHtwb3NpdGlvbn0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkRmllbGQoeCwgZmllbGQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG4gICAgZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZWdlclBhcnQoeCkge1xuICAgICAgICByZXR1cm4gY2Vuc29yTmVnYXRpdmVaZXJvKE1hdGhUcnVuYyh4KSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnNpZ25lZC1sb25nLWxvbmdcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG4gICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgbGV0IHggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICB4ID0gY2Vuc29yTmVnYXRpdmVaZXJvKHgpO1xuICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIGZpbml0ZSBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gaW50ZWdlclBhcnQoeCk7XG4gICAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBVc2UgQmlnSW50IGlmIHN1cHBvcnRlZD9cbiAgICAgICAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuICAgICAgICAvLyB4QmlnSW50ID0gQmlnSW50LmFzVWludE4oNjQsIHhCaWdJbnQpO1xuICAgICAgICAvLyByZXR1cm4gTnVtYmVyKHhCaWdJbnQpO1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVN0cmVhbSh4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBSZWFkYWJsZVN0cmVhbS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgIH1cbiAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyk7XG4gICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcbiAgICAgICAgICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCxcbiAgICAgICAgICogb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvciB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAgICAgICAqL1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQodGhpcywgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVsZWFzZUxvY2soKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCk7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuICAgIGNvbnN0IEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKiAoKSB7IH0pLnByb3RvdHlwZSk7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlYWRlciwgcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG4gICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgbmV4dFN0ZXBzLCBuZXh0U3RlcHMpIDpcbiAgICAgICAgICAgICAgICBuZXh0U3RlcHMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblN0ZXBzID0gKCkgPT4gdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgcmV0dXJuU3RlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBfbmV4dFN0ZXBzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICAgICAgICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2l0ZXJhdGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBieSBvbmUgbWljcm90YXNrLCBvdGhlcndpc2Ugd2Ugc3RvcCBwdWxsaW5nIHRvbyBlYXJseSB3aGljaCBicmVha3MgYSB0ZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIF9yZXR1cm5TdGVwcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICAgICAgICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2ZpbmlzaCBpdGVyYXRpbmcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JldHVybicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0sIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIGl0ZXJhdG9yLl9hc3luY0l0ZXJhdG9ySW1wbCA9IGltcGw7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvckltcGwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgICAgICAgICByZXR1cm4geC5fYXN5bmNJdGVyYXRvckltcGwgaW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0ZWFtQXN5bmNJdGVyYXRvcmApO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU4jUG9seWZpbGxcbiAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICAgIHJldHVybiB4ICE9PSB4O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0KGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIFdlIHVzZSBhcnJheXMgdG8gcmVwcmVzZW50IGxpc3RzLCBzbyB0aGlzIGlzIGJhc2ljYWxseSBhIG5vLW9wLlxuICAgICAgICAvLyBEbyBhIHNsaWNlIHRob3VnaCBqdXN0IGluIGNhc2Ugd2UgaGFwcGVuIHRvIGRlcGVuZCBvbiB0aGUgdW5pcXVlLW5lc3MuXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XG4gICAgfVxuICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbiAgICBmdW5jdGlvbiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pIHtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgfVxuICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZnVuY3Rpb24gSXNEZXRhY2hlZEJ1ZmZlcihPKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgLy8gQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBhdmFpbGFibGUgb24gSUUxMFxuICAgICAgICAvLyBodHRwczovL3d3dy5jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19hcnJheWJ1ZmZlcl9zbGljZVxuICAgICAgICBpZiAoYnVmZmVyLnNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuICAgICAgICBjb25zdCBzbGljZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMoc2xpY2UsIDAsIGJ1ZmZlciwgYmVnaW4sIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJc05vbk5lZ2F0aXZlTnVtYmVyKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXJJc05hTih2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDbG9uZUFzVWludDhBcnJheShPKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEFycmF5QnVmZmVyU2xpY2UoTy5idWZmZXIsIE8uYnl0ZU9mZnNldCwgTy5ieXRlT2Zmc2V0ICsgTy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGVxdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIC09IHBhaXIuc2l6ZTtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udGFpbmVyLCB2YWx1ZSwgc2l6ZSkge1xuICAgICAgICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHsgdmFsdWUsIHNpemUgfSk7XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgKz0gc2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnBlZWsoKTtcbiAgICAgICAgcmV0dXJuIHBhaXIudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc2V0UXVldWUoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWUgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHZpZXcoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uZChieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcbiAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHRoaXMuX3ZpZXcuYnVmZmVyKSkgO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uZFdpdGhOZXdWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuICAgICAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2FuIG9ubHkgcmVzcG9uZCB3aXRoIGFycmF5IGJ1ZmZlciB2aWV3cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSA7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIGJ5dGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgQllPQiBwdWxsIHJlcXVlc3QsIG9yIGBudWxsYCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgYnlvYlJlcXVlc3QoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgICAgICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZShjaHVuaykge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoY2h1bmssIDEsICdlbnF1ZXVlJyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKHRoaXMpO1xuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVUb3RhbFNpemUgLT0gZW50cnkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbih0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyh2aWV3KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgICAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoYnVmZmVyRSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhidWZmZXJFKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2l6ZTogMSxcbiAgICAgICAgICAgICAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBVaW50OEFycmF5LFxuICAgICAgICAgICAgICAgICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgYnlvYlJlcXVlc3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG4gICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICByZXR1cm4gbmV3IHB1bGxJbnRvRGVzY3JpcHRvci52aWV3Q29uc3RydWN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGJ5dGVzRmlsbGVkIC8gZWxlbWVudFNpemUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWUucHVzaCh7IGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9KTtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICBjb25zdCBjdXJyZW50QWxpZ25lZEJ5dGVzID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG4gICAgICAgIGNvbnN0IG1heEJ5dGVzVG9Db3B5ID0gTWF0aC5taW4oY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgICAgICAgY29uc3QgbWF4Qnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBtYXhCeXRlc1RvQ29weTtcbiAgICAgICAgY29uc3QgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSBtYXhCeXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuICAgICAgICBsZXQgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEJ5dGVzVG9Db3B5O1xuICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1heEFsaWduZWRCeXRlcyA+IGN1cnJlbnRBbGlnbmVkQnl0ZXMpIHtcbiAgICAgICAgICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhBbGlnbmVkQnl0ZXMgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZTtcbiAgICAgICAgd2hpbGUgKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gTWF0aC5taW4odG90YWxCeXRlc1RvQ29weVJlbWFpbmluZywgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBkZXN0U3RhcnQsIGhlYWRPZlF1ZXVlLmJ1ZmZlciwgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCwgYnl0ZXNUb0NvcHkpO1xuICAgICAgICAgICAgaWYgKGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggPT09IGJ5dGVzVG9Db3B5KSB7XG4gICAgICAgICAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQgKz0gYnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyAtPSBieXRlc1RvQ29weTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBzaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwICYmIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll92aWV3ID0gbnVsbDtcbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKGNvbnRyb2xsZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBsZXQgZWxlbWVudFNpemUgPSAxO1xuICAgICAgICBpZiAodmlldy5jb25zdHJ1Y3RvciAhPT0gRGF0YVZpZXcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTaXplID0gdmlldy5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdG9yID0gdmlldy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gICAgICAgIC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgIC8vICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgYnl0ZU9mZnNldDogdmlldy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgYnl0ZUxlbmd0aDogdmlldy5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgICAgICAgICBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogY3RvcixcbiAgICAgICAgICAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcbiAgICAgICAgICAgIC8vIC0gTm8gY2hhbmdlIGhhcHBlbnMgb24gZGVzaXJlZFNpemVcbiAgICAgICAgICAgIC8vIC0gVGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIG5vdGlmaWVkIG9mIHRoYXQgdGhlcmUncyBhdCBsZWFzdCAxIHBlbmRpbmcgcmVhZCh2aWV3KVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlWaWV3ID0gbmV3IGN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIDApO1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGVtcHR5Vmlldyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyU2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IEFycmF5QnVmZmVyU2xpY2UocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZW5kIC0gcmVtYWluZGVyU2l6ZSwgZW5kKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHJlbWFpbmRlciwgMCwgcmVtYWluZGVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIGZpcnN0RGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gICAgICAgIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBjaHVuay5idWZmZXI7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBjaHVuay5ieXRlT2Zmc2V0O1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSA7XG4gICAgICAgICAgICBmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKSB7XG4gICAgICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCB0cmFuc2ZlcnJlZFZpZXcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogSWRlYWxseSBpbiB0aGlzIGJyYW5jaCBkZXRhY2hpbmcgc2hvdWxkIGhhcHBlbiBvbmx5IGlmIHRoZSBidWZmZXIgaXMgbm90IGNvbnN1bWVkIGZ1bGx5LlxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCAmJiBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLCBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KGJ5b2JSZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbikge1xuICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoY29udHJvbGxlciwgdmlldykge1xuICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2aWV3XFwncyBsZW5ndGggbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICE9PSB2aWV3LmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGJ1ZmZlciBvZiB2aWV3IGhhcyBkaWZmZXJlbnQgY2FwYWNpdHkgdGhhbiBieW9iUmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyB2aWV3LmJ5dGVMZW5ndGggPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3Qnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIHZpZXdCeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9hdXRvQWxsb2NhdGVDaHVua1NpemUgPSBhdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ0J5dGVTb3VyY2UsIGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwdWxsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgICAgICAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QuXG4gICAgZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKTtcbiAgICB9XG5cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgICB9XG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBCWU9CIHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInKTtcbiAgICAgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnc291cmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG4gICAgICAgICAqIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIHJlYWRzIGJ5dGVzIGludG8gdmlldywgYW5kIHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAgICAgICAqL1xuICAgICAgICByZWFkKHZpZXcpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYHZpZXcncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHRoaXMsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRJbnRvUmVxdWVzdHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cbiAgICBmdW5jdGlvbiBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcmApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCBkZWZhdWx0SFdNKSB7XG4gICAgICAgIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0SFdNO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXJJc05hTihoaWdoV2F0ZXJNYXJrKSB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgaGlnaFdhdGVyTWFyaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoV2F0ZXJNYXJrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSkge1xuICAgICAgICBjb25zdCB7IHNpemUgfSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3koaW5pdCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG4gICAgICAgICAgICBzaXplOiBzaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShzaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY2h1bmsgPT4gY29udmVydFVucmVzdHJpY3RlZERvdWJsZShmbihjaHVuaykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2luayhvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgYWJvcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuYWJvcnQ7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNsb3NlO1xuICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuICAgICAgICBjb25zdCB3cml0ZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC53cml0ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBhYm9ydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhYm9ydCcgdGhhdGApLFxuICAgICAgICAgICAgY2xvc2U6IGNsb3NlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0YCksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0ZScgdGhhdGApLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKCkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRXcml0YWJsZVN0cmVhbSh4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBXcml0YWJsZVN0cmVhbS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWJvcnRTaWduYWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBBYm9ydFNpZ25hbC5wcm90b3R5cGUuYWJvcnRlZCB0aHJvd3MgaWYgaXRzIGJyYW5kIGNoZWNrIGZhaWxzXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBBYm9ydENvbnRyb2xsZXIsIGlmIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgd3JpdGFibGUgc3RyZWFtIHJlcHJlc2VudHMgYSBkZXN0aW5hdGlvbiBmb3IgZGF0YSwgaW50byB3aGljaCB5b3UgY2FuIHdyaXRlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtIHtcbiAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NpbmsgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xuICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTaW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU2luayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG4gICAgICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsodGhpcywgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB3cml0YWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEgd3JpdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGxvY2tlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignbG9ja2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWJvcnRzIHRoZSBzdHJlYW0sIHNpZ25hbGluZyB0aGF0IHRoZSBwcm9kdWNlciBjYW4gbm8gbG9uZ2VyIHN1Y2Nlc3NmdWxseSB3cml0ZSB0byB0aGUgc3RyZWFtIGFuZCBpdCBpcyB0byBiZVxuICAgICAgICAgKiBpbW1lZGlhdGVseSBtb3ZlZCB0byBhbiBlcnJvcmVkIHN0YXRlLCB3aXRoIGFueSBxdWV1ZWQtdXAgd3JpdGVzIGRpc2NhcmRlZC4gVGhpcyB3aWxsIGFsc28gZXhlY3V0ZSBhbnkgYWJvcnRcbiAgICAgICAgICogbWVjaGFuaXNtIG9mIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCBpZiB0aGUgc3RyZWFtIHNodXRzIGRvd24gc3VjY2Vzc2Z1bGx5LCBvciByZWplY3QgaWYgdGhlIHVuZGVybHlpbmcgc2luayBzaWduYWxlZFxuICAgICAgICAgKiB0aGF0IHRoZXJlIHdhcyBhbiBlcnJvciBkb2luZyBzby4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWxcbiAgICAgICAgICogdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Fib3J0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgc3RyZWFtLiBUaGUgdW5kZXJseWluZyBzaW5rIHdpbGwgZmluaXNoIHByb2Nlc3NpbmcgYW55IHByZXZpb3VzbHktd3JpdHRlbiBjaHVua3MsIGJlZm9yZSBpbnZva2luZyBpdHNcbiAgICAgICAgICogY2xvc2UgYmVoYXZpb3IuIER1cmluZyB0aGlzIHRpbWUgYW55IGZ1cnRoZXIgYXR0ZW1wdHMgdG8gd3JpdGUgd2lsbCBmYWlsICh3aXRob3V0IGVycm9yaW5nIHRoZSBzdHJlYW0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIGlmIGFsbCByZW1haW5pbmcgY2h1bmtzIGFyZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiBhbmQgdGhlIHN0cmVhbVxuICAgICAgICAgKiBzdWNjZXNzZnVsbHkgY2xvc2VzLCBvciByZWplY3RzIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGR1cmluZyB0aGlzIHByb2Nlc3MuIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aFxuICAgICAgICAgKiBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdjbG9zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cbiAgICAgICAgICogaXMgbG9ja2VkLCBubyBvdGhlciB3cml0ZXIgY2FuIGJlIGFjcXVpcmVkIHVudGlsIHRoaXMgb25lIGlzIHJlbGVhc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxuICAgICAgICAgKiB3aXRob3V0IGludGVycnVwdGlvbiBvciBpbnRlcmxlYXZpbmcuIEJ5IGdldHRpbmcgYSB3cml0ZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiB3cml0ZSBhdFxuICAgICAgICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V3JpdGVyKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdnZXRXcml0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZ2V0V3JpdGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XG4gICAgfVxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgICAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcbiAgICAgICAgLy8gVGhlIGVycm9yIHRoYXQgd2lsbCBiZSByZXBvcnRlZCBieSBuZXcgbWV0aG9kIGNhbGxzIG9uY2UgdGhlIHN0YXRlIGJlY29tZXMgZXJyb3JlZC4gT25seSBzZXQgd2hlbiBbW3N0YXRlXV0gaXNcbiAgICAgICAgLy8gJ2Vycm9yaW5nJyBvciAnZXJyb3JlZCcuIE1heSBiZSBzZXQgdG8gYW4gdW5kZWZpbmVkIHZhbHVlLlxuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcbiAgICAgICAgLy8gdmFyaWFibGUgdG8gdmFsaWRhdGUgdGhlIGNhbGxlci5cbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcbiAgICAgICAgLy8gcHJvZHVjZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgcXVldWVkIHdyaXRlcyB0byBmaW5pc2guXG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAvLyBXcml0ZSByZXF1ZXN0cyBhcmUgcmVtb3ZlZCBmcm9tIF93cml0ZVJlcXVlc3RzIHdoZW4gd3JpdGUoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50c1xuICAgICAgICAvLyB0aGVtIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgd3JpdGUoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG4gICAgICAgIC8vIGhhcyBiZWVuIGRldGFjaGVkLlxuICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcbiAgICAgICAgLy8gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSBjbG9zZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuYWJvcnQoKS4gVGhpcyBtYXkgYWxzbyBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgZGV0YWNoZWQuXG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhlIGJhY2twcmVzc3VyZSBzaWduYWwgc2V0IGJ5IHRoZSBjb250cm9sbGVyLlxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAoX2EgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuICAgICAgICAvLyBidXQgaXQgZG9lc24ndCBrbm93IHRoYXQgc2lnbmFsaW5nIGFib3J0IHJ1bnMgYXV0aG9yIGNvZGUgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQgdGhlIHN0YXRlLlxuICAgICAgICAvLyBXaWRlbiB0aGUgdHlwZSBhZ2FpbiBieSBjYXN0aW5nIHRvIFdyaXRhYmxlU3RyZWFtU3RhdGUuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FzQWxyZWFkeUVycm9yaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlYXNvbiB3aWxsIG5vdCBiZSB1c2VkLCBzbyBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICAgICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfcHJvbWlzZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdCxcbiAgICAgICAgICAgICAgICBfcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSBjbG9zZVJlcXVlc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBXcml0YWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmluZyc7XG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSAmJiBjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCh3cml0ZVJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcbiAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbQWJvcnRTdGVwc10oYWJvcnRSZXF1ZXN0Ll9yZWFzb24pO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtLCBlcnJvcikge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlcnJvciB3YXMgdG9vIGxhdGUgdG8gZG8gYW55dGhpbmcsIHNvIGl0IGlzIGlnbm9yZWQuXG4gICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gTmV2ZXIgZXhlY3V0ZSBzaW5rIGFib3J0KCkgYWZ0ZXIgc2luayBjbG9zZSgpLlxuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBUT0RPKHJpY2VhKTogRml4IGFscGhhYmV0aWNhbCBvcmRlci5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XG4gICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gc3RyZWFtLl93cml0ZVJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSkge1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmIChiYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCB3cml0ZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyk7XG4gICAgICAgICAgICBhc3NlcnRXcml0YWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG4gICAgICAgICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgICAgICAgKiBBIHByb2R1Y2VyIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGFtb3VudCBvZiBkYXRhIHRvIHdyaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB3aWxsIGJlIGBudWxsYCBpZiB0aGUgc3RyZWFtIGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byAoZHVlIHRvIGVpdGhlciBiZWluZyBlcnJvcmVkLCBvciBoYXZpbmcgYW4gYWJvcnRcbiAgICAgICAgICogcXVldWVkIHVwKS4gSXQgd2lsbCByZXR1cm4gemVybyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gQW5kIHRoZSBnZXR0ZXIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW52b2tlZCB3aGVuXG4gICAgICAgICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUgdHJhbnNpdGlvbnNcbiAgICAgICAgICogZnJvbSBub24tcG9zaXRpdmUgdG8gcG9zaXRpdmUsIHNpZ25hbGluZyB0aGF0IGl0IGlzIG5vIGxvbmdlciBhcHBseWluZyBiYWNrcHJlc3N1cmUuIE9uY2UgdGhlIGRlc2lyZWQgc2l6ZSBkaXBzXG4gICAgICAgICAqIGJhY2sgdG8gemVybyBvciBiZWxvdywgdGhlIGdldHRlciB3aWxsIHJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgc3RheXMgcGVuZGluZyB1bnRpbCB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgc3RyZWFtIGJlY29tZXMgZXJyb3JlZCBvciBhYm9ydGVkLCBvciB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlY29tZVxuICAgICAgICAgKiByZWplY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZHknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uYWJvcnQgfCBzdHJlYW0uYWJvcnQocmVhc29uKX0uXG4gICAgICAgICAqL1xuICAgICAgICBhYm9ydChyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5jbG9zZSB8IHN0cmVhbS5jbG9zZSgpfS5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxlYXNlcyB0aGUgd3JpdGVy4oCZcyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheSBmcm9tXG4gICAgICAgICAqIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBsb2NrIGNhbiBzdGlsbCBiZSByZWxlYXNlZCBldmVuIGlmIHNvbWUgb25nb2luZyB3cml0ZXMgaGF2ZSBub3QgeWV0IGZpbmlzaGVkIChpLmUuIGV2ZW4gaWYgdGhlXG4gICAgICAgICAqIHByb21pc2VzIHJldHVybmVkIGZyb20gcHJldmlvdXMgY2FsbHMgdG8ge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci53cml0ZSB8IHdyaXRlKCl9IGhhdmUgbm90IHlldCBzZXR0bGVkKS5cbiAgICAgICAgICogSXTigJlzIG5vdCBuZWNlc3NhcnkgdG8gaG9sZCB0aGUgbG9jayBvbiB0aGUgd3JpdGVyIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHdyaXRlOyB0aGUgbG9jayBpbnN0ZWFkIHNpbXBseSBwcmV2ZW50c1xuICAgICAgICAgKiBvdGhlciBwcm9kdWNlcnMgZnJvbSB3cml0aW5nIGluIGFuIGludGVybGVhdmVkIG1hbm5lci5cbiAgICAgICAgICovXG4gICAgICAgIHJlbGVhc2VMb2NrKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGUoY2h1bmsgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHdyaXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWFkeTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG4gICAgICAgIC8vIFRoZSBzdGF0ZSB0cmFuc2l0aW9ucyB0byBcImVycm9yZWRcIiBiZWZvcmUgdGhlIHNpbmsgYWJvcnQoKSBtZXRob2QgcnVucywgYnV0IHRoZSB3cml0ZXIuY2xvc2VkIHByb21pc2UgaXMgbm90XG4gICAgICAgIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcbiAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUod3JpdGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG8nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2VTZW50aW5lbCA9IHt9O1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWFzb24gd2hpY2ggd2FzIHBhc3NlZCB0byBgV3JpdGFibGVTdHJlYW0uYWJvcnQocmVhc29uKWAgd2hlbiB0aGUgc3RyZWFtIHdhcyBhYm9ydGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiAgVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmljYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvcHVsbC8xMTc3LlxuICAgICAgICAgKiAgVXNlIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnNpZ25hbH0ncyBgcmVhc29uYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGFib3J0UmVhc29uKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnRSZWFzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYEFib3J0U2lnbmFsYCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFib3J0IHRoZSBwZW5kaW5nIHdyaXRlIG9yIGNsb3NlIG9wZXJhdGlvbiB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdzaWduYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBidW5kbGUgYW5kIHNoaXAgYW4gYEFib3J0Q29udHJvbGxlcmAgcG9seWZpbGwgdG9nZXRoZXIgd2l0aCBvdXIgcG9seWZpbGwsXG4gICAgICAgICAgICAgICAgLy8gc28gaW5zdGVhZCB3ZSBvbmx5IGltcGxlbWVudCBzdXBwb3J0IGZvciBgc2lnbmFsYCBpZiB3ZSBmaW5kIGEgZ2xvYmFsIGBBYm9ydENvbnRyb2xsZXJgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHdyaXRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHJhcmVseSB1c2VkLCBzaW5jZSB1c3VhbGx5IGl0IHN1ZmZpY2VzIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZnJvbSBvbmUgb2YgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICogc2luaydzIG1ldGhvZHMuIEhvd2V2ZXIsIGl0IGNhbiBiZSB1c2VmdWwgZm9yIHN1ZGRlbmx5IHNodXR0aW5nIGRvd24gYSBzdHJlYW0gaW4gcmVzcG9uc2UgdG8gYW4gZXZlbnQgb3V0c2lkZSB0aGVcbiAgICAgICAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzdHJlYW0gaXMgY2xvc2VkLCBlcnJvcmVkIG9yIHdpbGwgYmUgc29vbi4gVGhlIHNpbmsgY2FuJ3QgZG8gYW55dGhpbmcgdXNlZnVsIGlmIGl0IGdldHMgYW4gZXJyb3IgaGVyZSwgc29cbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW0Fib3J0U3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW0Vycm9yU3RlcHNdKCkge1xuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBhYm9ydFJlYXNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRSZWFzb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuICAgICAgICB1cG9uUHJvbWlzZShzdGFydFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIHIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHN0cmVhbSwgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB3cml0ZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay53cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZUFsZ29yaXRobSA9IGNodW5rID0+IHVuZGVybHlpbmdTaW5rLndyaXRlKGNodW5rLCBjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU2luay5hYm9ydChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjbG9zZVNlbnRpbmVsLCAwKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IFBlZWtRdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGNsb3NlU2VudGluZWwpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlcnJvcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICAgICAgICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICB1cG9uUHJvbWlzZShzaW5rQ2xvc2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICAgICAgICBjb25zdCBzaW5rV3JpdGVQcm9taXNlID0gY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0oY2h1bmspO1xuICAgICAgICB1cG9uUHJvbWlzZShzaW5rV3JpdGVQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXInKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3Jlc29sdmVkJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHdyaXRlcikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9yZWFkeVByb21pc2UpO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3JlamVjdGVkJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAnZnVsZmlsbGVkJztcbiAgICB9XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuICAgIGNvbnN0IE5hdGl2ZURPTUV4Y2VwdGlvbiA9IHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnID8gRE9NRXhjZXB0aW9uIDogdW5kZWZpbmVkO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cbiAgICBmdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3IpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGN0b3IgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgY3RvcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICAgICAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnRXJyb3InO1xuICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBjdG9yO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG4gICAgY29uc3QgRE9NRXhjZXB0aW9uJDEgPSBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1QaXBlVG8oc291cmNlLCBkZXN0LCBwcmV2ZW50Q2xvc2UsIHByZXZlbnRBYm9ydCwgcHJldmVudENhbmNlbCwgc2lnbmFsKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc291cmNlKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihkZXN0KTtcbiAgICAgICAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuICAgICAgICBsZXQgc2h1dHRpbmdEb3duID0gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzcGVjJ3MgcmVxdWlyZW1lbnQgdGhhdCB3ZSB3YWl0IGZvciBvbmdvaW5nIHdyaXRlcyBkdXJpbmcgc2h1dGRvd24uXG4gICAgICAgIGxldCBjdXJyZW50V3JpdGUgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobTtcbiAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBET01FeGNlcHRpb24kMSgnQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbigpKSksIHRydWUsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzaW5nIHJlYWRlciBhbmQgd3JpdGVyLCByZWFkIGFsbCBjaHVua3MgZnJvbSB0aGlzIGFuZCB3cml0ZSB0aGVtIHRvIGRlc3RcbiAgICAgICAgICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcbiAgICAgICAgICAgIC8vIC0gU2h1dGRvd24gbXVzdCBzdG9wIGFsbCBhY3Rpdml0eVxuICAgICAgICAgICAgZnVuY3Rpb24gcGlwZUxvb3AoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVMb29wLCByZWplY3RMb29wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHBpcGVTdGVwKCksIG5leHQsIHJlamVjdExvb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGlwZVN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB1bmRlZmluZWQsIG5vb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVhZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlamVjdFJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgICAgICAgICBpc09yQmVjb21lc0Vycm9yZWQoZGVzdCwgd3JpdGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNDbG9zZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpIHx8IGRlc3QuX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZGVzdENsb3NlZCksIHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgZGVzdENsb3NlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwaXBlTG9vcCgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIHtcbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGF0IHRvby5cbiAgICAgICAgICAgICAgICBjb25zdCBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihjdXJyZW50V3JpdGUsICgpID0+IG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cG9uUmVqZWN0aW9uKHByb21pc2UsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvVGhlUmVzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwb25Qcm9taXNlKGFjdGlvbigpLCAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLCBuZXdFcnJvciA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNodXRkb3duKGlzRXJyb3IsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksICgpID0+IGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICAgICAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cbiAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdjbG9zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWUoY2h1bmsgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2VucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW0NhbmNlbFN0ZXBzXShyZWFzb24pIHtcbiAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBEZXF1ZXVlVmFsdWUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVTdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgICAgICAgICAgICAgIHRocm93IGNodW5rU2l6ZUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIGxldCBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU291cmNlLmNhbmNlbChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1UZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMikge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFkQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFzb24xO1xuICAgICAgICBsZXQgcmVhc29uMjtcbiAgICAgICAgbGV0IGJyYW5jaDE7XG4gICAgICAgIGxldCBicmFuY2gyO1xuICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgY2xvbmluZyBjb2RlIHJpZ2h0IG5vdyBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYWRkIG9uZSB0aGVuIHdlJ2xsIG5lZWQgYW4gaW1wbGVtZW50YXRpb24gZm9yIHNlcmlhbGl6YWJsZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNodW5rMiA9IFN0cnVjdHVyZWREZXNlcmlhbGl6ZShTdHJ1Y3R1cmVkU2VyaWFsaXplKGNodW5rMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XG4gICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuICAgICAgICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHIpID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbVRlZShzdHJlYW0pIHtcbiAgICAgICAgbGV0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFzb24xO1xuICAgICAgICBsZXQgcmVhc29uMjtcbiAgICAgICAgbGV0IGJyYW5jaDE7XG4gICAgICAgIGxldCBicmFuY2gyO1xuICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZFJlYWRlckVycm9yKHRoaXNSZWFkZXIpIHtcbiAgICAgICAgICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNSZWFkZXIgIT09IHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKSB7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSAmJiAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsyID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoY2xvbmVFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHB1bGxXaXRoQllPQlJlYWRlcih2aWV3LCBmb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBieW9iQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDIgOiBicmFuY2gxO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG4gICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRDaHVuayA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkICYmIG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG4gICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShzb3VyY2UsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNhbmNlbDtcbiAgICAgICAgY29uc3QgcHVsbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5wdWxsO1xuICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYXV0b0FsbG9jYXRlQ2h1bmtTaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgKSxcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjYW5jZWwnIHRoYXRgKSxcbiAgICAgICAgICAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhwdWxsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHlwZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHlwZSA9IGAke3R5cGV9YDtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7dHlwZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgY29udGV4dCkge1xuICAgICAgICBtb2RlID0gYCR7bW9kZX1gO1xuICAgICAgICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcbiAgICAgICAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG4gICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcbiAgICAgICAgY29uc3QgcHJldmVudENsb3NlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDbG9zZTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpZ25hbCcgdGhhdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmV2ZW50QWJvcnQ6IEJvb2xlYW4ocHJldmVudEFib3J0KSxcbiAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG4gICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IEJvb2xlYW4ocHJldmVudENsb3NlKSxcbiAgICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHBhaXIsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShwYWlyLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcmVhZGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIucmVhZGFibGU7XG4gICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtcbiAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIud3JpdGFibGU7XG4gICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQod3JpdGFibGUsICd3cml0YWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICAgICAgICBhc3NlcnRXcml0YWJsZVN0cmVhbSh3cml0YWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGFibGUnIHRoYXRgKTtcbiAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZWFkYWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIHNvdXJjZSBvZiBkYXRhLCBmcm9tIHdoaWNoIHlvdSBjYW4gcmVhZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2UgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xuICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTb3VyY2UgPSBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAwKTtcbiAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcbiAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHwgcmVhZGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBsb2NrZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2xvY2tlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIGEgbG9zcyBvZiBpbnRlcmVzdCBpbiB0aGUgc3RyZWFtIGJ5IGEgY29uc3VtZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdXBwbGllZCBgcmVhc29uYCBhcmd1bWVudCB3aWxsIGJlIGdpdmVuIHRvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSdzIHtAbGluayBVbmRlcmx5aW5nU291cmNlLmNhbmNlbCB8IGNhbmNlbCgpfVxuICAgICAgICAgKiBtZXRob2QsIHdoaWNoIG1pZ2h0IG9yIG1pZ2h0IG5vdCB1c2UgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVhZGVyKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZ2V0UmVhZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBwaXBlVGhyb3VnaChyYXdUcmFuc2Zvcm0sIHJhd09wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVGhyb3VnaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsICdwaXBlVGhyb3VnaCcpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHJhd1RyYW5zZm9ybSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5yZWFkYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBwaXBlVG8oZGVzdGluYXRpb24sIHJhd09wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVG8nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGBQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG4gICAgICAgICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAgICAgICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuICAgICAgICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcbiAgICAgICAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGVlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd0ZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgndmFsdWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBwaXBlVGhyb3VnaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHBpcGVUbzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciwge1xuICAgICAgICAgICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAncmVhZGFibGUnO1xuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX3JlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHModW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyaylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiA9IChjaHVuaykgPT4ge1xuICAgICAgICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnc2l6ZScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gZWFjaCBjaHVuay5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IHtcbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XG4gICAgICAgICAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgcmV0dXJuaW5nIHRoZSB2YWx1ZSBvZiBpdHMgYGJ5dGVMZW5ndGhgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKCdzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZUxlbmd0aFNpemVGdW5jdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5cbiAgICBmdW5jdGlvbiBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xuICAgIH1cblxuICAgIC8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbiAgICBjb25zdCBjb3VudFNpemVGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY291bnRTaXplRnVuY3Rpb24sICduYW1lJywge1xuICAgICAgICAgICAgdmFsdWU6ICdzaXplJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSBpbiBvbGRlciBicm93c2Vycywgc28gaWdub3JlIGlmIHRoaXMgdGhyb3dzLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBjaHVua3MuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgQ291bnRRdWV1aW5nU3RyYXRlZ3kge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdDb3VudFF1ZXVpbmdTdHJhdGVneScpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IGFsd2F5cyByZXR1cm5pbmcgMS5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBDb3VudFF1ZXVpbmdTdHJhdGVneS5cbiAgICBmdW5jdGlvbiBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ291bnRRdWV1aW5nU3RyYXRlZ3koeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lcihvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgZmx1c2ggPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuZmx1c2g7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5yZWFkYWJsZVR5cGU7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCB3cml0YWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGFibGVUeXBlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmx1c2g6IGZsdXNoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG4gICAgICAgICAgICByZWFkYWJsZVR5cGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2sodHJhbnNmb3JtLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksXG4gICAgICAgICAgICB3cml0YWJsZVR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbiAgICB9XG5cbiAgICAvLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBzdHJlYW0gY29uc2lzdHMgb2YgYSBwYWlyIG9mIHN0cmVhbXM6IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSxcbiAgICAgKiBrbm93biBhcyBpdHMgd3JpdGFibGUgc2lkZSwgYW5kIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSwga25vd24gYXMgaXRzIHJlYWRhYmxlIHNpZGUuXG4gICAgICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcbiAgICAgKiBtYWRlIGF2YWlsYWJsZSBmb3IgcmVhZGluZyBmcm9tIHRoZSByZWFkYWJsZSBzaWRlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFRyYW5zZm9ybVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1RyYW5zZm9ybWVyID0ge30sIHJhd1dyaXRhYmxlU3RyYXRlZ3kgPSB7fSwgcmF3UmVhZGFibGVTdHJhdGVneSA9IHt9KSB7XG4gICAgICAgICAgICBpZiAocmF3VHJhbnNmb3JtZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1dyaXRhYmxlU3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdSZWFkYWJsZVN0cmF0ZWd5LCAnVGhpcmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgcmVhZGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLndyaXRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsocmVhZGFibGVTdHJhdGVneSwgMCk7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShyZWFkYWJsZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0od3JpdGFibGVTdHJhdGVneSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gICAgICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHRoaXMsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVhZGFibGUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgd3JpdGFibGUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgIHJlYWRhYmxlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVBbGdvcml0aG0oY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCByZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3JlYWRhYmxlID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pO1xuICAgICAgICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW07XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiBib3RoIHNpZGVzIGFyZSBhbHJlYWR5IGVycm9yZWQuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgLy8gUHJldGVuZCB0aGF0IHB1bGwoKSB3YXMgY2FsbGVkIHRvIHBlcm1pdCBhbnkgcGVuZGluZyB3cml0ZSgpIGNhbGxzIHRvIGNvbXBsZXRlLiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoKVxuICAgICAgICAgICAgLy8gY2Fubm90IGJlIGNhbGxlZCBmcm9tIGVucXVldWUoKSBvciBwdWxsKCkgb25jZSB0aGUgUmVhZGFibGVTdHJlYW0gaXMgZXJyb3JlZCwgc28gdGhpcyB3aWxsIHdpbGwgYmUgdGhlIGZpbmFsIHRpbWVcbiAgICAgICAgICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSkge1xuICAgICAgICAvLyBQYXNzZXMgYWxzbyB3aGVuIGNhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuICAgIH1cbiAgICAvLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclxuICAgIC8qKlxuICAgICAqIEFsbG93cyBjb250cm9sIG9mIHRoZSB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGFuZCB7QGxpbmsgV3JpdGFibGVTdHJlYW19IG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBUcmFuc2Zvcm1TdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSByZWFkYWJsZSBzaWRl4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyBib3RoIHRoZSByZWFkYWJsZSBzaWRlIGFuZCB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZVxuICAgICAgICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgcmVhZGFibGUgc2lkZSBhbmQgZXJyb3JzIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXG4gICAgICAgICAqIHRyYW5zZm9ybWVyIG9ubHkgbmVlZHMgdG8gY29uc3VtZSBhIHBvcnRpb24gb2YgdGhlIGNodW5rcyB3cml0dGVuIHRvIHRoZSB3cml0YWJsZSBzaWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGVybWluYXRlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd0ZXJtaW5hdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB0ZXJtaW5hdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybSBTdHJlYW0gRGVmYXVsdCBDb250cm9sbGVyIEFic3RyYWN0IE9wZXJhdGlvbnNcbiAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHRyYW5zZm9ybUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcihzdHJlYW0sIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZXIudHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyLmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gdHJhbnNmb3JtZXIuZmx1c2goY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB0aHJvdHRsZSB0cmFuc2Zvcm0gaW52b2NhdGlvbnMgYmFzZWQgb24gdGhlIGJhY2twcmVzc3VyZSBvZiB0aGUgUmVhZGFibGVTdHJlYW0sIGJ1dCB3ZSBzdGlsbFxuICAgICAgICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gcmVhZGFibGVTdHJhdGVneS5zaXplKCkgdGhyb3dzLlxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuICAgICAgICAgICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0cmFuc2Zvcm1Qcm9taXNlLCB1bmRlZmluZWQsIHIgPT4ge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgcik7XG4gICAgICAgICAgICB0aHJvdyByO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoJ1RyYW5zZm9ybVN0cmVhbSB0ZXJtaW5hdGVkJyk7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rIEFsZ29yaXRobXNcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHdyaXRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICAvLyBhYm9ydCgpIGlzIG5vdCBjYWxsZWQgc3luY2hyb25vdXNseSwgc28gaXQgaXMgcG9zc2libGUgZm9yIGFib3J0KCkgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBhbHJlYWR5XG4gICAgICAgIC8vIGVycm9yZWQuXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pIHtcbiAgICAgICAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAvLyBSZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkIG9uIHN1Y2Nlc3MuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChmbHVzaFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHIpO1xuICAgICAgICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZSBBbGdvcml0aG1zXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKSB7XG4gICAgICAgIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICAvLyBQcmV2ZW50IHRoZSBuZXh0IHB1bGwoKSBjYWxsIHVudGlsIHRoZXJlIGlzIGJhY2twcmVzc3VyZS5cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbS5cbiAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtYCk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5CeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5ID0gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbiAgICBleHBvcnRzLkNvdW50UXVldWluZ1N0cmF0ZWd5ID0gQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtID0gUmVhZGFibGVTdHJlYW07XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xuICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICBleHBvcnRzLldyaXRhYmxlU3RyZWFtID0gV3JpdGFibGVTdHJlYW07XG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICBleHBvcnRzLldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb255ZmlsbC5lczIwMTguanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsIldlYlN0cmVhbXNQb2x5ZmlsbCIsIlN5bWJvbFBvbHlmaWxsIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJkZXNjcmlwdGlvbiIsIm5vb3AiLCJ1bmRlZmluZWQiLCJnZXRHbG9iYWxzIiwid2luZG93IiwiZ2xvYmFscyIsInR5cGVJc09iamVjdCIsIngiLCJyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24iLCJvcmlnaW5hbFByb21pc2UiLCJQcm9taXNlIiwib3JpZ2luYWxQcm9taXNlVGhlbiIsInByb3RvdHlwZSIsInRoZW4iLCJvcmlnaW5hbFByb21pc2VSZXNvbHZlIiwicmVzb2x2ZSIsImJpbmQiLCJvcmlnaW5hbFByb21pc2VSZWplY3QiLCJyZWplY3QiLCJuZXdQcm9taXNlIiwiZXhlY3V0b3IiLCJwcm9taXNlUmVzb2x2ZWRXaXRoIiwidmFsdWUiLCJwcm9taXNlUmVqZWN0ZWRXaXRoIiwicmVhc29uIiwiUGVyZm9ybVByb21pc2VUaGVuIiwicHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImNhbGwiLCJ1cG9uUHJvbWlzZSIsInVwb25GdWxmaWxsbWVudCIsInVwb25SZWplY3Rpb24iLCJ0cmFuc2Zvcm1Qcm9taXNlV2l0aCIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlIiwicXVldWVNaWNyb3Rhc2siLCJnbG9iYWxRdWV1ZU1pY3JvdGFzayIsInJlc29sdmVkUHJvbWlzZSIsImZuIiwicmVmbGVjdENhbGwiLCJGIiwiViIsImFyZ3MiLCJUeXBlRXJyb3IiLCJGdW5jdGlvbiIsImFwcGx5IiwicHJvbWlzZUNhbGwiLCJRVUVVRV9NQVhfQVJSQVlfU0laRSIsIlNpbXBsZVF1ZXVlIiwiY29uc3RydWN0b3IiLCJfY3Vyc29yIiwiX3NpemUiLCJfZnJvbnQiLCJfZWxlbWVudHMiLCJfbmV4dCIsIl9iYWNrIiwibGVuZ3RoIiwicHVzaCIsImVsZW1lbnQiLCJvbGRCYWNrIiwibmV3QmFjayIsInNoaWZ0Iiwib2xkRnJvbnQiLCJuZXdGcm9udCIsIm9sZEN1cnNvciIsIm5ld0N1cnNvciIsImVsZW1lbnRzIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwiaSIsIm5vZGUiLCJwZWVrIiwiZnJvbnQiLCJjdXJzb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplIiwicmVhZGVyIiwic3RyZWFtIiwiX293bmVyUmVhZGFibGVTdHJlYW0iLCJfcmVhZGVyIiwiX3N0YXRlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJfc3RvcmVkRXJyb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwiLCJSZWFkYWJsZVN0cmVhbUNhbmNlbCIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwicmVhZGVyTG9ja0V4Y2VwdGlvbiIsIm5hbWUiLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJBYm9ydFN0ZXBzIiwiRXJyb3JTdGVwcyIsIkNhbmNlbFN0ZXBzIiwiUHVsbFN0ZXBzIiwiTnVtYmVySXNGaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGhUcnVuYyIsIk1hdGgiLCJ0cnVuYyIsInYiLCJjZWlsIiwiZmxvb3IiLCJpc0RpY3Rpb25hcnkiLCJhc3NlcnREaWN0aW9uYXJ5Iiwib2JqIiwiY29udGV4dCIsImFzc2VydEZ1bmN0aW9uIiwiaXNPYmplY3QiLCJhc3NlcnRPYmplY3QiLCJhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IiwicG9zaXRpb24iLCJhc3NlcnRSZXF1aXJlZEZpZWxkIiwiZmllbGQiLCJjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIiwiY2Vuc29yTmVnYXRpdmVaZXJvIiwiaW50ZWdlclBhcnQiLCJjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhc3NlcnRSZWFkYWJsZVN0cmVhbSIsIklzUmVhZGFibGVTdHJlYW0iLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdCIsInJlYWRSZXF1ZXN0IiwiX3JlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0IiwiY2h1bmsiLCJkb25lIiwiX2Nsb3NlU3RlcHMiLCJfY2h1bmtTdGVwcyIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzIiwiUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJJc1JlYWRhYmxlU3RyZWFtTG9ja2VkIiwiY2xvc2VkIiwiZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjYW5jZWwiLCJyZWFkIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwiX2Vycm9yU3RlcHMiLCJlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCIsInJlbGVhc2VMb2NrIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiaGFzT3duUHJvcGVydHkiLCJfZGlzdHVyYmVkIiwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciIsIkFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwiLCJwcmV2ZW50Q2FuY2VsIiwiX29uZ29pbmdQcm9taXNlIiwiX2lzRmluaXNoZWQiLCJfcHJldmVudENhbmNlbCIsIm5leHQiLCJuZXh0U3RlcHMiLCJfbmV4dFN0ZXBzIiwicmV0dXJuIiwicmV0dXJuU3RlcHMiLCJfcmV0dXJuU3RlcHMiLCJyZXN1bHQiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsInN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uIiwiX2FzeW5jSXRlcmF0b3JJbXBsIiwic2V0UHJvdG90eXBlT2YiLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yIiwiaW1wbCIsImNyZWF0ZSIsIl9hIiwiTnVtYmVySXNOYU4iLCJpc05hTiIsIkNyZWF0ZUFycmF5RnJvbUxpc3QiLCJzbGljZSIsIkNvcHlEYXRhQmxvY2tCeXRlcyIsImRlc3QiLCJkZXN0T2Zmc2V0Iiwic3JjIiwic3JjT2Zmc2V0IiwibiIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJUcmFuc2ZlckFycmF5QnVmZmVyIiwiTyIsIklzRGV0YWNoZWRCdWZmZXIiLCJBcnJheUJ1ZmZlclNsaWNlIiwiYnVmZmVyIiwiYmVnaW4iLCJlbmQiLCJBcnJheUJ1ZmZlciIsIklzTm9uTmVnYXRpdmVOdW1iZXIiLCJDbG9uZUFzVWludDhBcnJheSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiRGVxdWV1ZVZhbHVlIiwiY29udGFpbmVyIiwicGFpciIsIl9xdWV1ZSIsIl9xdWV1ZVRvdGFsU2l6ZSIsInNpemUiLCJFbnF1ZXVlVmFsdWVXaXRoU2l6ZSIsIkluZmluaXR5IiwiUmFuZ2VFcnJvciIsIlBlZWtRdWV1ZVZhbHVlIiwiUmVzZXRRdWV1ZSIsIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJ2aWV3IiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uIiwiX3ZpZXciLCJyZXNwb25kIiwiYnl0ZXNXcml0dGVuIiwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQiLCJyZXNwb25kV2l0aE5ld1ZpZXciLCJpc1ZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5b2JSZXF1ZXN0IiwiSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0IiwiZGVzaXJlZFNpemUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJjbG9zZSIsIl9jbG9zZVJlcXVlc3RlZCIsInN0YXRlIiwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UiLCJlbnF1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUiLCJlcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MiLCJfY2FuY2VsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsImVudHJ5IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4iLCJhdXRvQWxsb2NhdGVDaHVua1NpemUiLCJfYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiYnVmZmVyRSIsInB1bGxJbnRvRGVzY3JpcHRvciIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJieXRlc0ZpbGxlZCIsImVsZW1lbnRTaXplIiwidmlld0NvbnN0cnVjdG9yIiwicmVhZGVyVHlwZSIsIl9wZW5kaW5nUHVsbEludG9zIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJjb250cm9sbGVyIiwic2hvdWxkUHVsbCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIl9wdWxsaW5nIiwiX3B1bGxBZ2FpbiIsInB1bGxQcm9taXNlIiwiX3B1bGxBbGdvcml0aG0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvciIsImZpbGxlZFZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUiLCJjdXJyZW50QWxpZ25lZEJ5dGVzIiwibWF4Qnl0ZXNUb0NvcHkiLCJtaW4iLCJtYXhCeXRlc0ZpbGxlZCIsIm1heEFsaWduZWRCeXRlcyIsInRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmciLCJyZWFkeSIsInF1ZXVlIiwiaGVhZE9mUXVldWUiLCJieXRlc1RvQ29weSIsImRlc3RTdGFydCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJfYnlvYlJlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvIiwicmVhZEludG9SZXF1ZXN0IiwiRGF0YVZpZXciLCJCWVRFU19QRVJfRUxFTUVOVCIsImN0b3IiLCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdCIsImVtcHR5VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZSIsImZpcnN0RGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlIiwicmVtYWluZGVyU2l6ZSIsInJlbWFpbmRlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwiLCJkZXNjcmlwdG9yIiwiX3N0YXJ0ZWQiLCJmaXJzdFBlbmRpbmdQdWxsSW50byIsInRyYW5zZmVycmVkQnVmZmVyIiwidHJhbnNmZXJyZWRWaWV3IiwiUmVhZGFibGVTdHJlYW1FcnJvciIsIlNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIl9zdHJhdGVneUhXTSIsInZpZXdCeXRlTGVuZ3RoIiwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwic3RhcnRBbGdvcml0aG0iLCJwdWxsQWxnb3JpdGhtIiwiY2FuY2VsQWxnb3JpdGhtIiwiaGlnaFdhdGVyTWFyayIsInN0YXJ0UmVzdWx0IiwiciIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlIiwidW5kZXJseWluZ0J5dGVTb3VyY2UiLCJzdGFydCIsInB1bGwiLCJyZXF1ZXN0IiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIl9yZWFkSW50b1JlcXVlc3RzIiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQiLCJFeHRyYWN0SGlnaFdhdGVyTWFyayIsInN0cmF0ZWd5IiwiZGVmYXVsdEhXTSIsIkV4dHJhY3RTaXplQWxnb3JpdGhtIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneSIsImluaXQiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2luayIsIm9yaWdpbmFsIiwiYWJvcnQiLCJ0eXBlIiwid3JpdGUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrIiwiYXNzZXJ0V3JpdGFibGVTdHJlYW0iLCJJc1dyaXRhYmxlU3RyZWFtIiwiaXNBYm9ydFNpZ25hbCIsImFib3J0ZWQiLCJzdXBwb3J0c0Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NpbmsiLCJyYXdTdHJhdGVneSIsInVuZGVybHlpbmdTaW5rIiwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtIiwic2l6ZUFsZ29yaXRobSIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayIsImxvY2tlZCIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsIklzV3JpdGFibGVTdHJlYW1Mb2NrZWQiLCJXcml0YWJsZVN0cmVhbUFib3J0IiwiV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbUNsb3NlIiwiZ2V0V3JpdGVyIiwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIkNyZWF0ZVdyaXRhYmxlU3RyZWFtIiwid3JpdGVBbGdvcml0aG0iLCJjbG9zZUFsZ29yaXRobSIsImFib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwid2FzQWxyZWFkeUVycm9yaW5nIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3JpbmciLCJjbG9zZVJlcXVlc3QiLCJ3cml0ZXIiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0Iiwid3JpdGVSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbiIsIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQiLCJzdG9yZWRFcnJvciIsIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQiLCJhYm9ydFJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2UiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlIiwiYmFja3ByZXNzdXJlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0IiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUiLCJfcmVhZHlQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQiLCJfY2xvc2VkUHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZHlQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsInJlbGVhc2VkRXJyb3IiLCJjaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlIiwiY2xvc2VTZW50aW5lbCIsImFib3J0UmVhc29uIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJzaWduYWwiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiX2Fib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlIiwic3RhcnRQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkIiwiY2h1bmtTaXplRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkIiwiZW5xdWV1ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZSIsInNpbmtDbG9zZVByb21pc2UiLCJzaW5rV3JpdGVQcm9taXNlIiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJOYXRpdmVET01FeGNlcHRpb24iLCJET01FeGNlcHRpb24iLCJpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIiwiY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIndyaXRhYmxlIiwiRE9NRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbVBpcGVUbyIsInNvdXJjZSIsInByZXZlbnRDbG9zZSIsInByZXZlbnRBYm9ydCIsInNodXR0aW5nRG93biIsImN1cnJlbnRXcml0ZSIsImFjdGlvbnMiLCJzaHV0ZG93bldpdGhBY3Rpb24iLCJhbGwiLCJtYXAiLCJhY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGlwZUxvb3AiLCJyZXNvbHZlTG9vcCIsInJlamVjdExvb3AiLCJwaXBlU3RlcCIsInJlc29sdmVSZWFkIiwicmVqZWN0UmVhZCIsImlzT3JCZWNvbWVzRXJyb3JlZCIsInNodXRkb3duIiwiaXNPckJlY29tZXNDbG9zZWQiLCJkZXN0Q2xvc2VkIiwid2FpdEZvcldyaXRlc1RvRmluaXNoIiwib2xkQ3VycmVudFdyaXRlIiwib3JpZ2luYWxJc0Vycm9yIiwib3JpZ2luYWxFcnJvciIsImRvVGhlUmVzdCIsImZpbmFsaXplIiwibmV3RXJyb3IiLCJpc0Vycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbVRlZSIsImNsb25lRm9yQnJhbmNoMiIsIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZSIsInJlYWRpbmciLCJyZWFkQWdhaW4iLCJjYW5jZWxlZDEiLCJjYW5jZWxlZDIiLCJyZWFzb24xIiwicmVhc29uMiIsImJyYW5jaDEiLCJicmFuY2gyIiwicmVzb2x2ZUNhbmNlbFByb21pc2UiLCJjYW5jZWxQcm9taXNlIiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FuY2VsMUFsZ29yaXRobSIsImNvbXBvc2l0ZVJlYXNvbiIsImNhbmNlbFJlc3VsdCIsImNhbmNlbDJBbGdvcml0aG0iLCJDcmVhdGVSZWFkYWJsZVN0cmVhbSIsInJlYWRBZ2FpbkZvckJyYW5jaDEiLCJyZWFkQWdhaW5Gb3JCcmFuY2gyIiwiZm9yd2FyZFJlYWRlckVycm9yIiwidGhpc1JlYWRlciIsInB1bGxXaXRoRGVmYXVsdFJlYWRlciIsImNsb25lRSIsInB1bGwxQWxnb3JpdGhtIiwicHVsbDJBbGdvcml0aG0iLCJwdWxsV2l0aEJZT0JSZWFkZXIiLCJmb3JCcmFuY2gyIiwiYnlvYkJyYW5jaCIsIm90aGVyQnJhbmNoIiwiYnlvYkNhbmNlbGVkIiwib3RoZXJDYW5jZWxlZCIsImNsb25lZENodW5rIiwiQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtIiwiY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrIiwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSIsImNvbnZlcnRSZWFkZXJPcHRpb25zIiwib3B0aW9ucyIsIm1vZGUiLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlIiwiY29udmVydEl0ZXJhdG9yT3B0aW9ucyIsIkJvb2xlYW4iLCJjb252ZXJ0UGlwZU9wdGlvbnMiLCJhc3NlcnRBYm9ydFNpZ25hbCIsImNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU291cmNlIiwiSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxIiwiZ2V0UmVhZGVyIiwicmF3T3B0aW9ucyIsInBpcGVUaHJvdWdoIiwicmF3VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwicGlwZVRvIiwiZGVzdGluYXRpb24iLCJ0ZWUiLCJicmFuY2hlcyIsInZhbHVlcyIsImFzeW5jSXRlcmF0b3IiLCJzb3VyY2VDYW5jZWxQcm9taXNlIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQiLCJieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsImJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uIiwiY291bnRTaXplRnVuY3Rpb24iLCJDb3VudFF1ZXVpbmdTdHJhdGVneSIsIl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0NvdW50UXVldWluZ1N0cmF0ZWd5IiwiY291bnRCcmFuZENoZWNrRXhjZXB0aW9uIiwiY29udmVydFRyYW5zZm9ybWVyIiwiZmx1c2giLCJyZWFkYWJsZVR5cGUiLCJ3cml0YWJsZVR5cGUiLCJjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrIiwiVHJhbnNmb3JtU3RyZWFtIiwicmF3VHJhbnNmb3JtZXIiLCJyYXdXcml0YWJsZVN0cmF0ZWd5IiwicmF3UmVhZGFibGVTdHJhdGVneSIsIndyaXRhYmxlU3RyYXRlZ3kiLCJyZWFkYWJsZVN0cmF0ZWd5IiwidHJhbnNmb3JtZXIiLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJyZWFkYWJsZVNpemVBbGdvcml0aG0iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJ3cml0YWJsZVNpemVBbGdvcml0aG0iLCJzdGFydFByb21pc2VfcmVzb2x2ZSIsIkluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0iLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyIiwiX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfcmVhZGFibGUiLCJfd3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvciIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwicmVhZGFibGVDb250cm9sbGVyIiwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwidGVybWluYXRlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUiLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwidHJhbnNmb3JtQWxnb3JpdGhtIiwiZmx1c2hBbGdvcml0aG0iLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwidHJhbnNmb3JtUmVzdWx0RSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybSIsInRyYW5zZm9ybVByb21pc2UiLCJiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiZmx1c2hQcm9taXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\n");

/***/ })

};
;